unit unpok99_FrForm;

interface
{$I AMI_DATABASE.INC}
{$O-}

uses
  DialogsCZ, Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  Buttons, ExtCtrls, StdCtrls, ComCtrls,
  UnHecos, UnPok99P, UnPok99I,

{$IFDEF DATABASE_PARADOX}
  DBTables,
{$ENDIF}

{$IFDEF DATABASE_ACCESS}
  {$IFDEF DATABASE_ADO}
    ADODB,
  {$ELSE}
    DTables,
    {$IFDEF ACCESS_PARADOX}
      DDB, DMaster,
    {$ENDIF}
  {$ENDIF}
{$ENDIF}
  cnjhost, TabHost,
  UnAmiKon, UnPok99B, ImgList, ToolWin, Grids, TB97, TB97Tlwn, Menus; //, QuickRpt, Qrctrls;

Const
  PocKnZv = 10;

type
  TFrForm99 = class(TForm)
    PanelCelek: TPanel;
    ScrollBar1: TScrollBar;
    ScrollBar2: TScrollBar;
    PanelA: TPanel;
    PanelALeft: TPanel;
    PanelMeritkoY: TPanel;
    PaintBoxMeritkoY: TPaintBox;
    PanelATop: TPanel;
    PanelMeritkoX: TPanel;
    PaintBoxMeritkoX: TPaintBox;
    PanelBitBtn0: TPanel;
    BitBtn0: TSpeedButton;
    PanelPaint: TPanel;
    PaintBox1: TPaintBox;
    Panel1: TPanel;
    BitBtn1: TSpeedButton;
    BitBtn2: TSpeedButton;
    BitBtn3: TSpeedButton;
    BitBtn4: TSpeedButton;
    BitBtn5: TSpeedButton;
    BitBtn6: TSpeedButton;
    BitBtn7: TSpeedButton;
    BitBtn8: TSpeedButton;
    BitBtn9: TSpeedButton;
    BitBtn10: TSpeedButton;
    HSplitter: TSplitter;
    StatusBar1: TStatusBar;
    BottomDockPanel: TPanel;
    Timer2: TTimer;
    Timer4: TTimer;
    TimerAutoSave: TTimer;
{    ToolWindowStoup: TToolWindow97;
    PanelBV: TPanel;
    BitBtn11: TBitBtn;
    StringGridStoup: TStringGrid; }
{    ToolWindowFormF: TToolWindow97;
    ListBoxProtokolF: TListBox;
    PopupMenuFormF: TPopupMenu;}
    Dock971: TDock97;
    Dock972: TDock97;
    ToolWindowFormF: TToolWindow97;
    ListBoxProtokolF: TListBox;
    PopupMenuFormF: TPopupMenu;
    TiskProtokolF1: TMenuItem;
    ToolWindowStoup: TToolWindow97;
    PanelBV: TPanel;
    StringGridStoup: TStringGrid;
    BitBtn11: TBitBtn;
    ImageLogo_T_16: TImage;
    ImageLogo_V: TImage;
    PopupMenu2: TPopupMenu;
    VlozitBodKapilary1: TMenuItem;
    ZrusitBodKapilary1: TMenuItem;
    NBodyKapilary1: TMenuItem;
    Undo2: TMenuItem;
    Redo2: TMenuItem;
    N11: TMenuItem;
    Vyjmout2: TMenuItem;
    Kopirovat2: TMenuItem;
    KopirovatZrcadlove2: TMenuItem;
    ZrcadloSvisle2: TMenuItem;
    ZrcadloVodorovne2: TMenuItem;
    Vlozit2: TMenuItem;
    Odstranit2: TMenuItem;
    VybratVse2: TMenuItem;
    N12: TMenuItem;
    Panelynastroju2: TMenuItem;
    Konstrukce2: TMenuItem;
    Standardni2: TMenuItem;
    Zobrazeni2: TMenuItem;
    N13: TMenuItem;
    N101: TMenuItem;
    N102: TMenuItem;
    N107: TMenuItem;
    N103: TMenuItem;
    N104: TMenuItem;
    N105: TMenuItem;
    N106: TMenuItem;
    N108: TMenuItem;
    N109: TMenuItem;
    N110: TMenuItem;
    N111: TMenuItem;
    N1A: TMenuItem;
    BStatusbar1: TMenuItem;
    BStatusbar2: TMenuItem;
    N1B: TMenuItem;
    N113: TMenuItem;
    N112: TMenuItem;
    procedure WMDropFiles(var Msg: TWMDropFiles); message WM_DROPFILES;
    procedure PaintBox1MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure PaintBox1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure PaintBox1MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure PaintBox1DblClick(Sender: TObject);
    procedure ScrollBar2Change(Sender: TObject);
    procedure ScrollBar1Change(Sender: TObject);
    procedure PaintBox1Paint(Sender: TObject);
    procedure Timer2Timer(Sender: TObject);
    procedure HSplitterCanResize(Sender: TObject; var NewSize: Integer;
      var Accept: Boolean);
    procedure HSplitterMoved(Sender: TObject);
    procedure BitBtn0MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure BitBtn0MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure BitBtn0MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure Timer4Timer(Sender: TObject);
    procedure BitBtn0Click(Sender: TObject);
    procedure TimerAutoSaveTimer(Sender: TObject);
    procedure StringGridStoupDblClick(Sender: TObject);
    procedure StringGridStoupDrawCell(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TGridDrawState);
    procedure StringGridStoupSelectCell(Sender: TObject; ACol,
      ARow: Integer; var CanSelect: Boolean);
    procedure StringGridStoupKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure ToolFormBVCloseQuery(Sender: TObject;
      var CanClose: Boolean);
    procedure ToolFormBVClose(Sender: TObject);
    procedure TiskProtokolF1Click(Sender: TObject);
    procedure ListBoxProtokolFClick(Sender: TObject);
    procedure BottomDockPanelDockDrop(Sender: TObject;
      Source: TDragDockObject; X, Y: Integer);
    procedure BottomDockPanelDockOver(Sender: TObject;
      Source: TDragDockObject; X, Y: Integer; State: TDragState;
      var Accept: Boolean);
    procedure BottomDockPanelGetSiteInfo(Sender: TObject;
      DockClient: TControl; var InfluenceRect: TRect; MousePos: TPoint;
      var CanDock: Boolean);
    procedure BottomDockPanelUnDock(Sender: TObject; Client: TControl;
      NewTarget: TWinControl; var Allow: Boolean);
    procedure TopDock97Resize(Sender: TObject);

    procedure FrFormMouseWheel(Sender: TObject; Shift: TShiftState;
      WheelDelta: Integer; MousePos: TPoint; var Handled: Boolean);
    procedure FrFormKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure FrFormKeyPress(Sender: TObject; var Key: Char);
    procedure FrFormKeyUp(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure FrFormCreate(Sender: TObject);
    procedure FrFormDestroy(Sender: TObject);

    procedure PaintBoxMeritkoXPaint(Sender: TObject);
    procedure PaintBoxMeritkoYPaint(Sender: TObject);
    procedure BitBtn11Click(Sender: TObject);
    procedure PopupMenu2Popup(Sender: TObject);
    procedure VlozitBodKapilary1Click(Sender: TObject);
    procedure ZrusitBodKapilary1Click(Sender: TObject);
    procedure Undo2Click(Sender: TObject);
    procedure Redo2Click(Sender: TObject);
    procedure Vyjmout2Click(Sender: TObject);
    procedure Vlozit2Click(Sender: TObject);
    procedure Kopirovat2Click(Sender: TObject);
    procedure ZrcadloSvisle2Click(Sender: TObject);
    procedure ZrcadloVodorovne2Click(Sender: TObject);
    procedure Odstranit2Click(Sender: TObject);
    procedure VybratVse2Click(Sender: TObject);
    procedure Konstrukce2Click(Sender: TObject);
    procedure Standardni2Click(Sender: TObject);
    procedure Zobrazeni2Click(Sender: TObject);
    procedure N101Click(Sender: TObject);
    procedure N102Click(Sender: TObject);
    procedure N107Click(Sender: TObject);
    procedure N103Click(Sender: TObject);
    procedure N104Click(Sender: TObject);
    procedure N105Click(Sender: TObject);
    procedure N106Click(Sender: TObject);
    procedure N108Click(Sender: TObject);
    procedure N109Click(Sender: TObject);
    procedure N110Click(Sender: TObject);
    procedure N111Click(Sender: TObject);
    procedure BStatusbar1Click(Sender: TObject);
    procedure BStatusbar2Click(Sender: TObject);
    procedure N112Click(Sender: TObject);
    procedure N113Click(Sender: TObject);
  private
    { Private declarations }
    JeCtrl  : boolean;
    JeShift : boolean;
    JeAlt   : boolean;

    StoupClickCol, StoupClickRow : integer;
    StoupStrList : TStringList;
    StoupListBarev : TList;

    BylssShift : boolean;
    BylssLeft  : boolean;
    BylssMiddle : boolean;
    BylssRight : boolean;
    JeRovnaCara : boolean;
    BylFixniZacatek : boolean;
    PoOAmi : TPoint;
    PBoxDblCl : boolean;

    PointMousePaintboxDown : TPoint;
    PohnulMysivPB : boolean;
    QohnulMysivPB : boolean;
    ShDnMovePB : boolean;
    KnofZvets : Array[1..PocKnZv] of TSpeedButton;

    CBUch : integer;   // cislo bodu oznacene AMI, na ktery  kliknul mysi


    AktBodBM : TBitMap;
    BitMapGrid : TBitMap;
    BiMa : TBitMap;
    Sitnice : integer;

    HejbalObjektyNaTrubce : boolean;
    HejbalObjektyNaKapilare : boolean;

    AZmana : TPoint;
    Korka : TPoint;
    AbsGriq : TPoint;

    ObdBiMa : TRect;
//    MetF : TMetafile;
    PoAAmi : TPoint;

    TextTextik : String;

    CisloBoduKapilary : integer;
    NovyBodKapilary : TPoint;

    BottomDockPanelHeight : integer;

    AktCisloKurzoru : integer;
    AktCisloKurzorv : integer;    // pri stisknuti prostredniho knofliku mysi si pamatuje AktCisloKurzoru

    PohnoutViceTrubkami : boolean;
    // TRUE   stiskne CTRL+SHIFT+mys na spolecnem bode vice trubek a muze jim
    // pohnout, pricemz koncove body zustanou na miste
    PohnoutViceRadKot : boolean;
    // TRUE   stiskne CTRL+SHIFT+mys na radiatoru, kotli a muze mysi pohnout tak,
    // ze necha stat konec privodnich trubek na miste

    BoPVenti3 : TPoint;
    BoKVenti3 : TPoint;  { pro roztahovani nebo smrstovani VENTI3 }

    ProtokolListFormF : TStringList;

    SourFormP : TPoint;

    ZoomKrizem : Boolean;

    Procedure ZobrazNeaktivniLogo;
    procedure SchovejFormP;

    procedure FrFormKeyDownOld(Sender: TObject; var Key: Word; Shift: TShiftState);

    Function UlozList_99(AList : TAmiList; Co : integer) : boolean;
    Procedure ZobrazitKontrolu_99(AChecked, AEnabled : boolean);

    Procedure ZoomZpet;
    Procedure ZoomTam;
    Procedure DelejProvedZoom(APosX, APosY, AKoefInt : integer);

    Function AUlozitProjekt_99 : boolean;
    procedure UdelejAktControl_99(WinControl : TWinControl);
//    Procedure SpocitejPosScrollOld;
    Procedure PrepocitejGrid(Koef : extended);
    Procedure KnofZvClick(Sender: TObject);

    Procedure CarkaNaPravitkuX; // nakresli odpovidajici carky na pravitkuX
    Procedure CarkaNaPravitkuY; // nakresli odpovidajici carky na pravitkuY
    Procedure CarkyNaPravitkach;
    Procedure MysiKriz(SH : TShiftState; Pohnul, jak : boolean);
    Procedure DelejAktBod(ABod : TPoint);

    procedure DelejPohniViceKotRad(ABod : TPoint;
           CoDelat : integer; Kreslit, KonecRotace : boolean);
              { Hybe s objekty na trubce pri pohybu mysi }
    Procedure PohniKoncemKapilary(APocatek : TPoint; AKapilara : TArrayPoints; ABodKotva : TPoint;
          AUhel : extended; AKreslit : boolean);
    Procedure OtocObjektemAC(AAC : TAmiClass; ABodKotva : TPoint;
          AUhel : extended; AKreslit : boolean);
    procedure DelejPohniViceTrubkami(ABod : TPoint; Kreslit, KonecRotace : boolean);
    procedure DelejPohniObjektyNaTrubce(ABod : TPoint; AT : TAmiClass;
                        PevnyPocatek, Kreslit, KonecRotace : boolean);
    procedure DelejPohniObjektyNaKapilarachb(ABod : TPoint; AT : TAmiClass;
                        CisloBodu : integer; Kreslit, Prepocitat : boolean);
    Procedure KresliSymbol(Canvas : TCanvas; var Bodik : TPoint;
                 SH : TShiftState; Pohnul, jak : boolean);
    Procedure NajdiBodSpojAmi(Bod : TPoint; Sh : TShiftState; Jak : integer);
    procedure DelejKreslAbs(Bod : TPoint);
    Procedure AktAmiOznKurzor_99(X, Y : integer);
    Procedure PrepocitejObloucek_99(Bod : TPoint; SH : TShiftState);
    Function NicSeNedeje_99 : boolean;
    Procedure NajdiObjektAmi(Bod : TPoint; SH : TShiftState; Jak : integer);
    Procedure DelejZoom_99(Bod1, Bod2 : TPoint; Zvetsit : integer; Kolikrat : extended);

    Function ZadejAmiSoucAAA_99(AmiSoucAAA : TAmiSoucAAA; Opravuje : boolean) : boolean;
    Function ZadejBarvaTypStylCary_99(AmiClass : TAmiClass; prevzit : boolean) : integer;
    Function ZadejBarvaTypStylElipsy_99(AmiClass : TAmiClass; prevzit : boolean) : integer;
    Function ZadejBarvaTypStylOblouku_99(AmiClass : TAmiClass; prevzit : boolean) : integer;
    Function ZadejPolohuRazitka_99(ARazitko : TAmiRazitko; Opravuje : boolean) : boolean;
    Procedure ZadejPopisVyska_99(AmiClass : TAmiClass);

    Procedure DelejVlozAmi(AbsBod : TPoint; ACisloCimJede : integer);

    Function DelkyTrubekT1T2_99(ATyp : integer) : boolean;
    Procedure StoupPrekresli;
    Function ObsluzStoupStrList : integer;
    Procedure KompreseStoupStrList(Prekreslit : boolean);

    procedure PripravUkazkuFormE(AList : TAmiList);
    procedure DelejUpravStropy_99(Bod1, Bod2 : TPoint);
    procedure UmozniSchovatListy_99;

    Procedure SpoctiKorku_99;
    procedure UkazOblastProTisk_99;

    procedure NastavToolB97Zobr5_6_FormA(ZoomZpet, ZoomVpred : boolean);
    Procedure DelejVymazVypocet_99;

    function CtiProjekt_99(AJmeno : String) : integer;
     public
    { Public declarations }
    AFormP : TFormP;
    AFormI : TFormI;
    AForm_A : TForm;
    AForm99 : TForm;
    AConjoinDockHost : TConjoinDockHost;
    ATabDockHost: TTabDockHost;
    ATopChlad : TTopChlad;
    OtevrenyProjekt : boolean;

    BeforeMoveLeft, BeforeMoveTop : integer;
    CitacKlikuObloucku : integer;
    RObloucku : integer;
    StredObloucku : TPoint;
    BodObloucku1, BodObloucku2 : TPoint;
    Alf1Obloucku, Alf2Obloucku : integer;
    JakObloucek : integer;
    VkladatObloucky : boolean;

    KoefZvetseni : Extended;
    PocAmi : TPoint;
    PocPacka : TPoint;

//    TopChlad : TTopChlad;
    LevyO, HorniO, PravyO, DolniO : integer;
    MuzeScroll : boolean;  // musi byt FALSE pri ScrollBarChange !!!

    Kotva, Kotvb : TPoint;
    AKatva, AKatvb : TPoint;
    Myska : TPoint;

    CisloCimJede_99 : integer;
    CisloCimJedf_99 : integer;

    CisloSymbolu : integer;
    CisloSymbolv : integer;

    // vyrez pro tisk
    BDelejOblastProTisk : boolean;
    JeOblastProTisk : boolean;
    VyrezTiskuB1 : TPoint;
    VyrezTiskuB2 : TPoint;

    // Rozdelit stropy
    BDelejRozdelStropy : boolean;

    BarvyStoupacekList : TList;   // seznam barev pro stoupacky pri volbe

    ListNastaveniZoomu : TList;
    PosicevNastZoomu : integer;
    AIzolace : StringSymbR;
    ASklon : integer;
    SkrytFormP : boolean;

//    procedure FrFormCreate(Sender: TObject);
//    procedure FrFormDestroy(Sender: TObject);
    class function CreateAsSubform(AOwner: TCustomForm; AParent: TPanel): TFrForm99;

    procedure UvolniToolWindows;

{    procedure FrFormKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure FrFormKeyPress(Sender: TObject; var Key: Char);
    procedure FrFormKeyUp(Sender: TObject; var Key: Word;
      Shift: TShiftState); }

    Function BJsouTepelneZtraty : boolean;
    Function ProjektTepelnychZtrat : String;

    procedure ZobrazAbsList(AList : TAmiList; ABod : TPoint);
    Procedure DelejVyberKurzor_99Old(CisloKurzoru : integer);
    Procedure DelejVyberKurzor_99(CisloKurzoru : integer);


    procedure JakobyPageControlChange;

    procedure OblastProTisk1Click_99;
    procedure DelejVlozit1Click_99;
    Procedure DelejUmozniUNDO_99;
    procedure Odstranit1Click_99;

    Procedure DelejUmozniUNDQ_99(KodUndo, KodZmeny : integer; AC : TAmiClass; List : TAmiList);
    Procedure DelejPrvniREDQ_99(KodUndo, KodZmeny : integer; AC : TAmiClass; List : TAmiList);
    Procedure DelejVratKrokUNDQ_99;

    procedure Novy1Click_99;
    procedure Precti1Click_99;
    procedure Undo1Click_99;
    procedure Redo1Click_99;
    Procedure VidPanel3_99(jak : boolean);
    Function DelejDelete_99 : boolean;
    Function UlozitProjekt_99 : boolean;

    Procedure ParProjektu1Click_99;
    procedure DelejInvalidu_99;
    Procedure DelejMoveAmi_99(AmiClass : TAmiClass);
    Procedure DelejTabulky_99;

    Procedure DokonciNastaveniZoom_99;
    Procedure DelejZrusNastZoomu_99;
    Procedure VlozNovyZoom_99(APosX, APosY : integer; AKoef : extended);
    procedure Zoomuj_99(Bod : TPoint; AWheelDelta : integer; var AHandled : boolean);

    procedure ToolBZobr4Click_99;
    procedure ToolBZobr5Click_99;
    procedure ToolBZobr6Click_99;

    procedure VybratVse1Click_99;
    procedure Vyjmout1Click_99;

    procedure ParPopisProjektu1Click_99;
    procedure OznacitMistnosti1Click_99;
    procedure TiskProjektu1Click_99;

    procedure OznacitStoupacku1Click_99;

    procedure AToolB97Click_99(ATag : integer);
    procedure SpdButClick_99(ATag : integer);
    Procedure VidPanel1_99(Jak : boolean);

    procedure ToolB97Zobr7Click_99;
    procedure ToolB97Zobr8Click_99;
    procedure AZrusitVyrezproTisk1Click_99;
    Function DelejOknoproClipBoard_99(var ASir, AVys : integer;
                                       var AObdVyrezu : TRect) : String;
    procedure AKopirovatOkno1Click_99;
    procedure DelejUkazatOznaceniVetvi_99(Ukazat : boolean);
    procedure ASkrytOknoPClick_99(ASkrytFormP : boolean);

    procedure DXF1Click_99;
    procedure AZmenitTopeniChlazeni1Click_99;

    Function DelejCtiProjekt_99(JmenoSouboru : String; ZobrazitHlasku : boolean) : boolean;
    function DelejPrecti1Click_99(AJmeno : String) : integer;
    procedure VlozitBodKapilary1Click_99;
    procedure ZrusitBodKapilary1Click_99;
    procedure Kontrolaprojektu1Click_99;
    procedure UlozJakoModul1Click_99;
    procedure UlozJakoSablonu1Click_99;
    procedure UlozJako1Click_99;
    Procedure SchovejFormF_99;
    procedure PripravFormF_99;

    procedure DelejVyplnRazitko_99;
    Function ZavritProjekt_99 : boolean;
    procedure Uloz1Click_99;
    procedure DelejVlozdoClipboardu_99;
    procedure NastavPrazdnyProjekt_99;
    procedure NastavDataPrazdnehoProjektu_99;
    Procedure SpocitejPosScroll_99;

    Function NovyProjekt_99(Jmeno : String) : boolean;

    procedure Kontrolamodul1Click_99;
    procedure KontrolaDatproVypocet1Click_99;
    procedure Vypocet1Click_99;
    procedure TiskObrazovky1Click_99;
    procedure APrevzitDatazTEZClick_99;
    procedure DoplnitTepelneVykony1Click_99;
    procedure KontrolaMistnostiClick_99;
    procedure NedotahyPotrubi1Click_99(AUkazatVolneKoncePotrubi : boolean);
    procedure GenerovatZeslTrub1Click_99(AGenerovatZeslTrub1 : boolean);
    procedure GenerovatSmerVody1Click_99(AGenerovatSmerVody1 : boolean);
    procedure ZrcadloSvisleClick_99;
    procedure ZrcadloVodorovneClick_99;
    Procedure UkazForm_99(AForm : TForm);
    procedure ShowDockPanel_99(APanel: TPanel; MakeVisible: Boolean; Client: TControl);
    Procedure SchovejFormBV_99;

    procedure ToolBStr3Click_99;
    procedure APrivodniZpatecka1Click_99;
    procedure AZpateckaPrivodni1Click_99;
    procedure AUkazFixDiamTr1Click_99;
    procedure Cooling_x_Heating_99(ACooling : boolean);

    Procedure DelejOznAmi_99(AmiClass : TAmiClass);

    Function NajdivAmiList_99(AList : TAmiList; AC : TAmiClass) : TAmiClass;
    Function ListUspVen2_99(Item1, Item2: Pointer): Integer;   virtual;
    Function DejMouCimru_99(AR : TAmiClass) : TAmiClass;
    Function DejVentCimru_99(AV : TAmiClass) : TAmiClass;

    procedure PosunSmer_99(Cislo : integer);
    procedure ZobrazitKontrolu1Click_99;

    Function VlozitSoubor1Click_99 : boolean;
    procedure DelejFormN_99;
    procedure DelejVlozClipboard_99(ABod : TPoint);
    Procedure DelejUmozniUpravy_99;
    procedure DelejZakazUNDO_99;
    procedure DelejZakazREDO_99;
    procedure DelejOpravVztahy_99;
    Procedure DelejOznzListu_99(AList : TAmiList);

    procedure DelejUkazveVypoctu_99;
    procedure TlacitkaPriJednotrubce_99;
    Procedure TlacitkaSchemat_99;
    Function DelejPrectiProjekt_99(JmenoSouboru : String) : integer;

    procedure KopirovatZrcadloveSvislaOsa_99;
    procedure KopirovatZrcadloveVodorovnaOsa_99;

    procedure RozdelitStropy1Click_99; //(jak : boolean);
    procedure NastavTimerAutoSave;

    Procedure VKESCAPE_99;  // pri stisknuti ESC
  end;

const
  SFCaptionVysledkyKontroly : String = 'Výsledky kontroly';
  SFCaptionChybypriVypoctu : String = 'Chyby při výpočtu';

  SFBitBtn9Caption : String = 'Celý pr.';
  SFBitBtn10Caption : String = 'Výřez';
  SFBitBtn11Caption : String = 'Normální zobrazení';
  SFFormBVCaption : String = 'Větve';

  JmenoSablony : String = '';
  JmenoModulu : String = '';
  JmenoVlozeneho : String = '';

  SingleWindow : boolean = TRUE;
  StatusBarVisible : boolean = TRUE;
  ScrollBarsVisible : boolean = TRUE;
  BZobrazitGrid : boolean = FALSE;

  ModusOvladani : integer = 0; // 0: klasik (toolbar97)
                               // 1: ribbon

  BViditelneSipkyNaListach : boolean = FALSE;
  BZalozniKopie : boolean = FALSE;
  BSamoUkladani : boolean = TRUE;
  IIntUkladani : integer = 15;
  BPtatseUlozit : boolean = FALSE;  // ptat se na ulozeni projektu, pokud nebyla zmena

  HesCos : integer = 0;  // -1 jen topeni, 0 topeni i chlazeni, 1 jen chlazeni


  GlobalneMoveToolW97 : boolean = TRUE;

//var
//  AFormatSettings : SysUtils.TFormatSettings;


var
  Trub5Sila    : integer;
  Trub5Barva   : integer;
  Trub5Styl    : integer;
  CaraSila     : integer;
  CaraBarva    : integer;
  CaraStyl     : integer;
  ObdCaraSila  : integer;
  ObdCaraBarva : integer;
  ObdVzorStyl  : TBrushStyle;
  ObdVzorBarva : integer;
  EliCaraSila  : integer;
  EliCaraBarva : integer;
  EliVzorStyl  : TBrushStyle;
  EliVzorBarva : integer;

  TextFont : TFont;
  PosRad1 : TAmiRad1;
  PosRad2 : TAmiRad2;
  PosChladic1 : TAmiRad2;
  PosOTChladic1 : TAmiOTChladic1;
  PosKotel : TAmiKotel;
  PosSchema : TAmiSchema;
  PosPoleSchemat : array[1..ImplementPocetSchemat] of TAmiSchema;
  PosPneuH : TAmiPneuH;
  PosPolePneuH : array[TypPneuH..TypPneuH+79] of TAmiPneuH;

const
  SymUpravStropy = -1;
  SymOblastProTisk = -2;

  SymPosunVykres = -31;
  SymPosunDoStredu = -32;
  SymDelejZoomLupa = -33;
  SymDelejZoomKriz = -34;
  SymVyberTam =  -35;
  SymVyberZpet = -36;
  SymJedeKrizem = 19;

const
  crPACKA = 301;
  crSTREDA = 302;
  crLUPA = 303;
  crCtrlShift = 304;
  crVENTILOTOC = 305;
  crVYBERTAM = 306;
  crVYBERZPET = 307;

  PocetKurzoru = 202;
  JmenaKurzoru : array[1..PocetKurzoru] of PChar {String[10]} =
  ('A1','A2','A3','A4','A5','B1','B2','B3','B4','B5','B6','B7','B8',
   'TRUBKA01','TRUBKA02','TRUBKA03','TRUBKA04','TRUBKA05',
   'TRUBKA06','TRUBKA07','TRUBKA08','TRUBKA09','TRUBKA10',
   'TRUBKA11','TRUBKA12','TRUBKA13','TRUBKA14','TRUBKA15',
   'TRUBKA16','TRUBKAC1','TRUBKAC2',
   'RAD01','RAD02','RAD03','RAD04','RAD05','RAD06','RAD07','RAD08','RAD09','RAD10',
   'RAD11','RAD12','RAD13','RAD14','RAD15','RAD16','RAD17','RAD18','RAD20',
   'VENTIL01','VENTIL02','VENTIL03','VENTIL04','VENTIL05',
   'VENTIL06','VENTIL07','VENTIL08','VENTIL09','VENTIL10',
   'VENTIL11','VENTIL12','VENTIL13','VENTIL14','VENTIL15','VENTIL16','VENTPRUTOKOMER',
   'C1','C2','C3','C4','C5','C6','C7','C8','C9','C10','G1','G2','G3','G4','G5','G6',
{77}  'G7','NUZKY1','NUZKY2','ALFA',
   'A6', 'A7', 'A8', 'A9',
   'M1', 'M2','M3','M4','M5','M6','M7','M8','M9',  {91}
   'VN01','VN02','VN04','VN05','VN06','VN07','VN08','VN09','VN10',
   'VN11','VN12','VN13','VN14','VN15','VN16','VN17','VN18','VN19','VN20',
   'VN21','VN22','VN23','VN24','VN25','VN26','VN27','VN28','VN29',
   'VENTB0','VENTB1','VENTB2','VENTB3','VENTB5','VENTB6','VENTB7','VENTB8',
   'SR01','SR02','TRUBCARA1','TRUBCARA2','TRUBCARA3','TRUBCARA4','TRUBCARA5',
   'TRUBCARA6','TRUBCARA7','TRUBCARA8','TRUBCARA9','TRUBCARA10',
   'PACKA','STREDA','RAZITKO','LUPA','CTRLSHIFT','VENTILOTOC','NUZKYSTROP',
   'NUZKYTISK','VYBERTAM','VYBERZPET','SCHEMA01',
   'SCHEMA02', 'SCHEMA03','SCHEMA04','SCHEMA05','SCHEMA06',
   'CHLADIC1', 'OTRAD1', 'OTRAD2',
   'VentAB0', 'VentAB1', 'VentAB2', 'VentAB3', 'VentAB4',
   'VENT_SHUTOFF', 'SEP_SLUDGE', 'SEP_MICROB', 'SEP_MICSLUD', 'VENT_AIR',
   'STATICO_SD', 'STATICO_SU', 'STATICO_SG',
   'COMPRESO_C', 'COMPRESO_CPV', 'COMPRESO_CU', 'COMPRESO_CG',
   'TRANSFERO_T', 'TRANSFERO_TP', 'TRANSFERO_TV', 'TRANSFERO_TPV', 'TRANSFERO_TU',
   'TRANSFERO_TG', 'TRANSFERO_TI', 'TRANSFERO_TGI',
   'VENTO_V', 'VENTO_VP',
   'AQUAPRESSO_AD', 'AQUAPRESSO_AU', 'AQUAPRESSO_AG',
   'INTERVESSEL_DD', 'INTERVESSEL_DU', 'INTERVESSEL_DG',
   'PLENO_P', 'PLENO_PI');

  PocetKurzorw = 320;
  OznKurzoru : array[0..PocetKurzorw] of Pchar {String[10]} =
     ('','VentAB0','VentAB1','VentAB2','VentAB3','VentAB4',
{6}   'TRUBKAC1','TRUBKAC2','TRUBKAC1','TRUBKAC2','TRUBKA01',    // predelat trubkaC na trubkaB
{11}   'TRUBKA01','TRUBKA02','TRUBKA03','TRUBKA04','TRUBKA05',
      'TRUBKA06','TRUBKA07','TRUBKA08','TRUBKA09','TRUBKA10',
{21}   'TRUBKA11','TRUBKA12','TRUBKA13','TRUBKA14','TRUBKA15',
      'TRUBKA16','A1','A2','A3','A4',
{31}   'VENTB0','VENTB1','VENTB2','VENTB3','',
      'VENTB5','VENTB6','VENTB7','VENTB8','140',
{41}   'VN01','VN14',{'VN02',}'VN06','VENTIL05','VN12',{'VN09',}
     'VENTIL06','VENTIL07','VENTIL08','VENTIL09','VENTIL10',
{51}   'VENTIL11','VENTIL12','VENTIL13','54','ALFA',
     '56','VN04','VN05', 'VENTIL_DPC', 'VN08',
{61}   'C1','C2','C3','C4','C5','C6','C7','C8','C9','C10',
{71}   'B1','B2','B3','B4','B5','B6','B7','B8','','',
{81}   'RAD01','RAD02','RAD03','RAD04','RAD05','RAD06','RAD07','RAD08','RAD09','RAD10',
{91}   'RAD16','RAD17','RAD18','RAD11','RAD12','RAD13','RAD14','RAD15','RAD20','100',

{101} 'G1','G2','G3','G4','G5','G6','RAZITKO','G7','OTRAD1','OTRAD2',
{111} 'TRUBKA14','TRUBKA04','TRUBKA05','TRUBKA06','TRUBKA07',
         'TRUBKA08','TRUBKA09','TRUBKA10','TRUBKA11','TRUBKA12',
{121} 'TRUBKA13','SR01','SR02','TRUBKA15','TRUBKA16',
        'B6','B7','B1','B2','',
{131} 'SCHEMA01', 'SCHEMA02','SCHEMA03','SCHEMA04','SCHEMA05','SCHEMA06',
      'SCHEMA07', 'SCHEMA08','SCHEMA09','SCHEMA10',
{141} 'C6','C7','C8','C9','C10', 'RAD11','RAD12','RAD14','RAD15','CHLADIC1',
{151} 'VN25','VN26','VN27','VN28','VN29','VN18','VN19','VN20','VN21','160',
{161} 'VENTPRUTOKOMER','VN23','VN24','VENTIL02','VENTIL03', 'M1','M2','M3','M4','M5',
{171} 'M6','M7','M8','M9', 'TRUBCARA10',
{176} 'TRUBCARA1','TRUBCARA2','TRUBCARA3','TRUBCARA4','TRUBCARA5',
{181} 'VN11','VN12','VN13','VN14','VN15','VN16','VN17','188','189','190',
{191} 'A1','A2','A3','A4','A5',{'A6','A7',}
{196} 'SCHEMA13', 'SCHEMA14', 'A8','A5','200',

{201}  'VENT_AIR', 'VN25', 'VENT_SHUTOFF', '204', '205',
       '206', 'SEP_SLUDGE', 'SEP_MICROB', 'SEP_MICSLUD', '210',
{211}  'STATICO_SD', 'STATICO_SU', 'STATICO_SG', '214', '215', '216', '217', '218', '219', '220',
{221}  'COMPRESO_C', 'COMPRESO_CPV', 'COMPRESO_CU', 'COMPRESO_CG', '225', '226', '227', '228', '229', '230',
{231}  'TRANSFERO_T', 'TRANSFERO_TP', 'TRANSFERO_TV', 'TRANSFERO_TPV', 'TRANSFERO_TU',
       'TRANSFERO_TG', 'TRANSFERO_TI', 'TRANSFERO_TGI', '239', '240',
{241}  'VENTO_V', 'VENTO_VP', '243', '244', '245', '246', '247', '248', '249', '250',
{251}  'AQUAPRESSO_AD', 'AQUAPRESSO_AU', 'AQUAPRESSO_AG', '254', '255', '256', '257', '258', '259', '260',
{261}  'INTERVESSEL_DD', 'INTERVESSEL_DU', 'INTERVESSEL_DG', '264', '265', '266', '267', '268', '269', '270',
{271}  'PLENO_P', 'PLENO_PI', '273', '274', '275', '276', '277', '278', '279', '280',
{281}  '281', '282', '283', '284', '285', '286', '287', '288', '289', '290',
{291}  '291', '292', '293', '294', '295', '296', '297', '298', '299', '300',

   'PACKA','STREDA','LUPA','CTRLSHIFT','VENTILOTOC','VYBERTAM','VYBERZPET',
   '308','309','310',
   'NUZKYSTROP','NUZKYTISK','313','314','315','316','317','318','319','320');

const
  TrubkyCaryH : array[0..3] of PChar = ('TRUBCARA1','TRUBCARA2','TRUBCARA3','TRUBCARA4');
  TrubkyCaryC : array[0..3] of PChar = ('TRUBCARA6','TRUBCARA7','TRUBCARA8','TRUBCARA9');

Procedure Inicializace_PosRad;
Procedure Uvolneni_PosRad;
Procedure AAFormKeyPress(var Key: Char);

Procedure KresliSpoje(AList : TAmiList; Canvas : TCanvas;
   AKoef : extended; PocSour : TPoint;
   KonceTrubekSpojX,KonceTrubekSpojY : TList;
   KonceTrubekVolX,KonceTrubekVolY : TList;
   var DelatSpojeTr : boolean;
   co : integer);

Function UdelejSingleFrForm99(AAFrForm99 : TFrForm99; Jak : integer; JmenoSouboru : String) : boolean;
Function DejZakladniCaption : String;

Type
  PPosiceOknaZ = ^TPosiceOknaZ;
  TPosiceOknaZ = record
    PosX, PosY, KoefInt : integer;
  end;

var
  AktFrForm99 : TFrForm99;

  DataDirectory : String;

implementation

uses
  Clipbrd, Registry, DB, ShellAPI, Consts,
  Printers, Math, IniFiles, AdvGrid,
  UnPok99_9,
  UnAStr1, UnAStr2,
  Un99Logo, UnPok991, {UnPok99P,} UnPok99C,
  UnPok99D, UnPok990, {UnPok99E,} {UnPok99F,} UnPok99G, {UnPok99I,}
  UnPok99J, UnPok99KvKalk, {UnPok99Z,} UnPok99L, UnPok99M, UnPok99N, UnPok99O,
  UnPok99Q, UnPok99U,
{$IFDEF VER130}
  UnPoT99A, UnPoT99BH, UnPoT99BC,
{$ELSE}
  Variants,
{$ENDIF}
  UnPokF2, UnPok99V, UnPok99R, UnPokF1,
  UnPokTZ1, UnPokTZ2, {cnjhost, TabHost, }{UnPokBV1,} UnPot99O,
  UnPot99Q, UnIntern01B, UnPok99S, unpok99a, UnPok99E, UnPok99_Rb1;

{$R *.DFM}

const
  DifHSplitter = 1;

Function SpSit(AK : Extended) : integer;
begin
  if AK*JMetr>=25 then begin
    Result := 100;
  end else begin
    if AK*JMetr>=10 then begin
      Result := 200;
    end else begin
      Result := 1000;
    end;
  end;
end;

Procedure PripravGrid(BitMap : TBitMap; AKoef : Extended; Barva : integer;
          AGriq : TPoint);
var
  i,j : integer;
  X,Y,AbsX,AbsY : integer;
  BHL, BDP : TPoint;
  NX,NY : integer;
  PoleX,PoleY : Array[0..1024] of integer;
begin
  BitMap.Width := Screen.Width;
  BitMap.Height := Screen.Height;
  with BitMap.Canvas do begin
    Brush.Color := BarvaPozadiObr;
    Brush.Style := bsSolid;
    FillRect(Rect(0, 0, BitMap.Width, BitMap.Height));

    if AKoef>0.5 then begin
      DelejSpocitejBodGrid(Point(0,0),Point(0,0),AGriq,AKoef, BHL);
      DelejSpocitejBodGrid(Point(0,0),Point(BitMap.Width,BitMap.Height),
                           AGriq,AKoef, BDP);
      NX := Round((BDP.X-BHL.X)/AGriq.X)+2;
      NY := Round((BHL.Y-BDP.Y)/AGriq.Y)+2;
      for j := 0 to NY do begin
        Y := BDP.Y+j*AGriq.Y;
        PoleY[j] := Round(-Y*AKoef*JMetrMM);
      end;
      for i := 0 to NX do begin
        X := BHL.X+i*AGriq.X;
        PoleX[i] := Round(X*AKoef*JMetrMM);
      end;
      for j := 0 to NY do
        for i := 0 to NX do
          Pixels[PoleX[i],PoleY[j]] := Barva;
    end;
  end;
end;

Procedure MeritkoX(Canvas : TCanvas; AKoef : Extended;
  APocatek : TPoint; Sir : integer);
const
  Minm = 10;

var
  R : TRect;
var
  Sit : Integer;
  D : integer;
  X,XD,BbsX : integer;
  S : String;
  i,j : integer;
  AocX : integer;
begin
  Sit := SpSit(AKoef);
  With Canvas do begin
    Pen.Mode := pmCopy;
    Brush.Color := clLtGray;
    Pen.Color := clBlack;
    R.Left := 0;
    R.Top := 0{+1};
    R.Right := Sir;
    R.Bottom := VysMer;
{    FillRect(R); }
    With R do
      Rectangle(Left, Top, Right, Bottom);

    Font.Name := 'MS Sans Serif';
    Font.Size := 8;
    Font.Style := [];
    Font.Color := BarvaMeritka;

    Pen.Color := BarvaMeritka;
    Brush.Style := bsClear;
    Pen.Color := BarvaMeritka;
    Brush.Style := bsClear;
    AocX := Round(APocatek.X*AKoef*JMetrMM);
{    IntersectClipRect(Canvas.Handle, LeO, AHO, Sir, HoO); }

    j := APocatek.X div Sit;
    for i := 0 to 32767 do begin
      XD := (i+j)*Sit;
      BbsX := Round(XD*AKoef*JMetrMM)-AocX;
      if BbsX>=0 then begin

        if ((i+j) mod 5)=0 then begin
          D := 7
        end else begin
          D := 4;
        end;

 //       BbsX := BbsX+LeO;
        if BbsX>Sir then Break;

        MoveTo(BbsX, VysMer-1);
        LineTo(BbsX, VysMer-D);
        if ((i+j) mod 10)=0 then begin
          S := IntToStr(((i+j)*Sit) div 1000);
          TextOut(BbsX-TextWidth(S) div 2,{AHO+}2,S);
        end;
      end;
    end;
  end;
end;

Procedure MeritkoXOld(Canvas : TCanvas; AKoef : Extended;
  APocatek : TPoint; ALO,AHO,Sir,Vys : integer);
const
  Minm = 10;

var
  R : TRect;
  LeO,HoO : integer;
var
  Sit : Integer;
  D : integer;
  X,XD,BbsX : integer;
  S : String;
  i,j : integer;
  AocX : integer;
begin
  Sit := SpSit(AKoef);
  LeO := ALO+SirMer;
  HoO := AHo+VysMer;
  With Canvas do begin
    Pen.Mode := pmCopy;
    Brush.Color := clLtGray;
    Pen.Color := clBlack;
    R.Left := Leo;
    R.Top := AHO{+1};
    R.Right := Sir;
    R.Bottom := HoO;
{    FillRect(R); }
    With R do
      Rectangle(Left, Top, Right, Bottom);

    Font.Name := 'MS Sans Serif';
    Font.Size := 8;
    Font.Style := [];
    Font.Color := BarvaMeritka;

    Pen.Color := BarvaMeritka;
    Brush.Style := bsClear;
    Pen.Color := BarvaMeritka;
    Brush.Style := bsClear;
    AocX := Round(APocatek.X*AKoef*JMetrMM);
{    IntersectClipRect(Canvas.Handle, LeO, AHO, Sir, HoO); }

    j := APocatek.X div Sit;
    for i := 0 to 32767 do begin
      XD := (i+j)*Sit;
      BbsX := Round(XD*AKoef*JMetrMM)-AocX;
      if BbsX>=0 then begin

        if ((i+j) mod 5)=0 then begin
          D := 7
        end else begin
          D := 4;
        end;

        BbsX := BbsX+LeO;
        if BbsX>Sir then Break;

        MoveTo(BbsX,HoO-1);
        LineTo(BbsX,HoO-D);
        if ((i+j) mod 10)=0 then begin
          S := IntToStr(((i+j)*Sit) div 1000);
          TextOut(BbsX-TextWidth(S) div 2,AHO+2,S);
        end;
      end;
    end;
  end;
end;

Procedure MeritkoY(Canvas : TCanvas; AKoef : Extended;
  APocatek : TPoint; Vys : integer);
const
  Minm = 10;

var
  R : TRect;
var
  Sit : Integer;
  D : integer;
  Y, YD, BbsY : integer;
  S : String;
  i,j : integer;
  AocY : integer;
begin
  Sit := SpSit(AKoef);
  With Canvas do begin
    Pen.Mode := pmCopy;
    Brush.Color := clLtGray;
    Pen.Color := clBlack;

    R.Left := 0;
    R.Top := 0;
    R.Right := SirMer;
    R.Bottom := Vys;
{    FillRect(R); }
    With R do
      Rectangle(Left, Top, Right, Bottom);

    Font.Name := 'MS Sans Serif';
    Font.Size := 8;
    Font.Style := [];
    Font.Color := BarvaMeritka;

    Pen.Color := BarvaMeritka;
    Brush.Style := bsClear;
    AocY := Round(APocatek.Y*AKoef*JMetrMM);

    j := APocatek.Y div Sit;
    for i := 0 to 32767 do begin
      YD := (j-i)*Sit;
      BbsY := AocY-Round(YD*AKoef*JMetrMM);
      if BbsY>=0 then begin

        if ((j-i) mod 5)=0 then begin
          D := 7
        end else begin
          D := 4;
        end;

        BbsY := BbsY;
        if BbsY>Vys then Break;

        MoveTo(SirMer-1,BbsY);
        LineTo(SirMer-D,BbsY);
        if ((j-i) mod 10)=0 then begin
          S := IntToStr((((j-i)*Sit) div 1000));
          TextOut(SirMer-D-2-TextWidth(S),BbsY-TextHeight(S) div 2,S);
        end;

      end;
    end;
  end;

end;

Procedure MeritkoYOld(Canvas : TCanvas; AKoef : Extended;
  APocatek : TPoint; ALO,AHO,Sir,Vys : integer);
const
  Minm = 10;

var
  R : TRect;
  LeO,HoO : integer;
var
  Sit : Integer;
  D : integer;
  Y,YD,BbsY : integer;
  S : String;
  i,j : integer;
  AocY : integer;
begin
  Sit := SpSit(AKoef);
  LeO := ALO+SirMer;
  HoO := AHo+VysMer;
  With Canvas do begin
    Pen.Mode := pmCopy;
    Brush.Color := clLtGray;
    Pen.Color := clBlack;

    R.Left := ALO{+1};
    R.Top := HoO;
    R.Right := LEO;
    R.Bottom := Vys;
{    FillRect(R); }
    With R do
      Rectangle(Left, Top, Right, Bottom);

    Font.Name := 'MS Sans Serif';
    Font.Size := 8;
    Font.Style := [];
    Font.Color := BarvaMeritka;

    Pen.Color := BarvaMeritka;
    Brush.Style := bsClear;
    AocY := Round(APocatek.Y*AKoef*JMetrMM);
    IntersectClipRect(Canvas.Handle, ALo, HoO, LEO, Vys);

    j := APocatek.Y div Sit;
    for i := 0 to 32767 do begin
      YD := (j-i)*Sit;
      BbsY := AocY-Round(YD*AKoef*JMetrMM);
      if BbsY>=0 then begin

        if ((j-i) mod 5)=0 then begin
          D := 7
        end else begin
          D := 4;
        end;

        BbsY := BbsY+HoO;
        if BbsY>Vys then Break;

        MoveTo(LeO-1,BbsY);
        LineTo(LeO-D,BbsY);
        if ((j-i) mod 10)=0 then begin
          S := IntToStr((((j-i)*Sit) div 1000));
          TextOut(LeO-D-2-TextWidth(S),BbsY-TextHeight(S) div 2,S);
        end;

      end;
    end;
  end;

end;

Procedure Meritko(CanvasX, CanvasY : TCanvas; AKoef : Extended;
  APocatek : TPoint; Sir, Vys : integer);
begin
  MeritkoX(CanvasX, AKoef, APocatek, Sir);
  MeritkoY(CanvasY, AKoef, APocatek, Vys);
end;

Procedure MeritkoOld(Canvas : TCanvas; AKoef : Extended;
  APocatek : TPoint; ALO,AHO,Sir,Vys : integer);
begin
  MeritkoXOld(Canvas, AKoef, APocatek, ALO, AHO, Sir, Vys);
  MeritkoYOld(Canvas, AKoef, APocatek, ALO, AHO, Sir, Vys);
end;

Procedure Inicializace_PosRad;
var
  i : integer;
begin
  PosRad1 := TAmiRad1.Creatf(NIL, Point(0, 0), 0, TypRad1);
  PosRad2 := TAmiRad2.Creatf(NIL, Point(0, 0), TypRad2+10);
  PosChladic1 := TAmiRad2.Creatf(NIL, Point(0, 0), TypChladic1);
  PosOTChladic1 := TAmiOTChladic1.Creatf(NIL, Point(0, 0), TypOTChladic1);
  PosKotel := TAmiKotel.Creatf(NIL, Point(0, 0), TypKotel);
  for i := 1 to ImplementPocetSchemat do
    PosPoleSchemat[i] := TAmiSchema.Creatf(NIL, Point(-1000, -1000), TypSchema0+i);
  PosSchema := PosPoleSchemat[1];
  for i := TypPneuH to TypPneuH+79 do
    PosPolePneuH[i] := TAmiPneuH.Creatf(NIL, Point(-10000, -10000), i);
  PosPneuH := PosPolePneuH[TypPneuH];


  TextFont := TFont.Create;
  TextFont.Name := 'Arial';
//  TextFont.Name := 'Tahoma';
  Trub5Sila    := 5;
  Trub5Barva   := clBlack;
  Trub5Styl    := 0;
  CaraSila     := 5;
  CaraBarva    := clBlack;
  CaraStyl     := 0;
  ObdCaraSila  := 5;
  ObdCaraBarva := clBlack;
  ObdVzorStyl  := bsClear;
  ObdVzorBarva := clWhite;
  EliCaraSila  := 5;
  EliCaraBarva := clBlack;
  EliVzorStyl  := bsClear;
  EliVzorBarva := clWhite;
end;

Procedure Uvolneni_PosRad;
var
  i : integer;
begin
  TextFont.Free;
  PosRad1.Free;
  PosRad2.Free;
  PosChladic1.Free;
  PosOTChladic1.Free;
  PosKotel.Free;
  for i := 1 to ImplementPocetSchemat do
    PosPoleSchemat[i].Free;
  for i := TypPneuH to TypPneuH+79 do
    PosPolePneuH[i].Free;
end;

procedure TFrForm99.FrFormCreate;
var
  CK : integer;
begin
{  BVlozitTermoVentilAuto := TRUE; }
  { zatim }
  PanelCelek.Align := alClient;
  PanelATop.Height := VysMer;
  PanelALeft.Width := SirMer;
  BitBtn0.Align := alClient;
  BitBtn9.Caption := SFBitBtn9Caption;
  BitBtn10.Caption := SFBitBtn10Caption;
  BitBtn11.Caption := SFBitBtn11Caption;
  ToolWindowStoup.Caption := SFFormBVCaption;

  AktBodBM := TBitMap.Create;
  AktBodBM.Width := 32;
  AktBodBM.Height := 32;

  BitMapGrid := TBitMap.Create;
  BiMa := TBitMap.Create;
  BiMa.Width := Screen.Width;
  BiMa.Height := Screen.Height;

  Timer2.Enabled := FALSE;
  Timer4.Enabled := FALSE;
  NastavTimerAutoSave;

  with ScrollBar1 do begin
    Min := ARozsahX.X;
    Max := ARozsahX.Y;
  end;
  with ScrollBar2 do begin
    Min := ARozsahY.X;
    Max := ARozsahY.Y;
  end;

  KnofZvets[1] := BitBtn1;
  KnofZvets[2] := BitBtn2;
  KnofZvets[3] := BitBtn3;
  KnofZvets[4] := BitBtn4;
  KnofZvets[5] := BitBtn5;
  KnofZvets[6] := BitBtn6;
  KnofZvets[7] := BitBtn7;
  KnofZvets[8] := BitBtn8;
  KnofZvets[9] := BitBtn9;
  KnofZvets[10] := BitBtn10;

{  BitBtn0.Left := LevyO;
  BitBtn0.Top := HorniO;
  BitBtn0.Width := SirMer;
  BitBtn0.Height := VysMer; }
  BitBtn0.Caption := IntToStr(Round(100*KoefZvetseni));

  Panel1.Left := LevyO;
  Panel1.Top := HorniO+VysMer+1;
  Panel1.Width := SKnofZvets;

  For CK := 1 to PocKnZv do begin
    KnofZvets[CK].Width := Panel1.Width;
    KnofZvets[CK].Height := VKnofZvets;
    KnofZvets[CK].Tag := CK;
    if CK>1 then begin
      KnofZvets[CK].Top := KnofZvets[CK-1].Top+KnofZvets[CK-1].Height-1;
      if CK=9 then KnofZvets[CK].Top := KnofZvets[CK].Top+10;
    end;
    KnofZvets[CK].OnClick := KnofZvClick;
  end;
  Panel1.Height := KnofZvets[PocKnZv].Top+KnofZvets[PocKnZv].Height;
  VidPanel1_99(FALSE);

  PocAmi := Pocatek;
  PoOAmi := Pocatek;
  SpoctiKorku_99;

  ATopChlad := TTopChlad.Create;
  ATopChlad.AFrForm99 := Self;

  PocAmi := Pocatek;
  PoOAmi := Pocatek;

  ListNastaveniZoomu := TList.Create;
//    PosicevNastZoomu : integer;

  StoupStrList := TStringList.Create;

  NastavPrazdnyProjekt_99;
  PrepocitejGrid(KoefZvetseni);


  with ScrollBar1 do begin
    Min := ARozsahX.X;
    Max := ARozsahX.Y;
    SmallChange := SpSit(KoefZvetseni);
    LargeChange := 10*SmallChange;
    Position := PocAmi.X;
  end;
  with ScrollBar2 do begin
    Min := ARozsahY.X;
    Max := ARozsahY.Y;
    SmallChange := SpSit(KoefZvetseni);
    LargeChange := 10*SmallChange;
    Position := -PocAmi.Y;
  end;

  MuzeScroll := TRUE;

  HorniO := 0;
{  LevyO := 100; }
  LevyO := 0;


  AFormP := TFormP.Create(Self);
  AFormP.Visible := FALSE;
  ATopChlad.AFormP := AFormP;
  AFormP.AFrForm99 := Self;

  AFormI := TFormI.Create(Self);
  AFormI.Visible := FALSE;
  ATopChlad.AFormI := AFormI;
  AFormI.AFrForm99 := Self;
//  AForm_A := FormA;
//  PaintBox1.PopupMenu := FormA.PopupMenu2;

  StatusBar1.Visible := StatusBarVisible;
  DelejInvalidu_99;
end;

Function DejForm(AControl : TControl) : TControl;
var
  AComponent : TComponent;
  AForm : TComponent;
begin
  Result := NIL;
  AForm := AControl;
  Repeat
    if (AForm is TForm) OR (AForm=NIL) then begin
      Result := TControl(AForm);
      break;
    end else begin
      AComponent := AForm.Owner;
      if AComponent is TControl then AForm := AComponent
                                else break;
    end;
  until FALSE;
end;

class function TFrForm99.CreateAsSubform(AOwner: TCustomForm; AParent: TPanel): TFrForm99;
begin
  Result := TFrForm99.Create(AOwner);
  Result.Parent := AParent;
  Result.ParentWindow := AParent.Handle;
  Result.Color := AParent.Color;
  Result.Top := 0;
  Result.Left := 0;
  Result.Align := alClient;
  Result.BorderStyle := Forms.bsNone;
  Result.ControlStyle := Result.ControlStyle + [csParentBackground];
  Result.Invalidate;
end;

procedure TFrForm99.UvolniToolWindows;
var
  AControl : TControl;
begin
  AControl := DejForm(Self);
  if AControl is TForm then begin
    BeforeMoveLeft := AControl.Left;
    BeforeMoveTop := AControl.Top;

    ToolWindowStoup.DockedTo := NIL;
    ToolWindowStoup.Left := AControl.Left-ToolWindowStoup.Width-50;
    ToolWindowStoup.Top := AControl.Top-ToolWindowStoup.Width-50;

    ToolWindowFormF.DockedTo := NIL;
    ToolWindowFormF.Left := BeforeMoveLeft+50;
    ToolWindowFormF.Top := BeforeMoveTop+50;
  end;
end;

procedure TFrForm99.WMDropFiles(var Msg: TWMDropFiles);
var
  CFileName : array[0..MAX_PATH] of Char;
  MuzeBytIMI : boolean;

  Table1 : TMojeTable;
  JmenP, ExtP, JmenD, DirD : String;
  FJmeno : String;
  AmiStream : TFileStream;
  Hr1, Hr2 : integer;
  i : integer;

{$IFDEF ACCESS_PARADOX}
  Master1 : TDMaster;
{$ENDIF}

begin
// pro otevreni projektu pretazenim (treba explorerem) na zakladni formular
  MuzeBytIMI := FALSE;
  try
    if DragQueryFile(Msg.Drop, 0, CFileName, MAX_PATH) > 0 then begin
      if FileExists(CFileName) then begin
        ExtP := UpperCase(ExtractFileExt(CFileName));
        if ExtP=ExtensionIMI then begin
          AmiStream := TFileStream.Create(CFileName, fmOpenRead);
          Try
            AmiStream.Read(I, SizeOf(Integer));
            if i=MagicAm07 then
              MuzeBytIMI := TRUE;
          finally
            AmiStream.Free;
          end;

          if NOT MuzeBytIMI then begin
{$IFDEF ACCESS_PARADOX}
            Master1 := NIL;
            JmenD := ChangeFileExt(ParamStr(0), ExtensionDB);
            if CopyFile(CFileName, PChar(JmenD), FALSE) then begin
              Master1 := TDMaster.Create( NIL );
              Table1 := TMojeTable.Create( NIL );
              DirD := ExtractFilePath(JmenD);
              DirD := ExcludeTrailingBackslash(DirD);
              JmenD := ExtractFileName(ChangeFileExt(ParamStr(0), ''));
              DirD := ExcludeTrailingBackslash(DirD);
  {$IFDEF DATABASE_ADO}
              Master1.LoginPrompt := FALSE;
              Table1.Connection := Master1;
              Master1.ConnectionString :=
  {$ELSE}
              Table1.Master := Master1;
              Master1.Connection :=
  {$ENDIF}
                'Provider=Microsoft.Jet.OLEDB.4.0;'+
                'Data Source='+DirD+';'+
                'Extended Properties=Paradox 5.x;';

              Master1.Connected := TRUE;

            end else begin
              exit;
            end;
{$ELSE}
            JmenD := ExtractFileName(CFileName);
            DirD := ExtractFilePath(CFileName);
            DirD := ExcludeTrailingBackslash(DirD);
            Table1 := TMojeTable.Create( NIL );
            Table1.DatabaseName := DirD;
  {$IFNDEF DATABASE_ALP}
            Table1.TableType := ttParadox;
  {$ENDIF}
{$ENDIF}
            Try
              with Table1 do begin
                { The Table component must not be active }
                Active := False;
                { First, describe the type of table and give }
                { it a name }
                TableName := JmenD;
                ReadOnly := TRUE;
                Try
                  Active := TRUE;
                  if FielDByName(StrFTyp).AsInteger=TypPocetvDB then begin
                    Hr1 := FielDByName(StrIntHodn1).AsInteger;
                    Hr2 := FielDByName(StrIntHodn2).AsInteger;
                    if Hr1=Hr2 then begin
                      MuzeBytIMI := TRUE;
                      Msg.Result := 0;
                    end;
                  end;
                except
                end;
                Active := False;
              end;
            finally
              Table1.Free;
{$IFDEF ACCESS_PARADOX}
              Master1.Free;
{$ENDIF}
            end;
          end;
        end;
      end;
    end;
  finally
    DragFinish(Msg.Drop);
  end;

  if NOT MuzeBytIMI then begin
    DialogsCZ.MessageDlg(String(CFileName)+#13+SneniprojektIMIhes+#13+
       SProgram+' '+ExtractFileName(ParamStr(0))+' '+Snemuzeprecisttentosoubor,
       mtWarning, [mbCancel], 0);

  end else begin
    with ATopChlad do begin
      if DelejCtiProjekt_99(CFileName, FALSE) then begin
        Form_Rb1.Ribbon1.AddRecentItem(CFileName);

{        for i := 0 to HistPosledniSouboru.Count-1 do
          if UpperCase(CFileName)=UpperCase(HistPosledniSouboru[i]) then begin
            HistPosledniSouboru.Delete(i);
            Break;
          end;

        HistPosledniSouboru.Insert(0, CFileName);
        ZrusHistSouboryPres;                                }

  //      DelejSeznamTrubek;
        DelejTabulky_99;
        // nastavi tak, aby se projekt zobrazil cely
        KnofZvClick(KnofZvets[9]);
      end;
    end;
  end;
end;

Procedure TFrForm99.DelejOznAmi_99(AmiClass : TAmiClass);
begin
  with ATopChlad do begin
    if AktAmiOzn<>AmiClass then begin
      PaintBox1.Canvas.Pen.Mode := pmXOR;
      Try
        if AktAmiOzn<>NIL then begin
          AktAmiOzn.Oznaceny := FALSE;
          PaintBox1.Canvas.Pen.Mode := pmXOR;
          AktAmiOzn.Kresli(PaintBox1.Canvas, KoefZvetseni, 4, PocAmi);
          PaintBox1.Canvas.Pen.Mode := pmCopy;
          AktAmiOzn.Kresli(PaintBox1.Canvas, KoefZvetseni, 0, PocAmi);
        end;
        AktAmiOzn := AmiClass;
        PaintBox1.Canvas.Pen.Mode := pmCopy;
        if AktAmiOzn<>NIL then begin
          AktAmiOzn.Oznaceny := TRUE;
          AktAmiOzn.Kresli(PaintBox1.Canvas, KoefZvetseni, 4, PocAmi);
        end;
      except
        AktAmiOzn := NIL;
      end;

      DelejTabulky_99;
    end;
  end;
end;

procedure TFrForm99.PaintBox1MouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);

Procedure AA3(AmiClass : TAmiClass; ABod : TPoint; var B1,B2 : TPoint);
var
  Ind : integer;
  B : TPoint;
begin
  if AmiClass=NIL then begin
    Ind := 0;
  end else begin
    with AmiClass do begin
      case CisloCimJede_99 of
        -TypTrubka1, -TypTrubka3 : B := BodproTrubTam(ABod,Ind);
        -TypTrubka2, -TypTrubka4 : B := BodproTrubZpet(ABod,Ind);
        -TypTrubka0 : begin
          B := BodproTrubTam(ABod,Ind);
          if ind=0 then
            B := BodproTrubZpet(ABod,Ind);
        end;
// COTRUBKA0?
      end;
    end;
  end;
  if Ind=0 then begin
    if NOT PorovnejBody(AktBodAmi, Point(-MaxInt div 2, -MaxInt div 2)) then begin
      B1 := AktBodAmi;
      DelejSpocAbsBodik(PocAmi, AktBodAmi, KoefZvetseni, B2);
      BylFixniZacatek := TRUE;
    end else begin
      B1 := AKatva;
      B2 := Kotva;
    end;
  end else begin
    B1 := B;
    DelejSpocAbsBodik(PocAmi, B, KoefZvetseni, B2);
    BylFixniZacatek := TRUE;
  end;
  DelejAktBod(Point(-MaxInt div 2, -MaxInt div 2));
end;

var
  Bod, B1, B2 : TPoint;
  AmiCla : TAmiClass;

  i, j : integer;
  AT, AU : TAmiClass;
  BodUchytu : TPoint;
  Nasel : integer;
  AsponDva : boolean;

  ZmX, ZmY : integer;

  N0, N1 : integer;
begin
  HejbalObjektyNaTrubce := FALSE;

  Application.CancelHint;
  PaintBox1.Hint := '';

  PaintBox1.BringToFront;

//  if NOT AsponJedenProjekt then
//    exit;

  BylssLeft   := ssLeft in Shift;
  BylssMiddle := ssMiddle in Shift;
  BylssRight  := ssRight in Shift;
  BylssShift  := ssShift in Shift;
  BylFixniZacatek := FALSE;
{  if BylssRight then begin
    if (AktAmiOzn is TAmiVentil) AND (Length(TAmiVentil(AktAmiOzn).Kapilara)>0) then begin



    end;
  end; }
  if BylssMiddle then begin
    DelejSpocitejBodGrid(PocAmi,Point(X,Y),Griq,KoefZvetseni,Bod);
    DelejSpocAbsBodik(PocAmi, Bod, KoefZvetseni, Kotva);
    AKatva := Bod;
    Myska := Kotva;
    PocPacka := Point(ScrollBar1.Position, ScrollBar2.Position);
  end;
  if BylssLeft then begin         // Levy knoflik mysi
    PocPacka := Point(ScrollBar1.Position, ScrollBar2.Position);

    PointMousePaintboxDown := Point(X, Y);

    PBoxDblCl := FALSE;
    Timer2.Enabled := FALSE;
  {  VybList.Clear; }
    VidPanel1_99(FALSE);
    Kotva := Point(X, Y);

    CBUch := 0;
    CisloSymbolu := 0;
    if AForm_A is TFormA then
      with TFormA(AForm_A) do begin
        if RozdelitStropy1.Checked OR ARozdelitStropy1.Checked then
          CisloSymbolu := SymUpravStropy;
        if OblastProTisk1.Checked OR AOblastProTisk1.Checked then
          CisloSymbolu := SymOblastProTisk;

        if ToolB97Zobr1.Down then CisloSymbolu := SymDelejZoomLupa;
        if ToolB97Zobr2.Down then CisloSymbolu := SymPosunVykres;
        if ToolB97Zobr3.Down then CisloSymbolu := SymPosunDoStredu;

      end;

    if CisloCimJede_99=SymJedeKrizem then begin
      MysiKriz([], FALSE, FALSE);
      CisloSymbolu := SymDelejZoomKriz;
      CisloCimJede_99 := 0;
      ZoomKrizem := TRUE;
    end;

    DelejSpocRealBodik(PocAmi,Point(X,Y),KoefZvetseni,Bod);
    AKatva := Bod;

    with ATopChlad do begin
      OznList.Clear;
      AktAmiPom := NIL;

      Myska := Kotva;
      if CisloCimJede_99<0 then begin  { je vybran objekt pro vlozeni }
        DelejSpocitejBodGrid(PocAmi,Point(X,Y),Griq,KoefZvetseni,Bod);
        DelejSpocAbsBodik(PocAmi, Bod, KoefZvetseni, Kotva);
        AKatva := Bod;
        Myska := Kotva;
        if AktAmiMove<>NIL then begin
          AktAmiMove.Kresli(PaintBox1.Canvas, KoefZvetseni, 0, PocAmi);
          AktAmiMove := NIL;
        end;

        DelejZrusVybrani(AmiLispik);
        DelejOznAmi_99(NIL);
        AktAmiSchemaF := NIL;
    {    if AktAmiOzn<>NIL then
          AktAmiOzn.Oznaceny := FALSE;
        AktAmiOzn := NIL; }
        OznList.Clear;
        VybList.Clear;
        case CisloCimJede_99 of
          -TypTrubka6..-TypTrubka1 : begin
            AmiCla := AmiLispik.NajdiRaKoBod(Bod, EpsilonRel, -CisloCimJede_99);
            AA3(AmiCla, Bod, AKatva, Kotva);
          end;
          -TypAmiOblouk2 : begin
            case CitacKlikuObloucku of
              0 : begin
                RObloucku := 0;
                BodObloucku1 := PointMousePaintboxDown;
                BodObloucku2 := PointMousePaintboxDown;
                StredObloucku := PointMousePaintboxDown;
  //              with PaintBox1.Canvas do begin
                with BiMa.Canvas do begin
                  brush.style := bssolid;
                  brush.color := clDkGray;
                  Pen.Mode := pmCopy;
                  Pen.Style := psSolid;
                  pen.color := clDkGray;
                  rectangle(X-velboduuch, Y-velboduuch,
                            x+velboduuch, y+velboduuch);

        //          OblKruznice(PaintBox1.Canvas, RObloucku, X, Y);
                end;
                with PaintBox1.Canvas do begin
                  brush.style := bssolid;
                  brush.color := clDkGray;
                  Pen.Mode := pmCopy;
                  Pen.Style := psSolid;
                  pen.color := clDkGray;
                  rectangle(X-velboduuch, Y-velboduuch,
                            x+velboduuch, y+velboduuch);

                end;
                inc(CitacKlikuObloucku);
              end;

              1 : begin
                case JakObloucek of
                  0 : begin
                    Alf1Obloucku := -Round(ArcTan2(BodObloucku1.Y-Y, BodObloucku1.X-X)/Pi*180000);
            //        Alf2Obloucku := Alf1Obloucku+180000;
                    Alf2Obloucku := Alf1Obloucku;
                    OblKruznice(PaintBox1.Canvas, RObloucku, Point(X, Y));
                    Obloucek(PaintBox1.Canvas, RObloucku, StredObloucku, Alf1Obloucku, Alf2Obloucku);
                    inc(CitacKlikuObloucku);
                  end;

                  1 : begin
                    with BiMa.Canvas do begin
                      brush.style := bssolid;
                      brush.color := clDkGray;
                      Pen.Mode := pmCopy;
                      Pen.Style := psSolid;
                      pen.color := clDkGray;
                      rectangle(X-velboduuch, Y-velboduuch,
                                x+velboduuch, y+velboduuch);
                    end;
                    with PaintBox1.Canvas do begin
                      brush.style := bssolid;
                      brush.color := clDkGray;
                      Pen.Mode := pmCopy;
                      Pen.Style := psSolid;
                      pen.color := clDkGray;
                      rectangle(X-velboduuch, Y-velboduuch,
                                x+velboduuch, y+velboduuch);
                    end;
                    BodObloucku2.X := X;
                    BodObloucku2.Y := Y;
                    Obloucek(BiMa.Canvas, RObloucku, StredObloucku, Alf1Obloucku, Alf2Obloucku);
                    BodyTetivy(PaintBox1.Canvas, BodObloucku1, BodObloucku2);
                    inc(CitacKlikuObloucku);
                  end;
                end;
              end;

              2 : begin
                CitacKlikuObloucku := 3;
              end;
            end;



          end;

        end;
      end else begin  //  neni vybran zadny objekt, ktery se ma vkladat
        PohnoutViceRadKot := FALSE;
        if CisloCimJede_99=0 then begin
          if ssLeft in Shift then begin
            PohnoutViceTrubkami := (ssShift in Shift) AND (ssCtrl in Shift);

            if PohnoutViceTrubkami then begin
              { stisknuta kalvesa Ctrl }
              { pokusi se najit jeden koncovy bod vice trubek, z nimz chce pohnout }
              nasel := 0;
              AsponDva := FALSE;
              for i := 0 to AmiLispik.COunt-1 do begin
                AT := AmiLispik[i];
                if (AT is TAmiTrubka) AND (AT.Typ in [TypTrubka1..TypTrubka6]) then begin
                  if BlizkeBody(Bod, AT.Pocatek, EpsilonRel) then begin
                    Nasel := 1;
                    BodUchytu := AT.Pocatek;
                  end else begin
                    if BlizkeBody(Bod, AT.AbsKonec, EpsilonRel) then begin
                      Nasel := -1;
                      BodUchytu := AT.AbsKonec;
                    end;
                  end;
                  if Nasel<>0 then begin
                    AT.Orientace := Nasel;
                    for j := 0 to AmiLispik.COunt-1 do begin
                      Nasel := 0;
                      AU := AmiLispik[j];
                      if (AU is TAmiTrubka) AND (AU.Typ in [TypTrubka1..TypTrubka6]) AND
                         (AU<>AT) then begin
                        if BlizkeBody(BodUchytu, AU.Pocatek, EpsilonRel) then begin
                          Nasel := 1;
                        end else begin
                          if BlizkeBody(BodUchytu, AU.AbsKonec, EpsilonRel) then begin
                            Nasel := -1;
                          end;
                        end;

                        if Nasel<>0 then begin
                          if NOT AsponDva then begin
                            VybList.Clear;
                            VybList.Add(AT);
                            AsponDva := TRUE;
                          end;
                          AU.Orientace := Nasel;
                          VybList.Add(AU);
                        end;
                      end;
                    end;    { for j }
                    break;  { prerusit cyklus i }
                  end;      { if Nasel }
                end;        { if AmiTrubka }
              end;          { for i }
              PohnoutViceTrubkami := AsponDva;
              if NOT PohnoutViceTrubkami then begin
                PohnoutViceRadKot := FALSE;
                AmiCla := AmiLispik.DotaX(Bod, EpsilonRel);
                if AmiCla.JeRadKot then begin
                  PohnoutViceRadKot := TRUE;

  {                if Assigned(AmiCla.AmCl) OR Assigned(AmiCla.AmCm) then begin
                    PohnoutViceRadKot := TRUE;
                    if (AmiCla.AmCl=AmiCla.AmCm) AND (AmiCla.AmCl is TAmiVenti2) then
                      if NOT (Assigned(AmiCla.AmCl.AmCl) OR
                              Assigned(AmiCla.AmCl.AmCm)) then
                        PohnoutViceRadKot := FALSE;
                  end; }
                end;
              end;
            end;


            if PohnoutViceTrubkami then begin
              DelejPohniViceTrubkami(Bod, TRUE, FALSE);
            end else begin { if PohnoutViceTrubkami }
              if PohnoutViceRadKot then begin
                DelejSpocitejBodGrid(PocAmi,Point(X,Y),Griq,KoefZvetseni,Bod);
                VybList.Clear;
                DelejOznAmi_99(AmiCla);
                DelejVyberOznMovRadKot;
                DelejPohniViceKotRad(Bod, 0, TRUE, FALSE);
              end else begin
                if CisloSymbolu>=0 then begin
                  AmiCla := AmiLispik.DotaX(Bod, EpsilonRel);
                  DelejOznzListu_99(VybList);
                  if AktAmiOzn<>NIL then begin
                    if AktAmiOzn.NajdiUchBod(Bod, CBUch, B1, B2)>0 then begin
                      AKatva := B1;
                      AKatvb := B2;
                      DelejSpocAbsBodik(PocAmi, AKatva, KoefZvetseni, Kotva);
                      DelejSpocAbsBodik(PocAmi, AKatvb, KoefZvetseni, Kotvb);

                      if (AktAmiOzn is TAmiPokoj) OR
                         (AktAmiOzn is TAmiStrop1) OR
                         (AktAmiOzn is TAmiObdelnik) then CisloSymbolu := 10+CBUch;
                      if ((AktAmiOzn is TAmiOblouk) AND (AktAmiOzn.Typ=TypAmiOblouk1)) then CisloSymbolu := 60+CBUch;
                      if ((AktAmiOzn is TAmiOblouk) AND (AktAmiOzn.Typ=TypAmiOblouk2)) then CisloSymbolu := 80+CBUch;
                      if AktAmiOzn is TAmiTrubka then begin
                        if AktAmiOzn.Typ=TypTrubkaOV then begin
                          CisloSymbolu := 26+CBUch;
                          if (B1.X=AktAmiOzn.Pocatek.X) AND
                             (B1.Y=AktAmiOzn.Pocatek.Y) then dec(CisloSymbolu);
                        end else begin
        {                  DelejSpocRealBodik(PocAmi,Bodik,KoefZvetseni,Bod); }
                          DelejPohniObjektyNaTrubce(Bod, AktAmiOzn, CBUch=3 ,TRUE, FALSE);
                            { at to KRESLI pri MOUSEDOWN }
                          CisloSymbolu := 20+CBUch;
                        end;
                      end;


                      if AktAmiOzn is TAmiCara then
                        CisloSymbolu := 20+CBUch;

                      if {AktAmiOzn is TAmiCara) OR }  // cara presunuta k trubkam
                        ((AktAmiOzn is TAmiTextik) AND (AktAmiOzn.Typ=TypAmiText3)) then
                        CisloSymbolu := 50+CBUch;

                      if AktAmiOzn is TAmiVenti3 then begin
                        CisloSymbolu := 10*AktAmiOzn.Typ+CBUch;
                        BoPVenti3 := AktAmiOzn.Pocatek;
                        BoKVenti3 := AktAmiOzn.AbsKonec;
                        AktAmiOzn.KreslAbs(PaintBox1.Canvas, Point(0, 0));
                      end;
                      if ((AktAmiOzn is TAmiPopis) AND
                        ((AktAmiOzn.Typ=TypPopisTru1) OR (AktAmiOzn.Typ=TypPopisTru2) OR
                         (AktAmiOzn.Typ=TypPopisTru3) OR (AktAmiOzn.Typ=TypPopisTru4) OR
                         (AktAmiOzn.Typ=TypPopisTru5))) OR
                        ((AktAmiOzn is TAmiTextik) AND (AktAmiOzn.Typ=TypAmiText2)) then begin
                        CisloSymbolu := 30+CBUch;
                        if CisloSymbolu=35 then
                          AktAmiOzn.KreslAbs(PaintBox1.Canvas, Point(0,0));
                      end;

                      if AktAmiOzn.JeAAAVent1 then begin
                        if CBUch=1 then begin
                          CisloSymbolu := 40+CBUch;
                          AktAmiOzn.KreslAbs(PaintBox1.Canvas, Point(0,0));
                        end else begin
                          CisloBoduKapilary := CBUch;
                          CisloSymbolu := 42;
                        end;
                      end;

                      if AktAmiOzn is TAmiKotel then begin
                        CisloSymbolu := 45+CBUch;
                        TAmiKotel(AktAmiOzn).SchovejBodyPrip;
                        AktAmiOzn.KreslAbs(PaintBox1.Canvas, Point(0,0));
                      end;

                      if AktAmiOzn is TAmiOTChladic1 then begin
                        CisloSymbolu := 55+CBUch;
  //                      TAmiOTChladic1(AktAmiOzn).SchovejBodyPrip;
                        AktAmiOzn.KreslAbs(PaintBox1.Canvas, Point(0,0));
                      end;
                      { meni tvar oznaceneho AMI }
        {              if (AktAmiOzn is TAmiPopis) AND (AktAmiOzn.Typ=TypPopisTru2) then
                        CisloSymbolu := 20+CBUch; }
                      if AktAmiOzn is TAmiVenti4 then begin
                        CisloSymbolu := 120+CBUch;
                      end;

                      if AktAmiOzn is TAmiVenti2 then begin
                        CisloSymbolu := 90+CBUch;
                        AktAmiOzn.KreslAbs(PaintBox1.Canvas, Point(0,0));
                      end;

                      if AktAmiOzn is TAmiSchema then begin
                        CisloSymbolu := 100+CBUch;
                        TAmiSchema(AktAmiOzn).SchovejBodyPrip;
                        AktAmiOzn.KreslAbs(PaintBox1.Canvas, Point(0,0));
                        TAmiSchema(AktAmiOzn).KresliPopisySchAbs(PaintBox1.Canvas, Point(0,0));
                        TAmiSchema(AktAmiOzn).UlozAbsSourPopisuSch;
                      end;

                      if AktAmiOzn is TAmiPneuH then begin
                        N0 := 3;
                        if CBUch<=N0 then begin
                          CisloSymbolu := 70+CBUch;
                          AktAmiOzn.KreslAbs(PaintBox1.Canvas, Point(0, 0));
                        end else begin
                          N1 := N0+Length((AktAmiOzn as TAmiPneuH).Kapilarb1);
                          if NOT ((CBUch=N0+1) OR (CBUch=N1+1)) then begin
                            CisloBoduKapilary := CBUch-N0;
                            CisloSymbolu := 74;
                          end;
                        end;
                      end;

                      DelejVyberOzn1;
                    end;
                  end;
                  if CBUch=0 then begin
                    if AmiCla<>NIL then begin
                      if ssCtrl in Shift then begin
                        { je stisknuty CTRL }
                        if AmiCla=AktAmiOzn then begin
                          { nedelej nic }
                        end else begin
                          if VybList.Count>0 then begin
                            if VybList.IndexOf(AmiCla)>=0 then begin
                              VybList.Remove(AmiCla);
                              DelejOznzListu_99(VybList);
                            end else begin
                              VybList.Add(AmiCla);
                            end;
                          end else begin
                            if AktAmiOzn<>NIL then begin
                              VybList.Add(AktAmiOzn);
                              VybList.Add(AmiCla);
                              DelejOznAmi_99(NIL);
                            end else begin
                              DelejOznAmi_99(AmiCla);
                            end;
                          end;
                        end;
                      end else begin
                        if AmiCla=AktAmiOzn then begin
                          { nedelej nic }
                        end else begin
                          if VybList.Count>0 then begin
                            if VybList.IndexOf(AmiCla)>=0 then begin
                              { ukazal na vybrany v listu }
                              AktAmiPom := AmiCla;
                            end else begin
                              VybList.Clear;
                              DelejOznAmi_99(AmiCla);
                            end;
                          end else begin
                            DelejOznAmi_99(AmiCla);
                          end;
                        end;
                      end;
                      DelejVyberOzn2;

                    end else begin
                      VybList.Clear;
                      DelejOznAmi_99(AmiCla);
                    end;
                  end;
                end else begin  { if CisloSymbolu>=0 }
                  case CisloSymbolu of
                    SymPosunDoStredu : begin
                      B1 := Point(X-PaintBox1.Width div 2,
                                  Y-PaintBox1.Height div 2);
                      DelejSpocRealBodik(Point(0, 0), B1, KoefZvetseni, B2);
                      ScrollBar1.Position := ScrollBar1.Position+B2.X;
                      ScrollBar2.Position := ScrollBar2.Position-B2.Y;
                    end;
                  end;
                end;    { if CisloSymbolu<0 }
              end;
            end;      { if PohnoutViceTrubkami }
          end;
        end;
      end;            { if ssLeft in Shift }
    end;
  end;

  PohnulMysivPB := FALSE;
  QohnulMysivPB := FALSE;
end;

procedure TFrForm99.PaintBox1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  HnulMysi : boolean;


Procedure KresliPresouvane;
var
  RBod, ABod : TPoint;
begin
  if (ssLeft in Shift) AND (CisloSymbolu>=0) AND (CisloSymbolu<10) then begin
    DelejSpocitejBodGrid(PocAmi, Myska, Griq, KoefZvetseni, RBod);
    DelejSpocAbsBodik(PocAmi, RBod, KoefZvetseni, ABod);
    DelejKreslAbs(Point(ABod.X-Kotva.X, ABod.Y-Kotva.Y));
{    DelejKreslAbs(Point(Myska.X-Kotva.X,Myska.Y-Kotva.Y)); }
  end;
end;

Procedure DelejOznPraveVlozene;
var
  i : integer;
  AC : TAmiClass;
begin
  for i := 0 to ATopChlad.OznList.Count-1 do begin
    AC := ATopChlad.OznList.Items[i];
    AC.PraveVlozeny := TRUE;
  end;
end;

var
  Bod, B1, B2 : TPoint;
begin
  HnulMysi := (Abs(X-PointMousePaintboxDown.X)>1) OR
              (Abs(Y-PointMousePaintboxDown.Y)>1);

//  if NOT AsponJedenProjekt then
//    exit;

  if NOT QohnulMysivPB then begin
    if HnulMysi then begin
  {  DelejKopie1Ozn; } { udela kopii oznacenych AMIobjektu, aby mohl udelat UNDO }
      if (ssLeft in Shift) AND (CisloCimJede_99=0) AND
        ((ATopChlad.OznList.Count>0) OR (ATopChlad.VybList.Count>0)) then begin
        PraveVlozenyFalse(ATopChlad.AmiLispik);
        DelejUmozniUNDO_99;
        DelejUmozniUNDQ_99(histInsert, histPohnulMysi, NIL, NIL);          //?????
        DelejOznPraveVlozene;
        QohnulMysivPB := TRUE;
      end;
      if (ssMiddle in Shift) then begin
        CisloCimJedf_99 := CisloCimJede_99;
        CisloCimJede_99 := 0;
        CisloSymbolv := CisloSymbolu;
        CisloSymbolu := SymPosunVykres;
//        AktCisloKurzorv := AktCisloKurzoru;
        QohnulMysivPB := TRUE;
        DelejVyberKurzor_99(crPacka);
      end;
    end;
  end;

  if Shift=[] then
    if NicSeNedeje_99 then
      AktAmiOznKurzor_99(X, Y);


  AZmana := Point(0,0);
  if (ssLeft in Shift) OR (ssCtrl in Shift) OR (ssShift in Shift) then begin
    if X<0 then AZmana.X := X
    else if X>PaintBox1.Width then AZmana.X := X-PaintBox1.Width;
    if Y<0 then AZmana.Y := Y
    else if Y>PaintBox1.Height then AZmana.Y := Y-PaintBox1.Height;
  end;
{  Timer2.Enabled := (AZmana.X<>0) OR (AZmana.Y<>0); }
  if (AZmana.X=0) AND (AZmana.Y=0) then begin
{    if Timer2.Enabled then Invalidate; }
    if Timer2.Enabled then Repaint;
    Timer2.Enabled := FALSE;
  end else begin
    Timer2.Enabled := TRUE;
  end;

  MysiKriz(Shift, HnulMysi, FALSE);
  KresliPresouvane;
  Myska := Point(X,Y);

  PrepocitejObloucek_99(Point(X, Y), Shift);

  DelejSpocitejBodGrid(PocAmi,Point(X,Y),Griq,KoefZvetseni,Bod);
  DelejSpocAbsBodik(PocAmi, Bod, KoefZvetseni, Myska);

  StatusBar1.Panels[0].Text := 'X:'+FloatToStrF(Bod.X/1000, ffFixed, 6,3)+
                             ', Y:'+FloatToStrF(Bod.Y/1000, ffFixed, 6,3)+
                             ' '+JmenoJednotek_Delka[0];

  KresliPresouvane;
  PohnulMysivPB := TRUE;
  ShDnMovePB := FALSE;

  MysiKriz(Shift, HnulMysi, TRUE);
  if CisloSymbolu>=0 then begin
    NajdiBodSpojAmi(Myska, Shift, 1);
    NajdiObjektAmi(Myska, Shift, 1);
  end else begin
    if (ssLeft in Shift) OR (ssMiddle in Shift) then begin
      case CisloSymbolu of
        SymPosunVykres : begin
          B1 := Point(X-Kotva.X, Y-Kotva.Y);
          DelejSpocRealBodik(Point(0, 0), B1, KoefZvetseni, B2);
          ScrollBar1.Position := PocPacka.X-B2.X;
          ScrollBar2.Position := PocPacka.Y+B2.Y;
        end;
      end;
    end;
  end;
end;

procedure TFrForm99.PaintBox1MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);

var
  i, j : integer;
  Bod, Boe, Ve, BAC : TPoint;
  AC, AX, AV : TAmiClass;

  R, EX, EY, Uhel : extended;

  { pro roztazeni nebo stlaceni rozvodnych ventilu }
  BoP, BoK : TPoint;
  PocPrip : integer;
  DifV : integer;
  nasel : boolean;
  DelTr : extended;

  Ve1, Ve2 : TPoint;
  B1, B2 : TPoint;
  CBUch : integer;

  HnulMysi : boolean;
//  N0, N1, N2 : integer;
  ABodVlozit, AEnableVlozit, ABodZrusit, AEnableZrusit : boolean;
begin
  HnulMysi := (Abs(X-PointMousePaintboxDown.X)>1) OR
              (Abs(Y-PointMousePaintboxDown.Y)>1);
  Timer2.Enabled := FALSE;
{  MysiKriz([ssLeft],FALSE); }
  if Sender<>PaintBox1 then
    exit;
  if PBoxDblCl then
    exit;
//  if NOT AsponJedenProjekt then
//    exit;

  with ATopChlad do begin
    SpojitaRozdelitTrubky := FALSE;
    RozdelitTrubkyPokoji := FALSE;

    MysiKriz(Shift, HnulMysi, FALSE);
    MysiKriz([], HnulMysi, FALSE);
    if BylssLeft OR BylssMiddle then begin
      if CisloCimJede_99<>0 then begin
    {    DelejSpocitejBodGrid(PocAmi,Point(X,Y),Grid,KoefZvetseni,Bod);}
  {      if RovnaCara then begin }

        DelejVlozAmi(Myska, CisloCimJede_99);


        if (AktAmiOzn<>NIL) AND ((AktAmiOzn.Typ in [TypTrubka1..TypTrubka6])
          OR AktAmiOzn.JeRadseSpodnimPripojeni OR
             AktAmiOzn.JeRadseSpodPravPripojeni OR AktAmiOzn.JeRadseSpodLevPripojeni ) then begin
          { na trubku k radiatoru se pokusi vlozit termostaticky ventil
                             nebo regulacni sroubeni, pokud specifikovano }
          { k radiatoru se spodnim pripojenim se pokusi vlozit pripojovaci
            sestavu, pokud specifikovano }
          DelejVlozAutoVentil;

        end;

        if SpojitaRozdelitTrubky then begin
          SpojTrubky;
          RozdelTrubky;
        end;
        if SpojitaRozdelitTrubky OR RozdelitTrubkyPokoji then
          RozdelTrubPokoji;

        DelejOpravVztahy_99;
        BZobrazitsKontrolou := FALSE;


        DelejVymazVypocet_99;;
        ZmenaProjektu := TRUE;
    {    case CisloCimJede_99 of
        end;}
        if AktAmiOzn<>NIL then begin
          Try
            Case CisloCimJede_99 of
              -TypPokoj : begin
                if AFormP.TSheetPokoj.TabVisible then UdelejAktControl_99(AFormP.AdvStringGridPokoj);
                if AFormP.TSheetPokojHC.TabVisible then UdelejAktControl_99(AFormP.AdvStringGridPokojHC);
              end;
              -TypRad1-20..-TypRad1 : UdelejAktControl_99(AFormP.AdvStringGridRad1);
              -TypRad2-15..-TypRad2 : begin
                if AFormP.AdvStringGridRad2N.Visible then UdelejAktControl_99(AFormP.AdvStringGridRad2N);
                if AFormP.AdvStringGridRad2O.Visible then UdelejAktControl_99(AFormP.AdvStringGridRad2O);
              end;
              -TypChladic1-5..-TypChladic1:
                          UdelejAktControl_99(AFormP.AdvStringGridChladic1);
              -TypOTChladic1-5..-TypOTChladic1:
                          UdelejAktControl_99(AFormP.AdvStringGridOTChladic1);
              -TypVenti1-12, -TypVenti1-11, -TypVenti1-10, -TypVenti3-3..-TypVenti3 :
                          UdelejAktControl_99(AFormP.AdvStringGridDzeta);
              -TypVenti1-15..-TypVenti1-13 : UdelejAktControl_99(AFormP.AdvStringGridKV);
              -TypVenti2-9..-TypVenti2, -TypBubSluVent..-TypSludgeVent, -TypVenti1-7..-TypVenti1 :
                          UdelejAktControl_99(AFormP.AdvStringGridVentil);
              -TypTrubka6..-TypTrubka1 :
                          UdelejAktControl_99(AFormP.AdvStringGridTrubka);
              -TypAmiText1, -TypAmiText2, -TypAmiText3 :
                          UdelejAktControl_99(AFormP.AdvStringGridText);
              -TypModul : UdelejAktControl_99(AFormP.AdvStringGridModul);
              -TypSchema0-15..-TypSchema0 : UdelejAktControl_99(AFormP.AdvStringGridSchema);
              -TypVentiPneuHShutoffValve..-TypVentiPneuHAirVent, -TypPneuH-79..-TypPneuH :
                          UdelejAktControl_99(AFormP.AdvStringGridPneuH1);
            end;
          except
          end;
        end;
      end else begin
        if PohnoutViceTrubkami then begin
          DelejSpocitejBodGrid(PocAmi,Point(X, Y),Griq,KoefZvetseni,Bod);
          DelejPohniViceTrubkami(Bod, FALSE, TRUE);
          SpocitatBodySpojTr := TRUE;
          SpocitatBodyNedotahuTr := TRUE;
          VybList.Clear;
          SpojTrubky;
          RozdelTrubky;
          RozdelTrubPokoji;
          NulujAmCm_sKapilarou;
          DelejOpravVztahy_99;
          BZobrazitsKontrolou := FALSE;
          ZobrazitKontrolu_99(FALSE, FALSE);

        end else begin
          if PohnoutViceRadKot then begin
            DelejSpocitejBodGrid(PocAmi,Point(X, Y),Griq,KoefZvetseni,Bod);
            DelejPohniViceKotRad(Bod, 2, FALSE, TRUE);

            SpocitatBodySpojTr := TRUE;
            SpocitatBodyNedotahuTr := TRUE;
            VybList.Clear;
            AV := AktAmiOzn.RegVentilTam;
            if AV is TAmiVenti1 then begin
              AC := AV.AmCl;
              if Assigned(AC) then begin
                DelTr := DelkaVektoru(AC.RelKonec);
                BoK := AC.AbsKonec;
                if DelTr>DefVzdVentRad then begin
                  BoE.X := BoK.X-Round(AC.RelKonec.X/DelTr*DefVzdVentRad);
                  BoE.Y := BoK.Y-Round(AC.RelKonec.Y/DelTr*DefVzdVentRad);
                end else begin
                  BoE.X := BoK.X-Round(AC.RelKonec.X/2);
                  BoE.Y := BoK.Y-Round(AC.RelKonec.Y/2);
                end;
                AV.Pocatek := BoE;
              end;
            end;

            AV := AktAmiOzn.RegVentilZpet;
            if AV is TAmiVenti1 then begin
              AC := AV.AmCl;
              if Assigned(AC) then begin
                DelTr := DelkaVektoru(AC.RelKonec);
                BoK := AC.AbsKonec;
                if DelTr>DefVzdVentRad then begin
                  BoE.X := BoK.X-Round(AC.RelKonec.X/DelTr*DefVzdVentRad);
                  BoE.Y := BoK.Y-Round(AC.RelKonec.Y/DelTr*DefVzdVentRad);
                end else begin
                  BoE.X := BoK.X-Round(AC.RelKonec.X/2);
                  BoE.Y := BoK.Y-Round(AC.RelKonec.Y/2);
                end;
                AV.Pocatek := BoE;
              end;
            end;
  {          SpojTrubky;
            RozdelTrubky;
            RozdelTrubPokoji;

            DelejOpravVztahy_99;
            BZobrazitsKontrolou := FALSE;
            ZobrazitKontrolu1.Checked := FALSE;
            ZobrazitKontrolu1.Enabled := FALSE;

          end else begin                        }
          end;

          begin
            PohnulMysivPB := (Abs(X-PointMousePaintboxDown.X)>2) OR
                             (Abs(Y-PointMousePaintboxDown.Y)>2) OR
                              PohnoutViceRadKot;

            DelejSpocitejBodGrid(Point(0,0),Point(X-Kotva.X,Y-Kotva.Y),
                                 Griq,KoefZvetseni,Bod);
            if (CisloSymbolu>=0) AND (CisloSymbolu<10) then begin
              if (Bod.X<>0) OR (Bod.Y<>0) then begin
                if OznList.Count>0 then begin
                  if PohnulMysivPB then begin
                    MaVymazatVypocet := ObsahujeObjektproVyp(OznList);
                    if MaVymazatVypocet then
                      VypocetHotov := FALSE;
                    ZkusSpojeniaRozpojeniTrubek(OznList);
                    OznList.PosunAmi(Bod);

                    if SpojitaRozdelitTrubky OR RozdelitTrubkyPokoji then begin
                      SpojTrubky;
                      RozdelTrubky;
                      RozdelTrubPokoji;
                    end;
                    NulujAmCm_sKapilarou;
                    DelejOpravVztahy_99;
                    OznList.Clear;
        {            DelejVyberOzn1; }

                    BZobrazitsKontrolou := FALSE;
                    ZobrazitKontrolu_99(FALSE, FALSE);
                    DelejVymazVypocet_99;;
                    ZmenaProjektu := TRUE;
                    SpocitatBodySpojTr := MaVymazatVypocet;
                    SpocitatBodyNedotahuTr := MaVymazatVypocet;
                    DelejInvalidu_99;
                  end;
                end else begin
        {          if VybList.Count>0 then begin
                    if PohnulMysivPB then begin
                      VybList.PosunAmi(Bod);
                      DelejOpravVztahy_99;
                      Invalidate;
                    end else begin
                      if NOT (ssCtrl in Shift) then begin
                        VybList.Clear;
                        if AktAmiPom<>NIL then begin
                          DelejAktAmi(AktAmiPom);
                          DelejVyberOzn1;
                          DelejInvalidu_99;
                        end;
                      end;
                    end;
                  end else } begin
                    VybList.Clear;
                    DelejSpocRealBodik(PocAmi,Point(X,Y),KoefZvetseni,Bod);
                    if PohnulMysivPB then begin
                      DelejSpocRealBodik(PocAmi,Kotva,KoefZvetseni,Boe);

                      if X>=Kotva.X then begin
                        // tahne zleva doprava, vybere jen obsazene cele
                        for i := 0 to AmiLispik.Count-1 do begin
                          AC := TAmiClass(AmiLispik.Items[i]);
                          if AC.ObsazenvRect(Rect(Bod.X,Bod.Y,Boe.X,Boe.Y)) then
                            VybList.Add(AC);
                        end;
                      end else begin  // pridano 2.3.2007
                        // tahne zprava doleva, vybere vsechny kterych se dotkne
                        for i := 0 to AmiLispik.Count-1 do begin
                          AC := TAmiClass(AmiLispik.Items[i]);
                          if AC.ProtneRect(Rect(Bod.X,Bod.Y,Boe.X,Boe.Y)) then
                            VybList.Add(AC);
                        end;
                      end;
                      if VybList.Count>0 then begin
                        DelejOznzListu_99(VybList);
                        DelejInvalidu_99;
                      end;
                    end;
                  end;
                end;
              end else begin
                if NOT PohnulMysivPB then begin
                  if AktAmiPom<>NIL then begin
                    if NOT (ssCtrl in Shift) then begin
                      DelejOznAmi_99(AktAmiPom);
                      AktAmiPom := NIL;
                      VybList.Count := 0;
                    end;
                  end;
                end;
              end;
            end else begin
              if CisloSymbolu>0 then begin
                if (AktAmiOzn<>NIL) AND PohnulMysivPB then begin
                  DelejSpocitejBodGrid(PocAmi,Myska,Griq,KoefZvetseni,Bod);
                  if AktAmiOzn is TAmiTrubka then begin
                    if NOT PorovnejBody(AktBodAmi, Point(-MaxInt div 2, -MaxInt div 2))
                      then Bod := AktBodAmi;

                    DelejPohniObjektyNaTrubce(Bod, AktAmiOzn, CisloSymbolu=23,
                       FALSE, TRUE);  { at to nekresli }
                    SpocitatBodySpojTr := TRUE;
                    SpocitatBodyNedotahuTr := TRUE;
                  end;

                  with AktAmiOzn do begin
                    case CisloSymbolu of
                      11, 21, 27, 51, 61 : begin
        {                RelKonec := Point(RelKonec.X-Bod.X+Pocatek.X,
                                          RelKonec.Y-Bod.Y+Pocatek.Y);
                        Pocatek := Bod;                                }
                        BoE := AbsKonec;
                        Pocatek := Bod;
                        AbsKonec := BoE;
                      end;

                      31 : begin
                        MaVymazatVypocet := FALSE;
                        if AktAmiOzn is TAmiPopis then begin
                          with AktAmiOzn as TAmiPopis do begin
                            BoE := AbsDrzatko;
                            Pocatek := Bod;
                            AbsDrzatko := BoE;
          {                    RelDrzatko := Point(RelDrzatko.X-Bod.X+Pocatek.X,
                                                RelDrzatko.Y-Bod.Y+Pocatek.Y);
                            Pocatek := Bod; }
                          end;
                        end;

                        if AktAmiOzn is TAmiTextik then begin
                          with AktAmiOzn as TAmiTextik do begin
                            BoE := AbsDrzatko;
                            Pocatek := Bod;
                            AbsDrzatko := BoE;
          {                    RelDrzatko := Point(RelDrzatko.X-Bod.X+Pocatek.X,
                                                RelDrzatko.Y-Bod.Y+Pocatek.Y);
                            Pocatek := Bod; }
                          end;
                        end;
                      end;

                      12,22,62 : begin
                        RelKonec := Point(Bod.X-Pocatek.X,
                                          RelKonec.Y-Bod.Y+Pocatek.Y);
                        Pocatek := Point(Pocatek.X,Bod.Y);
                      end;

                      13, 23, 28, 53, 63 : begin
                        AbsKonec := Bod;
        {                RelKonec := Point(Bod.X-Pocatek.X,
                                          Bod.Y-Pocatek.Y); }
                      end;

                      33 : begin
                        if AktAmiOzn is TAmiPopis then begin
                          with AktAmiOzn as TAmiPopis do
                            AbsDrzatko := Bod;
                        end;

                        if AktAmiOzn is TAmiTextik then begin
                          with AktAmiOzn as TAmiTextik do
                            AbsDrzatko := Bod;
                        end;
                      end;

                      35 : begin
                        BoP := Pocatek;
                        if Abs(Bod.X-BoP.X)>=Abs(Bod.Y-BoP.Y) then begin
                          if Bod.X<BoP.X then Orientace := 2
                                         else Orientace := 0;
                        end else begin
                          if Bod.Y<BoP.Y then Orientace := 3
                                         else Orientace := 1;
                        end;

        {               if AktAmiOzn is TAmiPopis then begin
                          with AktAmiOzn as TAmiPopis do
                            AbsDrzatko := Bod;
                        end;

                        if AktAmiOzn is TAmiTextik then begin
                          with AktAmiOzn as TAmiTextik do
                            AbsDrzatko := Bod;
                        end; }
                      end;

                      14, 24, 64 : begin
                        RelKonec := Point(RelKonec.X-Bod.X+Pocatek.X,
                                          Bod.Y-Pocatek.Y);
                        Pocatek := Point(Bod.X,Pocatek.Y);
                      end;

                      15, 65 : begin
                        RelKonec := Point(RelKonec.X,
                                          RelKonec.Y-Bod.Y+Pocatek.Y);
                        Pocatek := Point(Pocatek.X,Bod.Y);
                      end;

                      16, 66 : begin
                        RelKonec := Point(Bod.X-Pocatek.X,RelKonec.Y);
                      end;

                      17, 67 : begin
                        RelKonec := Point(RelKonec.X,Bod.Y-Pocatek.Y);
                      end;

                      18, 68 : begin
                        RelKonec := Point(RelKonec.X-Bod.X+Pocatek.X,
                                          RelKonec.Y);
                        Pocatek := Point(Bod.X,Pocatek.Y);
                      end;

                      41 : begin
                        // otoceni ventilu nebo fitingu
                      end;

                      42 : begin
                        // posunuti bodu kapilary ventilu
                        BodyUch[CisloBoduKapilary] := Bod;
                      end;

                      46, 47 : begin
                        if AktAmiOzn is TAmiKotel then
                          with AktAmiOzn as TAmiKotel do
                            ZmenPripojeneObjekty;
                        SpocitatBodySpojTr := TRUE;
                      end;

                      71..73 : begin
                        if AktAmiOzn is TAmiPneuH then
                          with AktAmiOzn as TAmiPneuH do
//                            ZmenPripojeneObjekty;
//                        SpocitatBodySpojTr := TRUE;
                      end;

                      74 : begin
                        // posunuti bodu kapilarb1 PneuH
                        BodyUch[CisloBoduKapilary+3] := Bod;
                      end;

                      81..88 : begin
                        if AktAmiOzn is TAmiOblouk then begin
                          with AktAmiOzn as TAmiOblouk do begin
                            DelejSpocRealBodik(PocAmi,
                              Point(StredObloucku.X-RObloucku, StredObloucku.Y-RObloucku),
                              KoefZvetseni, BodObloucku1);
                            DelejSpocRealBodik(Point(0, 0),
                              Point(2*RObloucku, 2*RObloucku), KoefZvetseni, BodObloucku2);

                            Pocatek := BodObloucku1;
                            RelKonec := BodObloucku2;
                            Alfa1 := Alf1Obloucku;
                            Alfa2 := Alf2Obloucku;
                            CitacKlikuObloucku := 0;
  //                          CisloSymbolu := 0;
  //                          Repaint;
                          end;
                        end;
                      end;

                      91 : begin
                        { otoceni venti2 }
  {                      Ve1 := Point(BodyUch[1].X-Pocatek.X, 0);
                        Ve2 := Point(Bod.X-Pocatek.X, 0);
                        if Ve1.X*Ve2.X+Ve1.Y*Ve2.Y<0 then begin
                          if AktAmiOzn.Orientace>=0 then AktAmiOzn.Orientace := -1
                                                    else AktAmiOzn.Orientace := 0;
                          AktAmiOzn.Kresli(NIL, KoefZvetseni, 4, PocAmi);
                        end; }
                      end;

                      101..105 : begin
                        if AktAmiOzn is TAmiSchema then
                          with AktAmiOzn as TAmiSchema do
                            ZmenPripojeneObjekty;
                        SpocitatBodySpojTr := TRUE;
                      end;

                      // venti4
                      121 : begin
                        BodyUch[1] := Bod;
                      end;
                      122 : begin
                        Pocatek := Bod;
                      end;
                      123 : begin
                        BodyUch[3] := Bod;
                      end;

                      10*(TypVenti3+0)+1,10*(TypVenti3+1)+1,10*(TypVenti3+2)+1 : begin
                        BoP := Pocatek;
                        BoK := AbsKonec;
                        if CisloSymbolu=10*TypVenti3+1 then DifV := 200
                                                       else DifV := 150;
                        PocPrip := Round((BoK.X-Bod.X-200)/DifV);
                        PocPrip := Min(Max(0,PocPrip),MaxPocPripVent);
                        BoE := Point(BoK.X-200-PocPrip*DifV, BoK.Y);

                        Pocatek := BoE;
                        AbsKonec := BoK;
                        SpocitatBodySpojTr := TRUE;
                        SpocitatBodyNedotahuTr := TRUE;
                      end;


                      10*TypVenti3+3,10*(TypVenti3+1)+3,10*(TypVenti3+2)+3 : begin
                        BoP := Pocatek;
                        BoK := AbsKonec;
                        if CisloSymbolu=10*TypVenti3+3 then DifV := 200
                                                       else DifV := 150;
                        PocPrip := Round((Bod.X-BoP.X-200)/DifV);
                        PocPrip := Min(Max(0,PocPrip),MaxPocPripVent);
                        BoE := Point(BoP.X+200+PocPrip*DifV, BoK.Y);

                        AbsKonec := BoE;
                        SpocitatBodySpojTr := TRUE;
                        SpocitatBodyNedotahuTr := TRUE;
                      end;

                    end;
                  end;

                  if AktAmiOzn is TAmiTrubka then begin
                    if DistBodu(AktAmiOzn.Pocatek, AktAmiOzn.AbsKonec) <
                                      MinDelkaTrub1 div 2 then begin
                      if AmiLispik.IndexOf(AktAmiOzn)>=0 then
                        AmiLispik.Remove(AktAmiOzn);
                      AktAmiOzn.Free;
    {                  DelejOznAmi_99(NIL); }
                      AktAmiOzn := NIL;
                    end;
                    SpojTrubky;
                    RozdelTrubky;
                    RozdelTrubPokoji;

                    SpocitatBodySpojTr := TRUE;
                    SpocitatBodyNedotahuTr := TRUE;
                  end;

                  if AktAmiOzn is TAmiPokoj then begin
                    AktAmiOzn.SpocitejORect;
                    if ((Abs(AktAmiOzn.RelKonec.X)<MinDelkaPokoje) OR
                        (Abs(AktAmiOzn.RelKonec.X)<MinVyskaPokoje)) then begin
                      AC := AktAmiOzn.AmCl;
                      if AmiLispik.IndexOf(AktAmiOzn)>=0 then
                        AmiLispik.Remove(AktAmiOzn);
                      AktAmiOzn.Free;
                      AktAmiOzn := NIL;

                      if AmiLispik.IndexOf(AC)>=0 then
                        AmiLispik.Remove(AC);
                      AC.Free;

                    end else begin
                      if AktAmiOzn.AmCl=NIL then begin
                        AC := TAmiPopis.Creatf(AmiLispik,
                              Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y-300),
                                     Point(500,-250),
                              Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y-300),
                                     TypPopisPok1,AktAmiOzn);
                        AmiLispik.Add(AC);
                        AktAmiOzn.AmCl := AC;
                        AC.PraveVlozeny := TRUE;
                      end else begin
                        AktAmiOzn.AmCl.Pocatek :=
                          Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y-300);
                        AktAmiOzn.AmCl.RelKonec := Point(500,-250);
                      end;
                    end;
                    SpojTrubky;
                    RozdelTrubPokoji;
                  end;

                  if AktAmiOzn is TAmiStrop1 then begin
                    AktAmiOzn.SpocitejORect;
                    for i := 0 to AmiLispik.Count-1 do begin
                      AC := AmiLispik.Items[i];
                      if AC is TAmiVyska then
                        if AC.AmCl=AktAmiOzn then begin
                          BAC := Point(AC.Pocatek.X, AktAmiOzn.HL.Y);
                          if (BAC.X<AktAmiOzn.HL.X) then
                            BAC.X := AktAmiOzn.HL.X+200;
                          if  (BAC.X>AktAmiOzn.DP.X) then
                            BAC.X := AktAmiOzn.DP.X-200;
                          AC.Pocatek := BAC;
                        end;
                    end;
                  end;

                  if ((AktAmiOzn is TAmiOblouk) AND (AktAmiOzn.Typ=TypAmiOblouk1)) then begin
                    if ((Abs(AktAmiOzn.RelKonec.X)<Griq.X) OR
                        (Abs(AktAmiOzn.RelKonec.X)<Griq.Y)) then begin
                      if AmiLispik.IndexOf(AktAmiOzn)>=0 then
                        AmiLispik.Remove(AktAmiOzn);
                      AktAmiOzn.Free;
                      AktAmiOzn := NIL;
                    end;
                  end;

                  if (AktAmiOzn is TAmiCara) OR (AktAmiOzn is TAmiObdelnik) then begin
                    if DistBodu(AktAmiOzn.Pocatek, AktAmiOzn.AbsKonec) <
                                      MinDelkaTrub1 div 2 then begin
                      if AmiLispik.IndexOf(AktAmiOzn)>=0 then
                        AmiLispik.Remove(AktAmiOzn);
                      AktAmiOzn.Free;
                      AktAmiOzn := NIL;
                    end;
                  end;


                  DelejOpravVztahy_99;
                  BZobrazitsKontrolou := FALSE;
                  ZobrazitKontrolu_99(FALSE, FALSE);
                  MaVymazatVypocet := AktAmiOzn.JeObjektProVypocet;
                  if MaVymazatVypocet then
                    VypocetHotov := FALSE;
                  DelejVymazVypocet_99;;
                  ZmenaProjektu := TRUE;
                end else begin
                  if HejbalObjektyNaTrubce then begin
                    DelejOpravVztahy_99;
                  end;
                end;
              end else begin
                Case CisloSymbolu of
                  SymUpravStropy : begin
                    DelejSpocitejBodGrid(PocAmi,Myska,Griq,KoefZvetseni,Bod);
                    DelejSpocitejBodGrid(PocAmi,Kotva,Griq,KoefZvetseni,Boe);
                    DelejUpravStropy_99(Boe, Bod);
                  end;

                  SymOblastProTisk : begin
                    DelejSpocRealBodik(PocAmi,Myska,KoefZvetseni,Bod);
                    DelejSpocRealBodik(PocAmi,Kotva,KoefZvetseni,Boe);
        {            DelejUpravStropy_99(Boe, Bod); }
                    if (Abs(Bod.X-Boe.X)>=PripRozTisk) AND
                       (Abs(Bod.Y-Boe.Y)>=PripRozTisk) then begin
                      JeOblastProTisk := TRUE;
                      VyrezTiskuB1 := Point(Min(Bod.X, Boe.X), Max(Bod.Y, Boe.Y));
                      VyrezTiskuB2 := Point(Max(Bod.X, Boe.X), Min(Bod.Y, Boe.Y));
                    end else begin
                      DialogsCZ.MessageDlg(SMalaOblastProTisk, mtWarning, [mbOk], 0);
                      JeOblastProTisk := FALSE;
                    end;
                  end;

                  SymDelejZoomLupa : begin
                    if (Abs(Myska.X-Kotva.X)<3) AND (Abs(Myska.Y-Kotva.Y)<3) then i := 1
                                                                             else i := 0;
                    DelejSpocRealBodik(PocAmi,Myska,KoefZvetseni,Bod);
                    DelejSpocRealBodik(PocAmi,Kotva,KoefZvetseni,Boe);
                    DelejZoom_99(Bod, Boe, i, 1);
                  end;

                  SymDelejZoomKriz : begin
                    if (Abs(Myska.X-Kotva.X)<3) AND (Abs(Myska.Y-Kotva.Y)<3) then i := 1
                                                                             else i := 0;
                    DelejSpocRealBodik(PocAmi,Myska,KoefZvetseni,Bod);
                    DelejSpocRealBodik(PocAmi,Kotva,KoefZvetseni,Boe);
                    DelejZoom_99(Bod, Boe, i, 1);

                    CisloCimJede_99 := CisloCimJedf_99;
                    CisloSymbolu := CisloSymbolv;
                    if AForm_A is TFormA then
                      with TFormA(AForm_A) do begin
                        if ToolB97Zobr1.Down then
                          AktCisloKurzorv := crLUPA;
                        if ToolB97Zobr2.Down then
                          AktCisloKurzorv := crPacka;
                        if ToolB97Zobr3.Down then
                          AktCisloKurzorv := crSTREDA;
                      end;

                    DelejVyberKurzor_99(AktCisloKurzorv);

  {                  if ToolB97Zobr1.Down then CisloSymbolu := SymDelejZoomLupa;
                    if ToolB97Zobr2.Down then CisloSymbolu := SymPosunVykres;
                    if ToolB97Zobr3.Down then CisloSymbolu := SymPosunDoStredu; }
                  end;

                end;
              end;
            end;
          end;
    (*      if (CisloSymbolu>=0) AND (CisloSymbolu<10) then begin
            if (Bod.X<>0) OR (Bod.Y<>0) then begin
              if OznList.Count>0 then begin
                if PohnulMysivPB then begin
                  MaVymazatVypocet := ObsahujeObjektproVyp(OznList);
                  OznList.PosunAmi(Bod);

                  SpojTrubky;
                  RozdelTrubky;
                  DelejOpravVztahy_99;
                  OznList.Clear;
      {            DelejVyberOzn1; }

                  BZobrazitsKontrolou := FALSE;
                  ZobrazitKontrolu1.Checked := FALSE;
                  ZobrazitKontrolu1.Enabled := FALSE;
                  DelejVymazVypocet;
                  ZmenaProjektu := TRUE;
                  SpocitatBodySpojTr := MaVymazatVypocet;
                  DelejInvalidu_99;
                end;
              end else begin
      {          if VybList.Count>0 then begin
                  if PohnulMysivPB then begin
                    VybList.PosunAmi(Bod);
                    DelejOpravVztahy_99;
                    Invalidate;
                  end else begin
                    if NOT (ssCtrl in Shift) then begin
                      VybList.Clear;
                      if AktAmiPom<>NIL then begin
                        DelejAktAmi(AktAmiPom);
                        DelejVyberOzn1;
                        DelejInvalidu_99;
                      end;
                    end;
                  end;
                end else }
                begin
                  VybList.Clear;
                  DelejSpocRealBodik(PocAmi,Point(X,Y),KoefZvetseni,Bod);
                  if PohnulMysivPB then begin
                    DelejSpocRealBodik(PocAmi,Kotva,KoefZvetseni,Boe);
                    for i := 0 to AmiLispik.Count-1 do begin
                      AC := TAmiClass(AmiLispik.Items[i]);
                      if AC.ObsazenvRect(Rect(Bod.X,Bod.Y,Boe.X,Boe.Y)) then
                        VybList.Add(AC);

                    end;
                    if VybList.Count>0 then begin
                      DelejOznzListu_99(VybList);
                      DelejInvalidu_99;
                    end;
                  end;
                end;
              end;
            end else begin
              if NOT PohnulMysivPB then begin
                if AktAmiPom<>NIL then begin
                  if NOT (ssCtrl in Shift) then begin
                    DelejOznAmi_99(AktAmiPom);
                    AktAmiPom := NIL;
                    VybList.Count := 0;
                  end;
                end;
              end;
            end;
          end;
        end else begin
          if CisloSymbolu>0 then begin
            if (AktAmiOzn<>NIL) AND PohnulMysivPB then begin
              DelejSpocitejBodGrid(PocAmi,Myska,Griq,KoefZvetseni,Bod);
              if AktAmiOzn is TAmiTrubka then begin
                if NOT PorovnejBody(AktBodAmi, Point(-MaxInt div 2, -MaxInt div 2))
                  then Bod := AktBodAmi;

                DelejPohniObjektyNaTrubce(Bod, AktAmiOzn, CisloSymbolu=23, FALSE);  { at to nekresli }
                SpocitatBodySpojTr := TRUE;
              end;

              with AktAmiOzn do begin
                case CisloSymbolu of
                  11,21,27,51,61 : begin
    {                RelKonec := Point(RelKonec.X-Bod.X+Pocatek.X,

                                      RelKonec.Y-Bod.Y+Pocatek.Y);
                    Pocatek := Bod;                                }
                    BoE := AbsKonec;
                    Pocatek := Bod;
                    AbsKonec := BoE;
                  end;

                  31 : begin
                    MaVymazatVypocet := FALSE;
                    if AktAmiOzn is TAmiPopis then begin
                      with AktAmiOzn as TAmiPopis do begin
                        BoE := AbsDrzatko;
                        Pocatek := Bod;
                        AbsDrzatko := BoE;
      {                    RelDrzatko := Point(RelDrzatko.X-Bod.X+Pocatek.X,
                                            RelDrzatko.Y-Bod.Y+Pocatek.Y);
                        Pocatek := Bod; }
                      end;
                    end;

                    if AktAmiOzn is TAmiTextik then begin
                      with AktAmiOzn as TAmiTextik do begin
                        BoE := AbsDrzatko;
                        Pocatek := Bod;
                        AbsDrzatko := BoE;
      {                    RelDrzatko := Point(RelDrzatko.X-Bod.X+Pocatek.X,
                                            RelDrzatko.Y-Bod.Y+Pocatek.Y);
                        Pocatek := Bod; }
                      end;
                    end;
                  end;

                  12,22,62 : begin
                    RelKonec := Point(Bod.X-Pocatek.X,
                                      RelKonec.Y-Bod.Y+Pocatek.Y);
                    Pocatek := Point(Pocatek.X,Bod.Y);
                  end;

                  13,23,28,53,63 : begin
                    AbsKonec := Bod;
    {                RelKonec := Point(Bod.X-Pocatek.X,
                                      Bod.Y-Pocatek.Y); }
                  end;

                  33 : begin
                    if AktAmiOzn is TAmiPopis then begin
                      with AktAmiOzn as TAmiPopis do
                        AbsDrzatko := Bod;
                    end;

                    if AktAmiOzn is TAmiTextik then begin
                      with AktAmiOzn as TAmiTextik do
                        AbsDrzatko := Bod;
                    end;
                  end;

                  35 : begin
                    BoP := Pocatek;
                    if Abs(Bod.X-BoP.X)>=Abs(Bod.Y-BoP.Y) then begin
                      if Bod.X<BoP.X then Orientace := 2
                                     else Orientace := 0;
                    end else begin
                      if Bod.Y<BoP.Y then Orientace := 3
                                     else Orientace := 1;
                    end;

    {               if AktAmiOzn is TAmiPopis then begin
                      with AktAmiOzn as TAmiPopis do
                        AbsDrzatko := Bod;
                    end;

                    if AktAmiOzn is TAmiTextik then begin
                      with AktAmiOzn as TAmiTextik do
                        AbsDrzatko := Bod;
                    end; }
                  end;

                  14,24,64 : begin
                    RelKonec := Point(RelKonec.X-Bod.X+Pocatek.X,
                                      Bod.Y-Pocatek.Y);
                    Pocatek := Point(Bod.X,Pocatek.Y);
                  end;

                  15,65 : begin
                    RelKonec := Point(RelKonec.X,
                                      RelKonec.Y-Bod.Y+Pocatek.Y);
                    Pocatek := Point(Pocatek.X,Bod.Y);
                  end;

                  16,66 : begin
                    RelKonec := Point(Bod.X-Pocatek.X,RelKonec.Y);
                  end;

                  17,67 : begin
                    RelKonec := Point(RelKonec.X,Bod.Y-Pocatek.Y);
                  end;

                  18,68 : begin
                    RelKonec := Point(RelKonec.X-Bod.X+Pocatek.X,
                                      RelKonec.Y);
                    Pocatek := Point(Bod.X,Pocatek.Y);
                  end;

                  41 : begin
                    { otoceni ventilu nebo fitingu }
                  end;

                  10*(TypVenti3+0)+1,10*(TypVenti3+1)+1,10*(TypVenti3+2)+1 : begin
                    BoP := Pocatek;
                    BoK := AbsKonec;
                    if CisloSymbolu=10*TypVenti3+1 then DifV := 200
                                                   else DifV := 150;
                    PocPrip := Round((BoK.X-Bod.X-200)/DifV);
                    PocPrip := Min(Max(0,PocPrip),MaxPocPripVent);
                    BoE := Point(BoK.X-200-PocPrip*DifV, BoK.Y);

                    Pocatek := BoE;
                    AbsKonec := BoK;
                    SpocitatBodySpojTr := TRUE;
                  end;

                  10*TypVenti3+3,10*(TypVenti3+1)+3,10*(TypVenti3+2)+3 : begin
                    BoP := Pocatek;
                    BoK := AbsKonec;
                    if CisloSymbolu=10*TypVenti3+3 then DifV := 200
                                                   else DifV := 150;
                    PocPrip := Round((Bod.X-BoP.X-200)/DifV);
                    PocPrip := Min(Max(0,PocPrip),MaxPocPripVent);
                    BoE := Point(BoP.X+200+PocPrip*DifV, BoK.Y);

                    AbsKonec := BoE;
                    SpocitatBodySpojTr := TRUE;
                  end;

                end;
              end;

              if AktAmiOzn is TAmiTrubka then begin
                if DistBodu(AktAmiOzn.Pocatek, AktAmiOzn.AbsKonec) <
                                  MinDelkaTrub1 div 2 then begin
                  if AmiLispik.IndexOf(AktAmiOzn)>=0 then
                    AmiLispik.Remove(AktAmiOzn);
                  AktAmiOzn.Free;
                  DelejOznAmi_99(NIL);
                end;
                SpojTrubky;
                RozdelTrubky;
                SpocitatBodySpojTr := TRUE;
              end;

              if AktAmiOzn is TAmiPokoj then begin
                AktAmiOzn.SpocitejORect;
                if AktAmiOzn.AmCl=NIL then begin
                  AC := TAmiPopis.Creatf(AmiLispik,
                        Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y-300),
                               Point(500,-250),
                        Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y-300),
                               TypPopisPok1,AktAmiOzn);
                  AmiLispik.Add(AC);
                  AktAmiOzn.AmCl := AC;
                  AC.PraveVlozeny := TRUE;
                end else begin
                  AktAmiOzn.AmCl.Pocatek :=
                    Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y-300);
                  AktAmiOzn.AmCl.RelKonec := Point(500,-250);
                end;
              end;
              DelejOpravVztahy_99;
              BZobrazitsKontrolou := FALSE;
              ZobrazitKontrolu1.Checked := FALSE;
              ZobrazitKontrolu1.Enabled := FALSE;
              MaVymazatVypocet := AktAmiOzn.JeObjektProVypocet;
              DelejVymazVypocet;
              ZmenaProjektu := TRUE;

            end;
          end else begin
            Case CisloSymbolu of
              SymUpravStropy : begin
                DelejSpocitejBodGrid(PocAmi,Myska,Griq,KoefZvetseni,Bod);
                DelejSpocitejBodGrid(PocAmi,Kotva,Griq,KoefZvetseni,Boe);
                DelejUpravStropy_99(Boe, Bod);
              end;

              SymOblastProTisk : begin
                DelejSpocRealBodik(PocAmi,Myska,KoefZvetseni,Bod);
                DelejSpocRealBodik(PocAmi,Kotva,KoefZvetseni,Boe);
    {            DelejUpravStropy(Boe, Bod); }
                if (Abs(Bod.X-Boe.X)>=PripRozTisk) AND
                   (Abs(Bod.Y-Boe.Y)>=PripRozTisk) then begin
                  JeOblastProTisk := TRUE;
                  VyrezTiskuB1 := Point(Min(Bod.X, Boe.X), Max(Bod.Y, Boe.Y));
                  VyrezTiskuB2 := Point(Max(Bod.X, Boe.X), Min(Bod.Y, Boe.Y));
                end;
              end;
            end;

          end;   *)
        end;
        if BylssMiddle then begin
          CisloCimJede_99 := CisloCimJedf_99;
          CisloSymbolu := CisloSymbolv;
          if AForm_A is TFormA then
            with TFormA(AForm_A) do begin
              if ToolB97Zobr1.Down then
                AktCisloKurzorv := crLUPA;
              if ToolB97Zobr2.Down then
                AktCisloKurzorv := crPacka;
              if ToolB97Zobr3.Down then
                AktCisloKurzorv := crSTREDA;
            end;
          DelejVyberKurzor_99(AktCisloKurzorv);
        end;
      end;
      DelejTabulky_99;
      PohnulMysivPB := FALSE;
      ShDnMovePB := FALSE;
      Myska := Point(X,Y);
      CisloSymbolu := 0;
      AktAmiPom := NIL;
      PohnoutViceTrubkami := FALSE;
      PohnoutViceRadKot := FALSE;

      if BDelejRozdelStropy then
        PaintBox1.Cursor := crDefault;
      BDelejRozdelStropy := FALSE;

{      if RozdelitStropy1.Checked OR ARozdelitStropy1.Checked then
        PaintBox1.Cursor := crDefault;
      RozdelitStropy1.Checked := FALSE;
      ARozdelitStropy1.Checked := RozdelitStropy1.Checked;
      if OblastProTisk1.Checked OR AOblastProTisk1.Checked then
        PaintBox1.Cursor := crDefault;
      OblastProTisk1.Checked := FALSE;
      AOblastProTisk1.Checked := OblastProTisk1.Checked; }

      DelejUmozniUpravy_99;
      if AForm_A is TFormA then
        with TFormA(AForm_A) do begin
          if RozdelitStropy1.Checked OR ARozdelitStropy1.Checked then
            PaintBox1.Cursor := crDefault;
          RozdelitStropy1.Checked := FALSE;
          ARozdelitStropy1.Checked := RozdelitStropy1.Checked;
          if OblastProTisk1.Checked OR AOblastProTisk1.Checked then
            PaintBox1.Cursor := crDefault;
          OblastProTisk1.Checked := FALSE;
          AOblastProTisk1.Checked := OblastProTisk1.Checked;
        end;

      KalibrujVyskaA;


    end;

  {  if ssRight in Shift then begin
      case CisloCimJede_99 of
        SymDelejZoomLupa : begin
          DelejSpocRealBodik(PocAmi,Point(X, Y), KoefZvetseni, Bod);
          DelejZoom_99(Bod, Bod, -1, 1);
        end;
      end;
    end; }
{    if AForm_A is TFormA then
      with TFormA(AForm_A) do} begin
        VlozitBodKapilary1.Visible := FALSE;
        ZrusitBodKapilary1.Visible := FALSE;
        NBodyKapilary1.Visible := FALSE;
        CisloBoduKapilary := 0;
        if BylssRight then begin
          case CisloCimJede_99 of
            0 : begin
              if AktAmiOzn is TAmiClass then begin
                DelejSpocRealBodik(PocAmi, Point(X, Y), KoefZvetseni, Bod);
                AktAmiOzn.DotazVlozZrusBodkapilary(Bod, CisloBoduKapilary,
                  ABodVlozit, AEnableVlozit, ABodZrusit, AEnableZrusit, NovyBodKapilary);

                VlozitBodKapilary1.Visible := ABodVlozit;
                VlozitBodKapilary1.Enabled := AEnableVlozit;
                ZrusitBodKapilary1.Visible := ABodZrusit;
                ZrusitBodKapilary1.Enabled := AEnableZrusit;

                NBodyKapilary1.Visible := ABodVlozit OR ABodZrusit;
              end;
            end;

            SymDelejZoomLupa : begin
              DelejSpocRealBodik(PocAmi,Point(X, Y), KoefZvetseni, Bod);
              DelejZoom_99(Bod, Bod, -1, 1);
            end;
          end;
        end;

      end;

    for i := 0 to AmiLispik.Count-1 do begin
      AC := AmiLispik[i];
      AC.Rotuje := FALSE;
    end;

    HejbalObjektyNaTrubce := FALSE;
    DelejInvalidu_99;

  //  FormI.BringToFront;
  //  ConjoinDockHost.BringToFront;
  //  FormP.BringToFront;
    DelejUkazveVypoctu_99;
  end;
{  MysiKriz([],FALSE);
  MysiKriz([],FALSE); }
end;

procedure TFrForm99.PaintBox1DblClick(Sender: TObject);
var
  i : integer;
  AC : TAmiClass;
  B1, B2, BAC : TPoint;
  JeVyskaStropu : boolean;
  S : String;
  AZmena : boolean;

Procedure NajdiPolohuFormSch(AForm : TForm);
var
  B1Y, B2Y : integer;
  BO : TPoint;
begin
  with ATopChlad do begin
    DelejSpocAbsBodik(PocAmi, AktAmiOzn.Pocatek, KoefZvetseni, BAC);
    DelejSpocAbsBodik(PocAmi, AktAmiOzn.BodyPrip[1], KoefZvetseni, B1);
    DelejSpocAbsBodik(PocAmi, AktAmiOzn.BodyPrip[2], KoefZvetseni, B2);
  end;
  DelejSpocAbsBodik(Point(0, 0), Point(SchemaOkrajX, SchemaOkrajY), KoefZvetseni, BO);
  B1 := PaintBox1.ClientToScreen(B1);
  B2 := PaintBox1.ClientToScreen(B2);
  BAC := PaintBox1.ClientToScreen(BAC);
  B1Y := Min(B1.Y, B2.Y){+VysMer}+BO.Y;
  B2Y := Max(B1.Y, B2.Y){+VysMer}-BO.Y;

  if B2Y+15+AForm.Height>Screen.Height then begin
    AForm.Top := Max(0, B1Y-15-AForm.Height);
  end else begin
    AForm.Top := B2Y+15;
  end;
  AForm.Left := Min(BAC.X{-SirMer}, Screen.Width-AForm.Width-5);
end;

Procedure ObnovZrusenePopisy(ASch : TAmiClass);
var
  i : integer;
  AC, AP : TAmiClass;
  Obnovil : boolean;
begin
  Obnovil := FALSE;
  if ASch is TAmiSchema then begin
    with ASch as TAmiSchema do begin
      for i := 0 to 4 do begin
        case i of
          0 : AC := BalancniVentil1;
          1 : AC := BalancniVentil2;
          2 : AC := BalancniVentil3;
          3 : AC := DvojcestnyVentil;
          4 : AC := TrojcestnyVentil;
        end;
        if Assigned(AC) then begin
          with ATopChlad do begin
            AP := NajdiPopis(AmiLispik, AC);
            if AP=NIL then begin
              DelejVlozJedenPopisSchematu(ASch, AC, AmiLispik);
              Obnovil := TRUE;
            end;
          end;
        end;
      end;
    end;
  end;
  if Obnovil then
    DelejInvalidu_99;
end;

begin
  PBoxDblCl := TRUE;
  with ATopChlad do begin
    if AktAmiOzn<>NIL then begin
      SkrytFormP := FALSE;
      if AktAmiOzn is TAmiSoucAAA then
        ZadejAmiSoucAAA_99(TAmiSoucAAA(AktAmiOzn), TRUE);
      if (AktAmiOzn is TAmiCara) OR (AktAmiOzn is TAmiObdelnik) OR
         ((AktAmiOzn is TAmiTrubka) AND (AktAmiOzn.Typ=TypTrubkaCara5)) then
        if ZadejBarvaTypStylCary_99(AktAmiOzn, FALSE )>0 then
          DelejInvalidu_99;
      if ((AktAmiOzn is TAmiOblouk) AND (AktAmiOzn.Typ=TypAmiOblouk1)) then
        if ZadejBarvaTypStylElipsy_99(AktAmiOzn, FALSE)>0 then
          DelejInvalidu_99;
      if ((AktAmiOzn is TAmiOblouk) AND (AktAmiOzn.Typ=TypAmiOblouk2)) then
        if ZadejBarvaTypStylOblouku_99(AktAmiOzn, FALSE)>0 then
          DelejInvalidu_99;
      if AktAmiOzn is TAmiVyska then begin
        ZadejPopisVyska_99(AktAmiOzn);
        DelejInvalidu_99;
      end;
      if AktAmiOzn is TAmiVenti4 then begin
        with AktAmiOzn as TAmiVenti4 do
          SpocitejNejlepsiPolohu;
        DelejInvalidu_99;
      end;
      if AktAmiOzn is TAmiRazitko then begin
        ZadejPolohuRazitka_99(TAmiRazitko(AktAmiOzn), TRUE);
      end;

      if (AktAmiOzn is TAmiTrubka) AND (AktAmiOzn.Typ in [TypTrubka1..TypTrubka6])
            then begin
        DelejSpocRealBodik(PocAmi, Myska, KoefZvetseni, AKatva);
        DelejUmozniUNDQ_TChl(histInsert, histRozdelSpojTrubky, NIL, NIL);          //?????
        ZkusRozdelitneboSpojitTrubky(AKatva, AZmena);
        if AZmena then begin
          DelejPrvniREDQ_TChl(histInsert, histRozdelSpojTrubky, NIL, NIL);
        end else begin
          DelejVratKrokUNDQ_TChl;
        end;
      end;

      if ((AktAmiOzn is TAmiPokoj) OR
          ((AktAmiOzn is TAmiPopis) AND (AktAmiOzn.AmCl is TAmiPokoj))) then
        if BJsouTepelneZtraty then begin
          DelejTabulky_99;
          AFormP.ButtonClickTepelneZtraty(1);
        end;

      if (AktAmiOzn is TAmiRad1) then begin
        AktAmiOzn.SpocitejORect;
        AC := TAmiRad1(AktAmiOzn).NajdiPopis(AmiLispik);
        DelejUmozniUNDO_99;
        if BylssShift then
          with AktAmiOzn do
            Pocatek := Point(Round(Pocatek.X/Griq.X)*Griq.X, Round(Pocatek.Y/Griq.Y)*Griq.Y);
        if Assigned(AC) then begin
          // premisti popis do puvodni polohy
          if NOT PorovnejBody(AC.Pocatek,
                Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y+100)) then
            ZmenaProjektu := TRUE;
          DelejUmozniUNDQ_99(histAC, histSourPopisRad1, AC, NIL);          //?????
          AC.Pocatek := Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y+100);
          DelejPrvniREDQ_99(histAC, histSourPopisRad1, AC, NIL);          //?????
        end else begin
          // vytvori popis
          AC := TAmiPopis.Creatf(AmiLispik,
                Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y+100),
                       Point(500,-250),
                Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y+100),
                       TypPopisRad1,AktAmiOzn);
          DelejUmozniUNDQ_99(histInsert, histVlozPopisRad1, NIL, NIL);          //?????
          AmiLispik.Add(AC);
          AC.PraveVlozeny := TRUE;
          DelejPrvniREDQ_99(histInsert, histVlozPopisRad1, NIL, NIL);          //?????
          ZmenaProjektu := TRUE;
        end;
      end;

      if (AktAmiOzn is TAmiRad2) then begin
        AktAmiOzn.SpocitejORect;
        AC := TAmiRad2(AktAmiOzn).NajdiPopis(AmiLispik);
        DelejUmozniUNDO_99;
        if BylssShift then
          with AktAmiOzn do
            Pocatek := Point(Round(Pocatek.X/Griq.X)*Griq.X, Round(Pocatek.Y/Griq.Y)*Griq.Y);
        if Assigned(AC) then begin
          // premisti popis do puvodni polohy
          if NOT PorovnejBody(AC.Pocatek,
                Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y+100)) then
            ZmenaProjektu := TRUE;
          DelejUmozniUNDQ_99(histAC, histSourPopisRad2, AC, NIL);          //?????
          AC.Pocatek := Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y+100);
          DelejPrvniREDQ_99(histAC, histSourPopisRad2, AC, NIL);          //?????
        end else begin
          // vytvori popis
          AC := TAmiPopis.Creatf(AmiLispik,
                Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y+100),
                       Point(500,-250),
                Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y+100),
                       TypPopisRad2,AktAmiOzn);
          DelejUmozniUNDQ_99(histInsert, histVlozPopisRad2, NIL, NIL);          //?????
          AmiLispik.Add(AC);
          DelejPrvniREDQ_99(histInsert, histVlozPopisRad2, NIL, NIL);          //?????
          AC.PraveVlozeny := TRUE;
          ZmenaProjektu := TRUE;
        end;
      end;

      if (AktAmiOzn is TAmiVentil) then begin
        if TAmiVentil(AktAmiOzn).PovinnyPopis then begin
          if NOT Assigned(TAmiVentil(AktAmiOzn).NajdiPopis(AmiLispik)) then begin
            AktAmiOzn.SpocitejORect;
            AC := TAmiPopis.Creatf(AmiLispik,
                  Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y+100),
                         Point(500,-250),
                  Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y+100),
                         TypPopisVent,AktAmiOzn);
            DelejUmozniUNDO_99;
            DelejUmozniUNDQ_99(histInsert, histPopisVent, NIL, NIL);          //?????
            AmiLispik.Add(AC);
            AC.PraveVlozeny := TRUE;
            DelejPrvniREDQ_99(histInsert, histPopisVent, NIL, NIL);          //?????
            ZmenaProjektu := TRUE;
          end;
        end;
        if Length(TAmiVentil(AktAmiOzn).Kapilara)>0 then begin

        end;

      end;

      if (AktAmiOzn is TAmiStrop1) then begin
        B1 := AktAmiOzn.Pocatek;
        B2 := AktAmiOzn.AbsKonec;
        if DelejUpravStrop2(B1, B2) then begin
          DelejUmozniUNDO_99;
          AktAmiOzn.Pocatek := B1;
          AktAmiOzn.AbsKonec := B2;

          JeVyskaStropu := FALSE;
          for i := 0 to AmiLispik.Count-1 do begin
            AC := AmiLispik.Items[i];
            if AC is TAmiVyska then
              if AC.AmCl=AktAmiOzn then begin
                BAC := Point(AC.Pocatek.X, B2.Y);
                if (BAC.X<B1.X) then
                  BAC.X := B1.X+200;
                if (BAC.X>B2.X) then
                  BAC.X := B2.X-200;
                AC.Pocatek := BAC;
                JeVyskaStropu := TRUE;
              end;
          end;

          if NOT JeVyskaStropu then begin
            DelejUmozniUNDQ_99(histInsert, histPopisStropu, NIL, NIL);          //?????
            DelejVlozPopisVysky(Point(AktAmiOzn.Pocatek.X+200, AktAmiOzn.AbsKonec.Y),
               AmiLispik, 0);
            DelejPrvniREDQ_99(histInsert, histPopisStropu, NIL, NIL);          //?????
            ZmenaProjektu := TRUE;
          end;

          DelejInvalidu_99;
        end;
      end;

      if (AktAmiOzn is TAmiPopis) then begin
        if AktAmiOzn.Typ=TypPopisTru4 then begin
          S := IntToStr(TAmiPopis(AktAmiOzn).Cislicko);
          if DialogsCZ.InputQuery(SZapisteSklon,'',S) then begin
            if S<>'' then begin
              Try
                i := StrToInt(S);
                if (i>=0) AND (i<1000) then begin
                  if TAmiPopis(AktAmiOzn).Cislicko<>i then begin
                    DelejUmozniUNDQ_99(histInsert, histPopisTru4, NIL, NIL);
                    TAmiPopis(AktAmiOzn).Cislicko := i;
                    DelejPrvniREDQ_99(histInsert, histPopisTru4, NIL, NIL);
                  end;
                end;
              except

              end;
            end;
          end;
        end;
      end;

      if AktAmiOzn is TAmiSchema then begin
        DelejUmozniUNDQ_99(histInsert, histParSchema, NIL, NIL);
        if BylssShift then
          with AktAmiOzn do begin
            Pocatek := Point(Round(Pocatek.X/Griq.X)*Griq.X, Round(Pocatek.Y/Griq.Y)*Griq.Y);
          end;

        ObnovZrusenePopisy(AktAmiOzn);
        NajdiPolohuFormSch(FormSch);
        FormSch.AFrForm99 := Self;
        FormSch.UdelejGrid(AktAmiOzn);
        FormSch.ShowModal;
        DelejPrvniREDQ_99(histInsert, histParSchema, NIL, NIL);
        DelejInvalidu_99;
      end;

    end else begin
      DelejUmozniUNDQ_TChl(histInsert, histRozdelSpojTrubkw, NIL, NIL);          //?????
      ZkusRozdelitneboSpojitTrubkw(AKatva, AZmena);
      if AZmena then begin
        DelejPrvniREDQ_TChl(histInsert, histRozdelSpojTrubkw, NIL, NIL);
      end else begin
        DelejVratKrokUNDQ_TChl;
      end;
    end;
  end;
end;

Procedure TFrForm99.DelejZoom_99(Bod1, Bod2 : TPoint; Zvetsit : integer; Kolikrat : extended);
var
  SX,SY : integer;
  KX,KY : extended;
  AKoef : extended;
begin
  SX := Abs(Bod1.X-Bod2.X);
  SY := Abs(Bod2.Y-Bod1.Y);
  case Zvetsit of
    2 : begin
      if Kolikrat>0 then begin
        AKoef := Min(MaxKoeficientZvetseni, KoefZvetseni*Abs(Kolikrat)*KoeficientZvetseniMousWheel);
//        SX := Round(PaintBox1.Width/(AKoef*JMetrMM)*0.5);
//        SY := Round(PaintBox1.Height/(AKoef*JMetrMM)*0.5);
      end else begin
        AKoef := Max(MinKoeficientZvetseni, KoefZvetseni/(Abs(Kolikrat)*KoeficientZvetseniMousWheel));  // nepovoli vice zmensit
      end;
//        SX := Round(KoefZvetseni/AKoef*(Bod2.X-Bod1.X));
//        SY := Round(KoefZvetseni/AKoef*(Bod2.Y-Bod1.Y));
        SX := Round(KoefZvetseni/AKoef*(Bod2.X-Bod1.X));
        SY := Round(KoefZvetseni/AKoef*(Bod2.Y-Bod1.Y));
        Bod1.X := Bod1.X+SX;
        Bod1.Y := Bod1.Y+SY;
        Bod2.X := Bod1.X+Round(PaintBox1.Width/(AKoef*JMetrMM));
        Bod2.Y := Bod1.Y-Round(PaintBox1.Height/(AKoef*JMetrMM));
//        Bod2.X := Bod2.X-SX;
//        Bod2.Y := Bod2.Y-SY;
(*      end else begin
        AKoef := Max(MinKoeficientZvetseni, KoefZvetseni/(Abs(Kolikrat)*KoeficientZvetseniMousWheel));  // nepovoli vice zmensit
{        if AKoef<>KoefZvetseni then } begin
          SX := Round(PaintBox1.Width/(AKoef*JMetrMM)*0.5);
          SY := Round(PaintBox1.Height/(AKoef*JMetrMM)*0.5);
          Bod1.X := Bod1.X+SX;
          Bod1.Y := Bod1.Y+SY;
          Bod2.X := Bod2.X-SX;
          Bod2.Y := Bod2.Y-SY;
//          Bod1 := Bod2;
        end;
      end; *)
      KoefZvetseni := AKoef;
    end;
    1 : begin
      AKoef := Min(MaxKoeficientZvetseni, KoefZvetseni*KoeficientLupy);
      SX := Round(PaintBox1.Width/(AKoef*JMetrMM)*0.5);
      SY := Round(PaintBox1.Height/(AKoef*JMetrMM)*0.5);
      Bod2.X := Bod2.X-SX;
      Bod2.Y := Bod2.Y-SY;
      Bod1 := Bod2;
      KoefZvetseni := AKoef;
    end;
    0 : begin
      if SX>0 then KX := PaintBox1.Width/(SX*JMetrMM) else KX := MaxKoeficientZvetseni;
      if SY>0 then KY := PaintBox1.Height/(SY*JMetrMM) else KY := MaxKoeficientZvetseni;
      if KX>KY then begin
        KoefZvetseni := KY;
      end else begin
        KoefZvetseni := KX;
      end;
      if KoefZvetseni>MaxKoeficientZvetseni then
        KoefZvetseni := MaxKoeficientZvetseni;
    end;
    -1 : begin
      AKoef := Max(MinKoeficientZvetseni, KoefZvetseni/KoeficientLupy);  // nepovoli vice zmensit
//      if AKoef<>KoefZvetseni then begin
      begin
        SX := Round(PaintBox1.Width/(AKoef*JMetrMM)*0.5);
        SY := Round(PaintBox1.Height/(AKoef*JMetrMM)*0.5);
        Bod2.X := Bod2.X-SX;
        Bod2.Y := Bod2.Y-SY;
        Bod1 := Bod2;
        KoefZvetseni := AKoef;
      end;
    end;
  end;

  MuzeScroll := FALSE;
  ScrollBar1.Position := Min(Bod2.X, Bod1.X);
  ScrollBar2.Position := -Min(Bod2.Y, Bod1.Y)-
    Round(PaintBox1.Height/(KoefZvetseni*JMetrMM));


  DokonciNastaveniZoom_99;
  VlozNovyZoom_99(ScrollBar1.Position, ScrollBar2.Position, KoefZvetseni);
//  DelejInvalidu_99;
//  PaintBox1.Canvas.Draw(0,0, BiMa);
//  Invalidate;

//  Invalidate;
end;

Procedure TFrForm99.KnofZvClick(Sender: TObject);
var
  AHoLe, ADoPr : TPoint;
  SX,SY : integer;
  KX,KY : extended;
  i : integer;
  AC : TAmiClass;
begin
  MuzeScroll := FALSE;
  With Sender as TSpeedButton do begin
    Case Tag of
      9 : begin
        if SpocitejRozsahList(ATopChlad.AmiLispik, PaintBox1.Width, PaintBox1.Height,
           AHoLe, ADoPr, KoefZvetseni) then begin
          ScrollBar1.Position := AHoLe.X;
          ScrollBar2.Position := -ADoPr.Y-
            Round(PaintBox1.Height/(KoefZvetseni*JMetrMM));
        end;
      end;

{      10 : begin
        FormZoom.BitMap.Width := PaintBox1.Width;
        FormZoom.BitMap.Height := PaintBox1.Height;
        FormZoom.KoefZvetseni := KoefZvetseni;
        With FormZoom.BitMap.Canvas do begin
          Brush.Color := BarvaPozadiObr;
          Brush.Style := bsSolid;
          FillRect(Rect(0, 0, PaintBox1.Width, PaintBox1.Height));
        end;
        for i := 0 to AmiLispik.Count-1 do begin
          AC := TAmiClass(AmiLispik.Items[i]);
          AC.Kresli(FormZoom.BitMap.Canvas,KoefZvetseni,0,PocAmi);
        end;
        if FormZoom.ShowModal=mrOK then begin
          DelejSpocRealBodik(PocAmi,FormZoom.Kotva,KoefZvetseni,AHoLe);
          DelejSpocRealBodik(PocAmi,FormZoom.Kriz,KoefZvetseni,ADoPr);
          SX := Abs(ADoPr.X-AHoLe.X);
          SY := Abs(AHoLe.Y-ADoPr.Y);
          if SX>0 then KX := PaintBox1.Width/(SX*JMetrMM) else KX := 2;
          if SY>0 then KY := PaintBox1.Height/(SY*JMetrMM) else KY := 2;
          if KX>KY then begin
            KoefZvetseni := KY;
          end else begin
            KoefZvetseni := KX;
          end;
          if KoefZvetseni>MaxKoeficientZvetseni then
            KoefZvetseni := MaxKoeficientZvetseni;

          ScrollBar1.Position := Min(AHoLe.X, ADoPr.X);
          ScrollBar2.Position := -Min(AHoLe.Y, ADoPr.Y)-
            Round(PaintBox1.Height/(KoefZvetseni*JMetrMM));


        end;
      end }
      10 : begin
        CisloSymbolv := CisloSymbolu;
        CisloSymbolu := SymDelejZoomKriz;
        CisloCimJedf_99 := CisloCimJede_99;
        CisloCimJede_99 := SymJedeKrizem;
        ZoomKrizem := FALSE;

        DelejVyberKurzor_99(crNone);

      end;
    else
      KoefZvetseni := TabKoefZv[Tag];
    end;
  end;

  DokonciNastaveniZoom_99;
  VlozNovyZoom_99(ScrollBar1.Position, ScrollBar2.Position, KoefZvetseni);
end;

procedure TFrForm99.ScrollBar1Change(Sender: TObject);
var
  XA1, XA2, XB1, XB2 : integer;
  X, Y : integer;
  DX, ADX : integer;
  ObdPrem : TRect;
begin
  MysiKriz([], TRUE, FALSE);
  X := ScrollBar1.Position;
  PocAmi.X := Sitnice*Round(X/Sitnice);
  SpoctiKorku_99;
  if MuzeScroll then begin
    if PocAmi.X<>PoOAmi.X then begin
      if Assigned(ATopChlad.MetF) then begin
        DX := PocAmi.X-PoOAmi.X;
        ADX := Round(DX*KoefZvetseni*JMetrMM);
        PoAAmi.X := PoAAmi.X+ADX;

        PaintBox1.Canvas.Draw(PoAAmi.X, PoAAmi.Y, ATopChlad.MetF);
      end else begin
        Y := Bima.Height;
        DX := PocAmi.X-PoOAmi.X;
        ADX := Round(PocAmi.X*KoefZvetseni*JMetrMM)-
               Round(PoOAmi.X*KoefZvetseni*JMetrMM);
        ObdBiMa.Left := ObdBiMa.Left+DX;
        ObdBiMa.Right := ObdBiMa.Right+DX;
        ObdPrem := ObdBiMa;

        Bima.Canvas.Brush.Color := BarvaPozadiObr;
        Bima.Canvas.Brush.Style := bsSolid;
        if ADX<0 then begin
          ObdPrem.Right := ObdPrem.Left-DX;
          XA1 := -ADX;
          XA2 := BiMa.Width;
          XB1 := 0;
          XB2 := XA2+ADX;
          if XA1<XA2 then
            Bima.Canvas.Copyrect(Rect(XA1, 0, XA2, Y), Bima.Canvas,
                                 Rect(XB1, 0, XB2, Y));
          if XA1>BiMa.Width then XA1 := BiMa.Width;
          if BZobrazitGrid AND (KoefZvetseni>=1) then begin
            Bima.Canvas.Copyrect(Rect(XB1, 0, XA1, Y),BitMapGrid.Canvas,
                                 Rect(XB1, 0, XA1, Y));
          end else begin
            Bima.Canvas.FillRect(Rect(XB1, 0, XA1, Y));
          end;
          IntersectClipRect(BiMa.Canvas.Handle, XB1, 0, XA1+1, Y);
        end else begin
          ObdPrem.Left := ObdPrem.Right-DX;
          XA1 := 0;
          XA2 := BiMa.Width-ADX;
          XB1 := ADX;
          XB2 := BiMa.Width;
          if XA1<XA2 then
            BiMa.Canvas.Copyrect(Rect(XA1, 0, XA2, Y), Bima.Canvas,
                                 Rect(XB1, 0, XB2, Y));
          if XA2<0 then XA2 := 0;
          if BZobrazitGrid AND (KoefZvetseni>=1) then begin
            Bima.Canvas.Copyrect(Rect(XA2, 0, XB2, Y),BitMapGrid.Canvas,
                                 Rect(XA2, 0, XB2, Y));
          end else begin
            Bima.Canvas.FillRect(Rect(XA2, 0, XB2, Y));
          end;
          IntersectClipRect(BiMa.Canvas.Handle, XA2-1, 0, XB2, Y);
        end;
        ATopChlad.DelejKresliBiMa_TChl(BiMa, ObdPrem, KoefZvetseni, PocAmi);
        PaintBox1.Canvas.Draw(0, 0, BiMa);
        MeritkoX(PaintBoxMeritkoX.Canvas, KoefZvetseni, PocAmi, PaintBoxMeritkoX.Width);
//        CarkaNaPravitkuX;

        UkazOblastProTisk_99;
      end;
    end;
  end;
  PoOAmi.X := PocAmi.X;
  MysiKriz([], TRUE, FALSE);
end;

procedure TFrForm99.ScrollBar2Change(Sender: TObject);
var
  YA1, YA2, YB1, YB2 : integer;
  X, Y : integer;
  DY, ADY : integer;
  ObdPrem : TRect;
begin
  MysiKriz([], TRUE, FALSE);
  Y := -ScrollBar2.Position;
  PocAmi.Y := Sitnice*Round(Y/Sitnice);
  SpoctiKorku_99;
  if MuzeScroll then begin
    if PocAmi.Y<>PoOAmi.Y then begin
      if Assigned(ATopChlad.MetF) then begin
        DY := PocAmi.Y-PoOAmi.Y;
        ADY := Round(DY*KoefZvetseni*JMetrMM);
        PoAAmi.Y := PoAAmi.Y+ADY;
        PaintBox1.Canvas.Draw(PoAAmi.X, PoAAmi.Y, ATopChlad.MetF);
      end else begin
        X := Bima.Width;
        DY := PoOAmi.Y-PocAmi.Y;
        ADY := Round(PoOAmi.Y*KoefZvetseni*JMetrMM)-
               Round(PocAmi.Y*KoefZvetseni*JMetrMM);
        ObdBiMa.Top := ObdBiMa.Top-DY;
        ObdBiMa.Bottom := ObdBiMa.Bottom-DY;
        ObdPrem := ObdBiMa;

        Bima.Canvas.Brush.Color := BarvaPozadiObr;
        Bima.Canvas.Brush.Style := bsSolid;
        if ADY<0 then begin
          ObdPrem.Top := ObdPrem.Bottom+DY;
          YA1 := -ADY;
          YA2 := BiMa.Height;
          YB1 := 0;
          YB2 := YA2+ADY;
          if YA1<YA2 then
            Bima.Canvas.Copyrect(Rect(0, YA1, X, YA2), Bima.Canvas,
                                 Rect(0, YB1, X, YB2));
          if YA1>BiMa.Height then YA1 := BiMa.Height;
          if BZobrazitGrid AND (KoefZvetseni>=1) then begin
            Bima.Canvas.Copyrect(Rect(0, YB1, X, YA1),BitMapGrid.Canvas,
                                 Rect(0, YB1, X, YA1));
          end else begin
            Bima.Canvas.FillRect(Rect(0, YB1, X, YA1));
          end;
          IntersectClipRect(BiMa.Canvas.Handle, 0, YB1, X, YA1+1);
        end else begin
          ObdPrem.Bottom := ObdPrem.Top+DY;
          YA1 := 0;
          YA2 := BiMa.Height-ADY;
          YB1 := ADY;
          YB2 := BiMa.Height;
          if YA1<YA2 then
            BiMa.Canvas.Copyrect(Rect(0, YA1, X, YA2), Bima.Canvas,
                                 Rect(0, YB1, X, YB2));
          if YA2<0 then YA2 := 0;
          if BZobrazitGrid AND (KoefZvetseni>=1) then begin
            Bima.Canvas.Copyrect(Rect(0, YA2, X, YB2),BitMapGrid.Canvas,
                                 Rect(0, YA2, X, YB2));
          end else begin
            Bima.Canvas.FillRect(Rect(0, YA2, X, YB2));
          end;
          IntersectClipRect(BiMa.Canvas.Handle, 0, YA2-1, X, YB2);
        end;
        ATopChlad.DelejKresliBiMa_TChl(BiMa, ObdPrem, KoefZvetseni, PocAmi);
        PaintBox1.Canvas.Draw(0, 0, BiMa);
        MeritkoY(PaintBoxMeritkoY.Canvas, KoefZvetseni, PocAmi, PaintBoxMeritkoY.Height);
//        CarkaNaPravitkuY;
        UkazOblastProTisk_99;
      end;
    end;
{    DelejInvalidu_99; }
  end;
  PoOAmi.Y := PocAmi.Y;
  MysiKriz([], TRUE, FALSE);
end;

procedure TFrForm99.FrFormKeyDownOld(Sender: TObject; var Key: Word;
          Shift: TShiftState);
var
  i : integer;
  AC : TAmiClass;

begin
(*  ShDnMovePB := [ssShift]=Shift;
  case Key of
    27 : begin
      VidPanel1_99(FALSE);
      JakobyPageControlChange;
    end;
    46 : begin { delete }
{      if NOT AAControl then begin }
      if Shift=[ssCtrl] then begin
        VidPanel1_99(FALSE);
        DelejDelete_99;
      end;
    end;
{    13 : begin
      if ActiveControl is TComboBox then begin
        with ActiveControl as TComboBox do
          OnChange(ActiveControl);
      end;

      TryUpdateStrigGrids;
    end;      }

    33,34 : begin  { pgup, pgdown }
      if ssCtrl in Shift then begin
        if ActiveControl=ScrollBar2 then
          ScrollBar1.SetFocus
      end else begin
        if ActiveControl=ScrollBar1 then
          ScrollBar2.SetFocus;
      end;
    end;

    38,40 : begin  { sipka nahoru, dolu }
      if Shift=[] then begin
        if (ActiveControl=ScrollBar1){ OR (ActiveControl=PaintBox1)} then
          ScrollBar2.SetFocus;
      end;
      if Shift=[ssAlt] then begin
        if Key=38 then PosunSmer_99(4);
        if Key=40 then PosunSmer_99(3);
      end;
    end;

    37,39 : begin  { sipka vlevo, vpravo }
      if Shift=[] then begin
        if (ActiveControl=ScrollBar2){ OR (ActiveControl=PaintBox1)} then
          ScrollBar1.SetFocus;
      end;
      if Shift=[ssAlt] then begin
        if Key=37 then PosunSmer_99(1);
        if Key=39 then PosunSmer_99(2);
      end;
    end;

    Ord('A') : begin
      if [ssCtrl, ssShift]<=Shift then
        VybratVse1Click_99;
    end;

    Ord('C') : begin
      if [ssCtrl, ssShift]<=Shift then
        DelejVlozdoClipboardu_99;
    end;

    Ord('N') : begin
      if Shift=[ssCtrl] then
        Novy1Click_99;
    end;

    Ord('O') : begin
      if Shift=[ssCtrl] then
        Precti1Click_99;
    end;

    Ord('P') : begin
      if Shift=[ssCtrl] then
        TiskProjektu1Click_99;
    end;

    Ord('S') : begin
      if Shift=[ssCtrl] then
        Uloz1Click_99;
    end;

    Ord('V') : begin
      if [ssCtrl, ssShift]<=Shift then begin
{        if AsponJedenProjekt then} begin
          if CisloCimJede_99<>-TypClipboard then begin

{            for i := 0 to JakobyClipboard.Count-1 do begin
              AC := JakobyClipboard.Items[i];
              AC.Kresli(PaintBox1.Canvas, KoefZvetseni, 2, PocAmi);
            end; }
            ZobrazAbsList(JakobyClipboard, Myska);
          end;
          DelejVlozit1Click_99;
        end;
      end;
    end;

    Ord('X') : begin
      if [ssCtrl, ssShift]<=Shift then begin
        if Vyjmout1.Enabled then
//        if AsponJedenProjekt then
            Vyjmout1Click_99;
      end;
    end;

    Ord('Y') : begin
      if Shift=[ssCtrl] then begin
//        if Redo1.Enabled then
//          if AsponJedenProjekt then
//            Redo1Click(Self);
      end;
    end;

    Ord('Z') : begin
      if Shift=[ssCtrl] then begin
//        if Undo1.Enabled then
//          if AsponJedenProjekt then
//            Undo1Click(Self);
      end;
    end;
  end; *)
end;

Procedure CopyDoClipboard(BControl : TControl); // AControl : TControl);
var
  AForm : TControl;
  AControl : TControl;
begin
  AControl := BControl;
  Try
    AForm := DejForm(BControl);
    if AForm is TForm then AControl := TForm(AForm).ActiveControl;
    if AControl is TAdvStringGrid then
      (AControl as TAdvStringGrid).NormalEdit.CopyToClipboard;

    if AControl is TCustomEdit then
      (AControl as TCustomEdit).CopyToClipboard;

    if AControl is TCustomCombobox then begin
      Clipboard.AsText := (AControl as TCustomCombobox).SelText;

{      EditDummy := TCustomEdit.Create(AForm);
      EditDummy.Parent := AForm;
      Try
        EditDummy.Text := (AControl as TCustomCombobox).SelText;
        EditDummy.SelectAll;
        EditDummy.CopyToClipboard;
      finally
        EditDummy.Free;
      end; }
    end;
  except

  end;
end;

Procedure CutDoClipboard(BControl : TControl); // AControl : TControl);
var
  AForm : TControl;
  AControl : TControl;
begin
  AControl := BControl;
  Try
    AForm := DejForm(BControl);
    if AForm is TForm then AControl := TForm(AForm).ActiveControl;
    If AControl is TAdvStringGrid then
      (AControl as TAdvStringGrid).NormalEdit.CutToClipboard;

    if AControl is TCustomEdit then
      (AControl as TCustomEdit).CutToClipboard;

    if AControl is TCustomCombobox then begin
      Clipboard.AsText := (AControl as TCustomCombobox).SelText;
      (AControl as TCustomCombobox).SelText := '';

{      EditDummy := TCustomEdit.Create(AForm);
      EditDummy.Parent := AForm;
      Try
        EditDummy.Text := (AControl as TCustomCombobox).SelText;
        EditDummy.SelectAll;
        EditDummy.CopyToClipboard;
        (AControl as TCustomCombobox).SelText := '';
      finally
        EditDummy.Free;
      end; }
    end;
  except

  end;
end;

Procedure CopyZClipboard(BControl : TControl); // AControl : TControl);
var
  AForm : TControl;
  AControl : TControl;
begin
  AControl := BControl;
  Try
    AForm := DejForm(BControl);
    if AForm is TForm then AControl := TForm(AForm).ActiveControl;

    if AControl is TAdvStringGrid then begin
      (AControl as TAdvStringGrid).NormalEdit.PasteFromClipboard;
  //    StringZClipboard := (AControl as TAdvStringGrid).NormalEdit.Text;
    end;

    if AControl is TCustomEdit then begin
      (AControl as TCustomEdit).PasteFromClipboard;
  //    StringZClipboard := (AControl as TCustomEdit).Text;
    end;
    if AControl is TCustomCombobox then begin
      if Clipboard.HasFormat(CF_TEXT) then
        (AControl as TCustomCombobox).SelText := Clipboard.AsText

{      EditDummy := TCustomEdit.Create(AForm);
//      EditDummy.ParentWindow := AForm.Handle;
      EditDummy.Parent := AForm;
      Try
        EditDummy.PasteFromClipboard;
        EditDummy.SelectAll;
        ASelStart := (AControl as TCustomCombobox).SelStart;
        (AControl as TCustomCombobox).SelText := EditDummy.Text;
  //    (AControl as TCustomCombobox).SelectAll;
  //    StringZClipboard := (AControl as TCustomCombobox).SelText;
  //    (AControl as TCustomCombobox).SelStart := ASelStart;
  //    (AControl as TCustomCombobox).SelLength := EditDummy.SelLength;
      finally
        EditDummy.Free;
      end; }
    end;
  except

  end;
end;

Procedure DelejShiftDelete(BControl : TControl);
var
  ASelStart : integer;
  AForm : TControl;
  AControl : TControl;
begin
  AControl := BControl;
  Try
    AForm := DejForm(BControl);
    if AForm is TForm then AControl := TForm(AForm).ActiveControl;
    if AControl is TAdvStringGrid then begin
      if (AControl as TAdvStringGrid).NormalEdit.SelLength=0 then
        (AControl as TAdvStringGrid).NormalEdit.SelLength := 1;
      (AControl as TAdvStringGrid).NormalEdit.SelText := '';
  //    StringZClipboard := (AControl as TAdvStringGrid).NormalEdit.Text;
    end;

    if AControl is TCustomEdit then begin
      if (AControl as TCustomEdit).SelLength=0 then
        (AControl as TCustomEdit).SelLength := 1;
      (AControl as TCustomEdit).SelText := '';
  //    StringZClipboard := (AControl as TAdvStringGrid).NormalEdit.Text;
    end;

    if AControl is TCustomCombobox then begin
      if (AControl as TCustomCombobox).SelLength=0 then
        (AControl as TCustomCombobox).SelLength := 1;
      (AControl as TCustomCombobox).SelText := '';
    end;
  {    EditDummy.Text := '';
      EditDummy.PasteFromClipboard;
      EditDummy.SelectAll;
      ASelStart := (AControl as TCustomCombobox).SelStart;
      (AControl as TCustomCombobox).SelText := EditDummy.Text;
      (AControl as TCustomCombobox).SelectAll;
      StringZClipboard := (AControl as TCustomCombobox).SelText;
      (AControl as TCustomCombobox).SelStart := ASelStart;
      (AControl as TCustomCombobox).SelLength := EditDummy.SelLength;     }
  except

  end;
end;

Procedure TFrForm99.VKESCAPE_99;
begin
  VidPanel1_99(FALSE);
  VidPanel3_99(FALSE);
  if AForm_A is TFormA then
    (AForm_A as TFormA).AEscape;

  if AForm_A is TForm_Rb1 then begin
    (AForm_A as TForm_Rb1).UnCheckAllAmiActions;
    (AForm_A as TForm_Rb1).ActCliItInvisible;
  end;
  JakobyPageControlChange;
end;

procedure TFrForm99.FrFormKeyDown(Sender: TObject; var Key: Word;
          Shift: TShiftState);
var
  i : integer;
  AC : TAmiClass;
  AForm : TComponent;
begin
  ShDnMovePB := [ssShift]=Shift;
  JeCtrl := ssCtrl in Shift;
  JeShift := ssShift in Shift;
  JeAlt := ssAlt in Shift;
  case Key of
    VK_ESCAPE : VKESCAPE_99;

{    begin
      VidPanel1_99(FALSE);
      VidPanel3_99(FALSE);
      if AForm_A is TFormA then
        (AForm_A as TFormA).AEscape;

      if AForm_A is TForm_Rb1 then begin
        (AForm_A as TForm_Rb1).UnCheckAllAmiActions;
        (AForm_A as TForm_Rb1).ActCliItInvisible;
      end;
      JakobyPageControlChange;
    end; }

    VK_DELETE : begin // delete
      if jeShift then begin
        DelejShiftDelete(Self);
      end else begin
        VidPanel1_99(FALSE);
        VidPanel3_99(FALSE);
        DelejDelete_99;
      end;
      Key := 0;
    end;
{    13 : begin
      if ActiveControl is TComboBox then begin
        with ActiveControl as TComboBox do
          OnChange(ActiveControl);
      end;

      TryUpdateStrigGrids;
    end;      }


    VK_PRIOR ,VK_NEXT : begin  // pgup, pgdown
      if (ScrollBar1.Visible AND ScrollBar1.Visible) then begin
        AForm := Owner;
        if AForm is TForm then
          with (AForm as TForm) do begin
            if ssCtrl in Shift then begin
              if ActiveControl=ScrollBar2 then
                ScrollBar1.SetFocus
            end else begin
              if ActiveControl=ScrollBar1 then
                ScrollBar2.SetFocus;
            end;
          end;
      end else begin
        if ssCtrl in Shift then begin
          with ScrollBar1 do begin
            if Key=VK_PRIOR then Position := Position-LargeChange
                            else Position := Position+LargeChange;
          end;
        end else begin
          with ScrollBar2 do begin
            if Key=VK_PRIOR then Position := Position-LargeChange
                            else Position := Position+LargeChange;
          end;
        end;
      end;
    end;

    VK_UP, VK_DOWN : begin     // sipka nahoru, dolu
      if Shift=[] then begin
        if (ScrollBar1.Visible AND ScrollBar1.Visible) then begin
          AForm := Owner;
          if AForm is TForm then
            with (AForm as TForm) do begin
              if (ActiveControl=ScrollBar1){ OR (ActiveControl=PaintBox1)} then
                ScrollBar2.SetFocus;
            end;
        end else begin
          with ScrollBar2 do begin
            if Key=VK_UP then Position := Position-SmallChange
                         else Position := Position+SmallChange;
          end;
        end;
      end;
      if Shift=[ssAlt] then begin
        if Key=VK_UP then PosunSmer_99(4);
        if Key=VK_DOWN then PosunSmer_99(3);
      end;
    end;

    VK_LEFT ,VK_RIGHT : begin  // sipka vlevo, vpravo
      if Shift=[] then begin
        if (ScrollBar1.Visible AND ScrollBar1.Visible) then begin
          AForm := Owner;
          if AForm is TForm then
            with (AForm as TForm) do begin
              if (ActiveControl=ScrollBar1){ OR (ActiveControl=PaintBox1)} then
                ScrollBar1.SetFocus;
            end;
        end else begin
          with ScrollBar1 do begin
            if Key=VK_LEFT then Position := Position-SmallChange
                           else Position := Position+SmallChange;
          end;
        end;
      end;
      if Shift=[ssAlt] then begin
        if Key=VK_LEFT then PosunSmer_99(1);
        if Key=VK_RIGHT then PosunSmer_99(2);
      end;
    end;

    Ord('A') : begin
//      if [ssCtrl, ssShift]<=Shift then
      if jeCtrl then
        VybratVse1Click_99;
      if Shift=[ssAlt] then begin
        if AForm_A is TFormA then
          if (AForm_A as TFormA).ToolB97Trub2.Enabled then
            (AForm_A as TFormA).ToolB97Trub2.Click;
        if AForm_A is TForm_Rb1 then begin
          if (AForm_A as TForm_Rb1).A_Tru_1.Enabled then
            (AForm_A as TForm_Rb1).A_Tru_1.Execute;
          if (AForm_A as TForm_Rb1).A_Trv_1.Enabled then
            (AForm_A as TForm_Rb1).A_Trv_1.Execute;
          if (AForm_A as TForm_Rb1).A_Tru_1.Enabled then
            (AForm_A as TForm_Rb1).A_Tru_1.Checked := TRUE;
        end;
      end;
    end;

    Ord('C') : begin
      if jeCtrl then begin
        if jeShift then begin
          CopyDoClipboard(Self);
        end else begin
          DelejVlozdoClipboardu_99;
        end;
        Key := 0;
      end;
    end;

    Ord('D') : begin
      if Shift=[ssAlt] then begin
        if AForm_A is TFormA then
          if (AForm_A as TFormA).ToolB97Trub3.Enabled then
            (AForm_A as TFormA).ToolB97Trub3.Click;
        if AForm_A is TForm_Rb1 then begin
          if (AForm_A as TForm_Rb1).A_Tru_2.Enabled then
            (AForm_A as TForm_Rb1).A_Tru_2.Execute;
          if (AForm_A as TForm_Rb1).A_Trv_2.Enabled then
            (AForm_A as TForm_Rb1).A_Trv_2.Execute;
          if (AForm_A as TForm_Rb1).A_Tru_2.Enabled then
            (AForm_A as TForm_Rb1).A_Tru_2.Checked := TRUE;
        end;
      end;
    end;

    Ord('N') : begin
      if Shift=[ssCtrl] then
        Novy1Click_99;
    end;

    Ord('O') : begin
      if Shift=[ssCtrl] then
        Precti1Click_99;
    end;

    Ord('P') : begin
      if Shift=[ssCtrl] then
        TiskProjektu1Click_99;
    end;

    Ord('S') : begin
      if Shift=[ssCtrl] then
        Uloz1Click_99;
    end;

    Ord('V') : begin
      if jeCtrl then begin
        if jeShift then begin
          CopyZClipboard(Self);
        end else begin
{          if AsponJedenProjekt then} begin
            if CisloCimJede_99<>-TypClipboard then begin
              ZobrazAbsList(JakobyClipboard, Myska);
            end;
            DelejVlozit1Click_99;
          end;
        end;
        Key := 0;
      end;
    end;

    Ord('W') : begin
      if Shift=[ssAlt] then begin
        if AForm_A is TFormA then
          if (AForm_A as TFormA).ToolB97Fit2.Enabled then
            (AForm_A as TFormA).ToolB97Fit2.Click;
        if AForm_A is TForm_Rb1 then begin
          if (AForm_A as TForm_Rb1).A_Tru_2.Enabled then
            (AForm_A as TForm_Rb1).A_Tru_2.Execute;
          if (AForm_A as TForm_Rb1).A_Trv_2.Enabled then
            (AForm_A as TForm_Rb1).A_Trv_2.Execute;
        end;
      end;
    end;

    Ord('X') : begin
      if jeCtrl then begin
        if jeShift then begin
          CutDoClipboard(Self);
        end else begin
//          if Vyjmout1.Enabled then
//            if AsponJedenProjekt then
              Vyjmout1Click_99;
        end;
        Key := 0;
      end;
    end;

    Ord('Y') : begin
      if Shift=[ssCtrl] then begin
//        if Redo1.Enabled then
//          if AsponJedenProjekt then
            Redo1Click_99;
      end;
    end;

    Ord('Z') : begin
      if Shift=[ssCtrl] then begin
//        if Undo1.Enabled then
//          if AsponJedenProjekt then
            Undo1Click_99;
      end;
    end;
  end;
end;

procedure TFrForm99.FrFormKeyPress(Sender: TObject; var Key: Char);
begin
{  Case Key of
    #1 : Key := #0;  // ctrl A
    #3 : Key := #0;  // ctrl C
    #22 : Key := #0; // ctrl V
    #24 : Key := #0; // ctrl X
  end; }
  AAFormKeyPress(Key);
end;

procedure TFrForm99.FrFormKeyUp(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  ShDnMovePB := [ssShift]=Shift;
end;

procedure TFrForm99.JakobyPageControlChange;
begin
  if CisloCimJede_99<0 then
    KresliSymbol(PaintBox1.Canvas,Myska,[], True, FALSE);

  CisloCimJede_99 := 0;

//  Application.CancelHint;
//  PageControl1.Hint := PageControl1.ActivePage.Hint;

  PaintBox1.Cursor := crDefault;

  DelejVyberKurzor_99(0);
end;

procedure TFrForm99.RozdelitStropy1Click_99; //(jak : boolean);
begin
  CisloCimJede_99 := 0;

  with ATopChlad do begin
    OznList.Clear;
    VybList.Clear;
    KontrList.Clear;
    DelejOznAmi_99(NIL);
    ZobrazitKontrolu_99(FALSE, FALSE);
  //  PageControl1Change(Self);

  end;
  if BDelejRozdelStropy then begin
    DelejVyberKurzor_99(211);
  end else begin
    DelejVyberKurzor_99(crDefault);
  end;
  DelejInvalidu_99;
end;

procedure TFrForm99.ParProjektu1Click_99;
var
  UdelalInvalidu : boolean;

Procedure RozdelTrubkyPokoji;
var
  i : integer;
  AC : TAmiClass;
begin
  DelejUmozniUNDO_99;
  DelejUmozniUNDQ_99(histInsert, histRozdelTrubkyPokoji, NIL, NIL);

  with ATopChlad do begin;
    for i := 0 to AmiLispik.Count-1 do begin
      AC := AmiLispik[i];
      if AC is TAmiPokoj then
        AC.PraveVlozeny := TRUE;
    end;
    BJeOchlazovani := TRUE;
    RozdelTrubPokoji;
    OznList.Clear;
    VybList.Clear;
    DelejInvalidu_99;
    UdelalInvalidu := TRUE;
  end;
  DelejPrvniREDQ_99(histInsert, histRozdelTrubkyPokoji, NIL, NIL);
end;

var
  i : integer;
  AC : TAmiClass;
  Zmena : boolean;
  ZmenaCooling : boolean;
  BPokrytiPokoju : boolean;
  JeOchlOhrevOld : boolean;
  JeOchlOhrev : boolean;
begin
  with ATopChlad do begin;
    NemuzeUlozit := TRUE;
    if PokrytiPokojuC<=0 then
      PokrytiPokojuC := 1;
    if PokrytiPokojuH<=0 then
      PokrytiPokojuH := 1;

  //  FormG.GroupBox8.Enabled := ZjistiJednotrubku(AmiLispik)=0;
  {//  FormG.CheckBoxOtopnaSoustava.Enabled := FormG.GroupBox8.Enabled;
    FormG.CheckBoxOtopnaSoustava.Enabled := FormG.GroupBox8.Enabled;
    FormG.CheckBoxOtopnaSoustava.Checked := Jednotrubka; }
  {  FormG.RadioButtonJednoTrubka.Enabled := FormG.GroupBox8.Enabled;
    FormG.RadioButtonDvouTrubka.Enabled := FormG.GroupBox8.Enabled;
    if JednoTrubka then FormG.RadioButtonJednoTrubka.Checked := TRUE
                   else FormG.RadioButtonDvouTrubka.Checked := TRUE;  }

    with FormG do begin
      RadioButtonBezOchlH.Enabled := ZjistiJednotrubku(AmiLispik)=0;
      RadioButtonSOchlH.Enabled := RadioButtonBezOchlH.Enabled;
    //  FormG.LabelHSOchl.Visible := NOT FormG.RadioButtonSOchlH.Visible;


      with NastaveniTopChlad do begin
        ATeplotaTamH := TeplotaExterni(TeplotaTamH);
        ATeplotaZpetH := TeplotaExterni(TeplotaZpetH);
        AdPZdrojeH := dPZdrojeH;
        AobjemZdrojeH := objemZdrojeH;
        ATlakovySpadH := TlakovySpadH;
        AKoncGlykolu_procH := KoncGlykolu_procH;
        ATypMediaH := TypMediaH;
        AdPTermostVentiluH := dPTermostVentiluH;
        AdPBalancnihoVentiluH := dPBalancnihoVentiluH;
        AdPZpetSroubeniH := dPZpetSroubeniH;
        AdPRegulacnihoVentiluH := dPRegulacnihoVentiluH;
        AdispTlakCerpadlaH := dispTlakCerpadlaH;
        AKorekce1dP_RoH := Korekce1dP_RoH;
        ATeplotaNevytapeneMistnosti := TeplotaExterni(TeplotaNevytapeneMistnosti);
        APokrytiPokojuH := PokrytiPokojuH;

        AMinimalniDiamTrubkyH := MinimalniDiamTrubkyH;
        AMinimalniDNTrubkyH := MinimalniDNTrubkyH;
        AKoefAlphaH := KoefAlphaH;
        AKoefDPCH := KoefDPCH;
        AMinAutoritaH := MinAutoritaH;

        ATypVypoctuH := TypVypoctuH;
        ABAbsTlakovySpadH := BAbsTlakovySpadH;
        AMaxRychlostvTrubceH := MaxRychlostvTrubceH;
        ARychlostvTrubceH := RychlostvTrubceH;
        ABAbsRychlostvTrubceH := BAbsRychlostvTrubceH;
        ABPocitat_sKoefDPCH := BPocitat_sKoefDPCH;

        AJeOchlazovani := BJeOchlazovani;

        ATeplotaTamC := TeplotaExterni(TeplotaTamC);
        ATeplotaZpetC := TeplotaExterni(TeplotaZpetC);
        AdPZdrojeC := dPZdrojeC;
        AobjemZdrojeC := objemZdrojeC;
        ATlakovySpadC := TlakovySpadC;
        AKoncGlykolu_procC := KoncGlykolu_procC;
        ATypMediaC := TypMediaC;
        AdispTlakCerpadlaC := dispTlakCerpadlaC;
        ATeplotaNechlazeneMistnosti := TeplotaExterni(TeplotaNechlazeneMistnosti);

        AdPTermostVentiluC := dPTermostVentiluC;
        AdPBalancnihoVentiluC := dPBalancnihoVentiluC;
        AdPZpetSroubeniC := dPZpetSroubeniC;
        AdPRegulacnihoVentiluC := dPRegulacnihoVentiluC;

        AMinimalniDiamTrubkyC := MinimalniDiamTrubkyC;
        AMinimalniDNTrubkyC := MinimalniDNTrubkyC;
        AKoefDPCC := KoefDPCC;
        AMinAutoritaC := MinAutoritaC;

        APokrytiPokojuC := PokrytiPokojuC;

        ATypVypoctuC := TypVypoctuC;
        ABAbsTlakovySpadC := BAbsTlakovySpadC;
        AMaxRychlostvTrubceC := MaxRychlostvTrubceC;
        ARychlostvTrubceC := RychlostvTrubceC;
        ABAbsRychlostvTrubceC := BAbsRychlostvTrubceC;
        ABPocitat_sKoefDPCC := BPocitat_sKoefDPCC;
        AJeOhrev := BJeOhrev;


        ACooling := BCooling;
        if BCooling then JeOchlOhrevOld := BJeOhrev
                    else JeOchlOhrevOld := BJeOchlazovani;
        AJeOchlOhrevOld := JeOchlOhrevOld;

        OTeplotaTamH := TeplotaTamH;
        OTeplotaZpetH := TeplotaZpetH;
        OTeplotaNevytapeneMistnosti := TeplotaNevytapeneMistnosti;

        OTeplotaTamC := TeplotaTamC;
        OTeplotaZpetC := TeplotaZpetC;
        OTeplotaNechlazeneMistnosti := TeplotaNechlazeneMistnosti;

        OdPTermostVentiluC := dPTermostVentiluC;
        OdPBalancnihoVentiluC := dPBalancnihoVentiluC;
        OdPZpetSroubeniC := dPZpetSroubeniC;
        OdPRegulacnihoVentiluC := dPRegulacnihoVentiluC;

      end;
    end;  // with FormG

    if (FormG.ShowModal=FormG.BitBtn1.ModalResult) AND
        NOT FormG.Chypka then begin
      with NastaveniTopChlad do begin
        Zmena := BCooling<>FormG.ACooling;
        ZmenaCooling := Zmena;

        DelejUmozniUNDQ_TChl(histPar, histZmenPar, NIL, NIL);          //?????
        UdelalInvalidu := FALSE;

        BCooling := FormG.ACooling;
        if ZmenaCooling then
          BGlobCooling := BCooling;
        if BCooling then Mod_Chlazeni_x_Topeni := 1
                    else Mod_Chlazeni_x_Topeni := 0;
        BMod_Chlazeni_x_Topeni := Mod_Chlazeni_x_Topeni;  // zatim

        if NOT Zmena then begin
          if BCooling then begin
            Zmena :=
              (TeplotaExterni(TeplotaTamC)<>FormG.ATeplotaTamC) OR
              (TeplotaExterni(TeplotaZpetC)<>FormG.ATeplotaZpetC) OR
              (dPZdrojeC<>FormG.AdPZdrojeC) OR
              (objemZdrojeC<>FormG.AobjemZdrojeC) OR
              (dPTermostVentiluC<>FormG.AdPTermostVentiluC) OR
              (dPBalancnihoVentiluC<>FormG.AdPBalancnihoVentiluC) OR
              (dPZpetSroubeniC<>FormG.AdPZpetSroubeniC) OR
              (dPRegulacnihoVentiluC<>FormG.AdPRegulacnihoVentiluC) OR
              (MinAutoritaC<>FormG.AMinAutoritaC) OR
              (dispTlakCerpadlaC<>FormG.AdispTlakCerpadlaC) OR
    //          (Korekce1dP_Ro<>FormG.AKorekce1dP_Ro) OR
              (TeplotaExterni(TeplotaNechlazeneMistnosti)<>FormG.ATeplotaNechlazeneMistnosti) OR
              (MinimalniDiamTrubkyC<>FormG.AMinimalniDiamTrubkyC) OR
              (MinimalniDNTrubkyC<>FormG.AMinimalniDNTrubkyC) OR
              (TypVypoctuC<>FormG.ATypVypoctuC) OR
              (TlakovySpadC<>FormG.ATlakovySpadC) OR
              (BAbsTlakovySpadC<>FormG.ABAbsTlakovySpadC) OR
              (BAbsRychlostvTrubceC<>FormG.ABAbsRychlostvTrubceC) OR
              (BPocitat_sKoefDPCC<>FormG.ABPocitat_sKoefDPCC) OR
              (MaxRychlostvTrubceC<>FormG.AMaxRychlostvTrubceC) OR
              (RychlostvTrubceC<>FormG.ARychlostvTrubceC) OR
              (TypMediaC<>FormG.ATypMediaC) OR
              (KoncGlykolu_procC<>FormG.AKoncGlykolu_procC) OR
              (KoefDPCC<>FormG.AKoefDPCC);
          end else begin
            Zmena :=
              (TeplotaExterni(TeplotaTamH)<>FormG.ATeplotaTamH) OR
              (TeplotaExterni(TeplotaZpetH)<>FormG.ATeplotaZpetH) OR
              (dPZdrojeH<>FormG.AdPZdrojeH) OR
              (objemZdrojeH<>FormG.AobjemZdrojeH) OR
              (dPTermostVentiluH<>FormG.AdPTermostVentiluH) OR
              (dPBalancnihoVentiluH<>FormG.AdPBalancnihoVentiluH) OR
              (dPZpetSroubeniH<>FormG.AdPZpetSroubeniH) OR
              (dPRegulacnihoVentiluH<>FormG.AdPRegulacnihoVentiluH) OR
              (MinAutoritaH<>FormG.AMinAutoritaH) OR
              (dispTlakCerpadlaH<>FormG.AdispTlakCerpadlaH) OR
              (Korekce1dP_RoH<>FormG.AKorekce1dP_RoH) OR
              (TeplotaExterni(TeplotaNevytapeneMistnosti)<>FormG.ATeplotaNevytapeneMistnosti) OR
              (MinimalniDiamTrubkyH<>FormG.AMinimalniDiamTrubkyH) OR
              (MinimalniDNTrubkyH<>FormG.AMinimalniDNTrubkyH) OR
              (TypVypoctuH<>FormG.ATypVypoctuH) OR
              (TlakovySpadH<>FormG.ATlakovySpadH) OR
              (BAbsTlakovySpadH<>FormG.ABAbsTlakovySpadH) OR
              (BAbsRychlostvTrubceH<>FormG.ABAbsRychlostvTrubceH) OR
              (BPocitat_sKoefDPCH<>FormG.ABPocitat_sKoefDPCH) OR
              (MaxRychlostvTrubceH<>FormG.AMaxRychlostvTrubceH) OR
              (RychlostvTrubceH<>FormG.ARychlostvTrubceH) OR
              (KoefAlphaH<>FormG.AKoefAlphaH) OR
              (TypMediaH<>FormG.ATypMediaH) OR
              (KoncGlykolu_procH<>FormG.AKoncGlykolu_procH) OR
              (KoefDPCH<>FormG.AKoefDPCH);
          end;
        end;
      end;
        //      (FormG.RadioButtonJednoTrubka.Checked<>Jednotrubka);
  //      (FormG.CheckBoxOtopnaSoustava.Checked<>Jednotrubka);

  //      (PokrytiPokoju<>FormG.APokrytiPokoju);
      if NastaveniTopChlad.BCooling then begin
        BPokrytiPokoju := FormG.CheckBoxPokrytiPokojuC.Checked;
        PokrytiPokojuC := FormG.APokrytiPokojuC;
        if BPokrytiPokoju then begin
          for i := 0 to AmiLispik.Count-1 do begin
            AC := AmiLispik[i];
            if AC is TAmiPokoj then
              with AC as TAmiPokoj do begin
                Zmena := Zmena OR NOT (Pokryti=PokrytiPokojuC);
                Pokryti := PokrytiPokojuC;
              end;
          end;
          DelejTabulky_99;
        end;
      end else begin
        BPokrytiPokoju := FormG.CheckBoxPokrytiPokojuH.Checked;
        PokrytiPokojuH := FormG.APokrytiPokojuH;
        if BPokrytiPokoju then begin
          for i := 0 to AmiLispik.Count-1 do begin
            AC := AmiLispik[i];
            if AC is TAmiPokoj then
              with AC as TAmiPokoj do begin
                Zmena := Zmena OR NOT (Pokryti=PokrytiPokojuH);
                Pokryti := PokrytiPokojuH;
              end;
          end;
          DelejTabulky_99;
        end;
      end;

      if ZmenaCooling then begin
        for i := 0 to AmiLispik.Count-1 do begin
          AC := AmiLispik[i];
          if AC is TAmiOTChladic1 then
            with AC as TAmiOTChladic1 do begin
              ClCmCxCy;
            end;
        end;

        if (AForm_A is TFormA) AND (AForm99=NIL) then
          AForm_A.Caption := DejZakladniCaption+'  '+ATopChlad.DejIMIIMICaption;
        if AForm_A is TForm_Rb1 then
          TForm_Rb1(AForm_A).Ribbon1.DocumentName := DejIMIIMICaption;
        if AForm99<>NIL then
          AForm99.Caption := DejIMIIMICaption;

      end;

      if Zmena then begin


//        DelejZakazUNDO_99;
//        DelejZakazREDO_99;
        DelejPrvniREDQ_TChl(histPar, histZmenPar, NIL, NIL);          //?????
        ZmenaProjektu := TRUE;

        PrycsVypoctem;
      end else begin
        DelejVratKrokUNDQ_TChl;
      end;
      with NastaveniTopChlad do begin
        if HesCos=0 then
          BCoolingProj := BCooling;

        Cooling_x_Heating_99(BCooling);

        if BCooling then begin
          TeplotaTamC := TeplotaInterni(FormG.ATeplotaTamC);
          TeplotaZpetC := TeplotaInterni(FormG.ATeplotaZpetC);
          dPZdrojeC := FormG.AdPZdrojeC;
          objemZdrojeC := FormG.AobjemZdrojeC;
          dPTermostVentiluC := FormG.AdPTermostVentiluC;
          dPBalancnihoVentiluC := FormG.AdPBalancnihoVentiluC;
          dPZpetSroubeniC := FormG.AdPZpetSroubeniC;
          dPRegulacnihoVentiluC := FormG.AdPRegulacnihoVentiluC;
          dispTlakCerpadlaC := FormG.AdispTlakCerpadlaC;
    //      Korekce1dP_Ro := FormG.AKorekce1dP_Ro;
          TeplotaNechlazeneMistnosti := TeplotaInterni(FormG.ATeplotaNechlazeneMistnosti);
          PokrytiPokojuC := FormG.APokrytiPokojuC;
          MinimalniDiamTrubkyC := FormG.AMinimalniDiamTrubkyC;
          MinimalniDNTrubkyC := FormG.AMinimalniDNTrubkyC;
          MinAutoritaC := FormG.AMinAutoritaC;

          TypVypoctuC := FormG.ATypVypoctuC;
          TlakovySpadC := FormG.ATlakovySpadC;
          BAbsTlakovySpadC := FormG.ABAbsTlakovySpadC;
          MaxRychlostvTrubceC := FormG.AMaxRychlostvTrubceC;
          RychlostvTrubceC := FormG.ARychlostvTrubceC;
          BAbsRychlostvTrubceC := FormG.ABAbsRychlostvTrubceC;
          KoefDPCC := FormG.AKoefDPCC;
          BPocitat_sKoefDPCC := FormG.ABPocitat_sKoefDPCC;
          KoncGlykolu_procC := FormG.AKoncGlykolu_procC;
          TypMediaC := FormG.ATypMediaC;

          DeltaTC := TeplotaZpetC-TeplotaTamC;
          TeplotaStredC := Round((TeplotaTamC+TeplotaZpetC)*0.5);
        end else begin   // if BCooling
          TeplotaTamH := TeplotaInterni(FormG.ATeplotaTamH);
          TeplotaZpetH := TeplotaInterni(FormG.ATeplotaZpetH);
          dPZdrojeH := FormG.AdPZdrojeH;
          objemZdrojeH := FormG.AobjemZdrojeH;
          dPTermostVentiluH := FormG.AdPTermostVentiluH;
          dPBalancnihoVentiluH := FormG.AdPBalancnihoVentiluH;
          dPZpetSroubeniH := FormG.AdPZpetSroubeniH;
          dPRegulacnihoVentiluH := FormG.AdPRegulacnihoVentiluH;
          dispTlakCerpadlaH := FormG.AdispTlakCerpadlaH;
          Korekce1dP_RoH := FormG.AKorekce1dP_RoH;
          TeplotaNevytapeneMistnosti := TeplotaInterni(FormG.ATeplotaNevytapeneMistnosti);
          PokrytiPokojuH := FormG.APokrytiPokojuH;
          MinimalniDiamTrubkyH := FormG.AMinimalniDiamTrubkyH;
          MinimalniDNTrubkyH := FormG.AMinimalniDNTrubkyH;
          MinAutoritaH := FormG.AMinAutoritaH;

          TypVypoctuH := FormG.ATypVypoctuH;
          TlakovySpadH := FormG.ATlakovySpadH;
          BAbsTlakovySpadH := FormG.ABAbsTlakovySpadH;
          MaxRychlostvTrubceH := FormG.AMaxRychlostvTrubceH;
          RychlostvTrubceH := FormG.ARychlostvTrubceH;
          BAbsRychlostvTrubceH := FormG.ABAbsRychlostvTrubceH;
          KoefAlphaH := FormG.AKoefAlphaH;
          KoefDPCH := FormG.AKoefDPCH;
          BPocitat_sKoefDPCH := FormG.ABPocitat_sKoefDPCH;
          KoncGlykolu_procH := FormG.AKoncGlykolu_procH;
          TypMediaH := FormG.ATypMediaH;

          DeltaTH := TeplotaTamH-TeplotaZpetH;
          TeplotaStredH := Round((TeplotaTamH+TeplotaZpetH)*0.5);
        end;
    //    Parametry_Latky(TeplotaTam, TeplotaZpet, Ro_Tam, Ro_Zpet, Ro_M, dp_ro,
    //                    Ny_M, Ny_Tam, Ny_Zpet);

    //    Jednotrubka := FormG.CheckBoxOtopnaSoustava.Checked;
    //    Jednotrubka := FormG.RadioButtonJednoTrubka.Checked;


        if ZmenaCooling then begin
          if BCooling then JeOchlOhrev := FormG.AJeOhrev
                      else JeOchlOhrev := FormG.AJeOchlazovani;
          if JeOchlOhrev AND NOT JeOchlOhrevOld then
            RozdelTrubkyPokoji;

          if BCooling then BJeOhrev := FormG.AJeOhrev
                      else BJeOchlazovani := FormG.AJeOchlazovani;
          Caption := DejIMIIMICaption;
        end else begin
          if BCooling then begin
            if FormG.AJeOhrev<>BJeOhrev then begin
              if FormG.AJeOhrev then
                RozdelTrubkyPokoji;
              BJeOhrev := FormG.AJeOhrev;
              Caption := DejIMIIMICaption;
            end;

          end else begin
            if FormG.AJeOchlazovani<>BJeOchlazovani then begin
              if FormG.AJeOchlazovani then
                RozdelTrubkyPokoji;
              BJeOchlazovani := FormG.AJeOchlazovani;
              Caption := DejIMIIMICaption;
            end;
          end;
        end;

      end;
      TlacitkaPriJednotrubce_99;
      UmozniSchovatListy_99;

  //    if BJeOchlazovani then begin

  //    end;
      SchovejFormBV_99;
      SchovejFormF_99;
      if Zmena then
        MaVymazatVypocet := TRUE;
      DelejVymazVypocet_99;
      if Zmena then
  //    if ZmenaCooling AND NOT UdelalInvalidu then
        DelejInvalidu_99;
      VypocetHotov := FALSE;
      Caption := DejIMIIMICaption;
    end;
    NemuzeUlozit := FALSE;

    NastaveniTopChlad.BPocitat_sKoefDPCH := FALSE;
    NastaveniTopChlad.BPocitat_sKoefDPCC := FALSE;
  end;
end;

procedure TFrForm99.TiskObrazovky1Click_99;
begin
  with FormV do begin
    DelejSpocRealBodik(PocAmi, Point(0, 0), KoefZvetseni, AVyrezTiskuB1);
    DelejSpocRealBodik(PocAmi ,Point(PaintBox1.Width,PaintBox1.Height),
                               KoefZvetseni, AVyrezTiskuB2);
    ZobrCernobile := AZobrCernobile;
    ABKreslitSpoje := BKreslitSpoje;
    PripravPreview(ATopChlad.AmiLispik);
    ShowModal;
  end;
  ZobrCernoBile := 0;
end;

procedure TFrForm99.OznacitStoupacku1Click_99;
begin
  with ATopChlad do begin
    if AktAmiOzn<>NIL then begin
      if VybList.IndexOf(AktAmiOzn)<0 then
        VybList.Add(AktAmiOzn);
    end;

    FormL.VList := VybList;
    FormL.AFrForm99 := Self;
    FormL.ATopChlad := ATopChlad;
    FormL.Oznacil := FALSE;

    PripravUkazkuFormE(AmiLispik);
    ProtokolStrings.Clear;

    if FormL.ShowModal=FormL.BitBtn1.ModalResult then
      ZmenaProjektu := TRUE;

    if AktAmiOzn<>NIL then begin
      if VybList.IndexOf(AktAmiOzn)>=0 then
        VybList.Remove(AktAmiOzn);
    end;
    DelejTabulky_99;
    if FormL.Oznacil then
      DelejUkazatOznaceniVetvi_99(TRUE);
  //  DelejInvalidu_99;
  end;
end;

procedure TFrForm99.DelejFormN_99;
begin
  Try
    with FormN do begin
      with ATopChlad do begin
        Edit1.Text := PopisyEdit[1];
        Edit2.Text := PopisyEdit[2];
        Edit3.Text := PopisyEdit[3];
        Edit4.Text := PopisyEdit[4];
        Edit5.Text := PopisyEdit[5];
        Edit6.Text := PopisyEdit[6];
        Edit7.Text := PopisyEdit[7];
        Edit8.Text := PopisyEdit[8];
        Edit9.Text := PopisyEdit[9];
        Edit10.Text := PopisyEdit[10];
        Edit11.Text := PopisyEdit[11];
        Edit12.Text := PopisyEdit[12];
        Memo1.Lines.Text := PopisyMem1[1];
        Memo2.Lines.Text := PopisyMem1[2];
        Memo3.Lines.Text := PopisUzivatele;
      end;
    end;
  except

  end;
end;

procedure TFrForm99.DelejVyplnRazitko_99;
var
  APopisyEdit : Array[1..PocPopisuEdit] of String[25];
  APopisyMem1 : Array[1..PocPopisuMemo] of String;
  i : integer;
  AVMeritku : boolean;
  Zmena : boolean;
begin
  DelejFormN_99;
  Zmena := FALSE;
  with FormN do begin
    if ShowModal=mrYes then begin
      Zmena := AZmena;
      APopisyEdit[1] := Edit1.Text;
      APopisyEdit[2] := Edit2.Text;
      APopisyEdit[3] := Edit3.Text;
      APopisyEdit[4] := Edit4.Text;
      APopisyEdit[5] := Edit5.Text;
      APopisyEdit[6] := Edit6.Text;
      APopisyEdit[7] := Edit7.Text;
      APopisyEdit[8] := Edit8.Text;
      APopisyEdit[9] := Edit9.Text;
      APopisyEdit[10] := Edit10.Text;
      APopisyEdit[11] := Edit11.Text;
      APopisyEdit[12] := Edit12.Text;
      APopisyMem1[1] := Memo1.Lines.Text;
      APopisyMem1[2] := Memo2.Lines.Text;
      with ATopChlad do begin
        for i := 1 to 12 do begin
          Zmena := Zmena OR (PopisyEdit[i]<>APopisyEdit[i]);
          PopisyEdit[i] := APopisyEdit[i];
        end;
        for i := 1 to 2 do begin
          Zmena := Zmena OR (PopisyMem1[i]<>APopisyMem1[i]);
          PopisyMem1[i] := APopisyMem1[i];
        end;
        ZmenaProjektu := ZmenaProjektu OR Zmena;
        if (AmiLispik.DejRazitko<>NIL) AND Zmena then
          DelejInvalidu_99;
      end;
    end;
  end;
end;

procedure TFrForm99.ParPopisProjektu1Click_99;
begin
  DelejVyplnRazitko_99;
end;

Procedure TFrForm99.SpocitejPosScroll_99;
var
  i : integer;
  H : integer;
begin
(*  RightDock97.Left := ClientWidth-RightDock97.Width;
  H := BottomDock97.Height+BottomDockPanel.Height;
  if StatusBar1.Visible then begin
{    StatusBar1.Height := 17;
    StatusBar1.Top := Height-StatusBar1.Height;
    H := H+StatusBar1.Height;
    StatusBar1.Invalidate;
    StatusBar1.BringToFront; }
//    BottomDockPanel.Top := StatusBar1.Top-BottomDockPanel.Height;
  end;
  BottomDock97.Top := ClientHeight-H-1;
  HSplitter.Top := BottomDockPanel.Top-DifHSplitter;
  PravyO := RightDock97.Left-1;
  LevyO := LeftDock97.Width+1;
  HorniO := TopDock97.Height+1;
  DolniO := BottomDock97.Top-1;

//  BitBtn0.Top := HorniO;
//  BitBtn0.Left := LevyO;
  Panel1.Top := HorniO+VysMer+1;
  Panel1.Left := LevyO;         *)
//  ScrollBar1.Left := LevyO;
//  ScrollBar1.Width := PravyO-LevyO;
//  ScrollBar1.Top := DolniO-ScrollBar1.Height;
//  ScrollBar2.Top := HorniO;
//  ScrollBar2.Left := PravyO-ScrollBar2.Width;
//  ScrollBar2.Height := DolniO-HorniO-ScrollBar1.Height;

{  PaintBox1.UpdateBoundsRect(LevyO+SirMer, HorniO+VysMer,
                      PravyO-(LevyO+SirMer)-ScrollBar2.Width-1,
                      DolniO-(HorniO+VysMer)-ScrollBar1.Height-1); }
//  PaintBox1.SetBounds(LevyO+SirMer, HorniO+VysMer,
//                      PravyO-(LevyO+SirMer)-ScrollBar2.Width-1,
//                      DolniO-(HorniO+VysMer)-ScrollBar1.Height-1);
//  PanelPaint.SetBounds(LevyO+SirMer, HorniO+VysMer,
//                      PravyO-(LevyO+SirMer)-ScrollBar2.Width-1,
//                      DolniO-(HorniO+VysMer)-ScrollBar1.Height-1);
  BottomDockPanel.Update;
  BottomDockPanel.Invalidate;
  BottomDockPanel.Refresh;
  Invalidate;
end;

Procedure TFrForm99.AktAmiOznKurzor_99(X, Y : integer);
// meni kurzor, pokud je mozno menit vybrany objekt
// napr posunout koncovy bod trubky, otocit ventil, roztahnout mistnost...
var
  Nasel : boolean;
  CBUch : integer;
  Bod, B1, B2, PoiXY : TPoint;
  i, j, Pocet : integer;
  AC : TAmiClass;
begin
  Nasel := FALSE;
  DelejSpocRealBodik(PocAmi, Point(X,Y), KoefZvetseni, Bod);

  with ATopChlad do begin
    if AktAmiOzn<>NIL then begin
      if AktAmiOzn.NajdiUchBod(Bod, CBUch, B1, B2)>0 then begin
        if (AktAmiOzn is TAmiPokoj) OR
           (AktAmiOzn is TAmiStrop1) OR
           (AktAmiOzn is TAmiObdelnik) OR
           ((AktAmiOzn is TAmiOblouk) AND (AktAmiOzn.Typ=TypAmiOblouk1)) then begin
          Nasel := TRUE;
          Case CBUch of
            1..4 : DelejVyberKurzor_99(crSizeAll); // rohovy bod
            5, 7 : DelejVyberKurzor_99(crSizeNS);   // stred horni nebo dolni cary
            6, 8 : DelejVyberKurzor_99(crSizeWE);   // stred prave nebo leve cary
          end;
        end;

        if AktAmiOzn is TAmiSchema then begin
          Nasel := TRUE;
          Case CBUch of
            1, 2, 5 : DelejVyberKurzor_99(crVentilOtoc); // ma otocit
            3 : DelejVyberKurzor_99(crSizeWE);   // stred leve cary
            4 : DelejVyberKurzor_99(crSizeNS);   // stred horni cary
          end;
        end;

        if AktAmiOzn is TAmiPneuH then begin
          Nasel := TRUE;
          Case CBUch of
            1, 3 : DelejVyberKurzor_99(crVentilOtoc); // ma otocit
            2 : DelejVyberKurzor_99(crSizeNS);  // horni cast, zmenit velikost
            4 : DelejVyberKurzor_99(crDefault);
          else
            if Length(TAmiPneuH(AktAmiOzn).KapilarB2)>0 then begin
              if CBuch<>4+Length(TAmiPneuH(AktAmiOzn).KapilarB1) then
                DelejVyberKurzor_99(crSizeAll);     // bod kapilary
            end else begin
              DelejVyberKurzor_99(crSizeAll);     // bod kapilary
            end;
          end;
        end;

        if (AktAmiOzn is TAmiTrubka) OR
           (AktAmiOzn is TAmiCara) OR
           ((AktAmiOzn is TAmiTextik) AND
            ((AktAmiOzn.Typ=TypAmiText2) OR (AktAmiOzn.Typ=TypAmiText3))) OR
           (AktAmiOzn is TAmiPopis) OR
           (AktAmiOzn is TAmiVenti4) then begin
          Nasel := TRUE;
          DelejVyberKurzor_99(crSizeAll);  // koncovy bod trubky, cary...
        end;

        if AktAmiOzn is TAmiVenti3 then begin
          Nasel := TRUE;
          DelejVyberKurzor_99(crSizeWE);   // rozdelovac, roztahnout nebo smrsknout
        end;

        if AktAmiOzn is TAmiKotel then begin
          Nasel := TRUE;
          DelejVyberKurzor_99(crVentilOtoc);   // Obecna pata, otocit
        end;

        if AktAmiOzn.JeAAAVent1 then begin
          Nasel := TRUE;
          if CBUch=1 then DelejVyberKurzor_99(crVentilOtoc)  // predelat kurzor na otocit ventil
                     else DelejVyberKurzor_99(crSizeAll);    // bod kapilary
        end;

        if ((AktAmiOzn is TAmiOblouk) AND (AktAmiOzn.Typ=TypAmiOblouk2)) then begin
          Nasel := TRUE;
          DelejVyberKurzor_99(crVentilOtoc);
        end;

        if ((AktAmiOzn is TAmiVenti2) AND
           ((AktAmiOzn.Typ=TypVenti2+1) OR (AktAmiOzn.Typ=TypVenti2+3) OR
            (AktAmiOzn.Typ=TypVenti2+6) OR (AktAmiOzn.Typ=TypVenti2+8))) then begin
          Nasel := TRUE;
          DelejVyberKurzor_99(crVentilOtoc);
        end;

      end;
    end;


    if NOT Nasel then begin
      Try
        for i := 0 to BodySpojTrubekX.Count-1 do begin
          PoiXY.X := Integer(BodySpojTrubekX[i]);
          PoiXY.Y := Integer(BodySpojTrubekY[i]);
          if BlizkeBody(Bod, PoiXY, EpsilonRel) then begin
            Pocet := 0;
            for j := 0 to AmiLispik.Count-1 do begin
              AC := AmiLispik[j];
              Case AC.Typ of
                TypTrubka1, TypTrubka0 : if (Pocet>=0) then begin   // teple trubky, Pocet>0
                  if PorovnejBody(PoiXY, AC.Pocatek) OR
                     PorovnejBody(PoiXY, AC.AbsKonec) then inc(Pocet);
                  if Pocet>=2 then begin
                    Nasel := TRUE;
                    DelejVyberKurzor_99(crCtrlShift);   // pri stisku CTRL je mozno
                    exit;  // pohnout koncovym bodem nekolika stykajicich se trubek
                  end;
                end;

                TypTrubka2 : if (Pocet<=0) then begin  // studene trubky, Pocet<0
                  if PorovnejBody(PoiXY, AC.Pocatek) OR
                     PorovnejBody(PoiXY, AC.AbsKonec) then dec(Pocet);
                  if Pocet<=-2 then begin
                    Nasel := TRUE;
                    DelejVyberKurzor_99(crCtrlShift);   // pri stisku CTRL je mozno
                    exit;  // pohnout koncovym bodem nekolika stykajicich se trubek
                  end;
                end;

                TypTrubka3 : if (Pocet>=0) then begin  // privodni C trubky, Pocet<0
                  if PorovnejBody(PoiXY, AC.Pocatek) OR
                     PorovnejBody(PoiXY, AC.AbsKonec) then dec(Pocet);
                  if Pocet>=2 then begin
                    Nasel := TRUE;
                    DelejVyberKurzor_99(crCtrlShift);   // pri stisku CTRL je mozno
                    exit;  // pohnout koncovym bodem nekolika stykajicich se trubek
                  end;
                end;

                TypTrubka4 : if (Pocet<=0) then begin  // zpatecni C trubky, Pocet<0
                  if PorovnejBody(PoiXY, AC.Pocatek) OR
                     PorovnejBody(PoiXY, AC.AbsKonec) then dec(Pocet);
                  if Pocet<=-2 then begin
                    Nasel := TRUE;
                    DelejVyberKurzor_99(crCtrlShift);   // pri stisku CTRL je mozno
                    exit;  // pohnout koncovym bodem nekolika stykajicich se trubek
                  end;
                end;

              end;
            end;   // for j
          end;
        end;       // for i
      except

      end;
    end;
  end;

  if NOT Nasel then
    DelejVyberKurzor_99(0);
end;

procedure TFrForm99.UkazOblastProTisk_99;
var
  VyrB1, VyrB2 : TPoint;
begin
  if JeOblastProTisk then begin
    DelejSpocAbsBodik(PocAmi, VyrezTiskuB1, KoefZvetseni, VyrB1);
    DelejSpocAbsBodik(PocAmi, VyrezTiskuB2, KoefZvetseni, VyrB2);
    with PaintBox1.Canvas do begin
      Pen.Mode := pmCopy;
      Pen.Color := BarvaVyrezuTisku;
      Pen.Width := 4;
      Polyline([VyrB1, Point(VyrB1.X, VyrB2.Y),
                VyrB2, Point(VyrB2.X, VyrB1.Y), VyrB1]);
      Pen.Width := 1;
    end;
  end;
end;

procedure TFrForm99.PaintBoxMeritkoXPaint(Sender: TObject);
begin
  MeritkoX(PaintBoxMeritkoX.Canvas, KoefZvetseni, PocAmi, PaintBoxMeritkoX.Width);
  CarkaNaPravitkuX; // nakresli odpovidajici carku na pravitkuX
end;

procedure TFrForm99.PaintBoxMeritkoYPaint(Sender: TObject);
begin
  MeritkoY(PaintBoxMeritkoY.Canvas, KoefZvetseni, PocAmi, PaintBoxMeritkoY.Height);
  CarkaNaPravitkuY; // nakresli odpovidajici carku na pravitkuX
end;

Procedure TFrForm99.DelejAktBod(ABod : TPoint);
var
  BBod2 : TPoint;
  R1,R2 : TRect;
begin
  if NOT PorovnejBody(ABod, AktBodAmi) then begin
    R2 := Rect(0, 0, 2*VelAktBodu, 2*VelAktBodu);
{    PaintBox1.Canvas.CopyMode := cmSrcCopy;
    AktBodBM.Canvas.CopyMode := cmSrcCopy; }
    DelejSpocAbsBodik(PocAmi, AktBodAmi, KoefZvetseni, BBod2);
    if NOT ((BBod2.X<-VelAktBodu) OR (BBod2.X>PaintBox1.Width+VelAktBodu) OR
            (BBod2.Y<-VelAktBodu) OR (BBod2.Y>PaintBox1.Width+VelAktBodu)) then begin
      R1 := Rect(BBod2.X-VelAktBodu, BBod2.Y-VelAktBodu,
                 BBod2.X+VelAktBodu+1, BBod2.Y+VelAktBodu+1);
      PaintBox1.Canvas.CopyRect(R1,AktBodBM.Canvas,R2);
    end;

    AktBodAmi := ABod;

    DelejSpocAbsBodik(PocAmi, AktBodAmi, KoefZvetseni, BBod2);
    R1 := Rect(BBod2.X-VelAktBodu, BBod2.Y-VelAktBodu,
               BBod2.X+VelAktBodu+1, BBod2.Y+VelAktBodu+1);
    AktBodBM.Canvas.CopyRect(R2,PaintBox1.Canvas,R1);
    With PaintBox1.Canvas do begin
      Pen.Mode := pmCopy;
      Pen.Width := 1;
      Case CisloCimJede_99 of
        -TypTrubka1 :  Pen.Color := BarvaTrubka1;
        -TypTrubka2 :  Pen.Color := BarvaTrubka2;
        -TypTrubka0 :  Pen.Color := BarvaTrubka0;
        -TypTrubka3 :  Pen.Color := BarvaTrubka3;
        -TypTrubka4 :  Pen.Color := BarvaTrubka4;
        -TypTrubka5 :  Pen.Color := BarvaTrubka5;
        -TypTrubka6 :  Pen.Color := BarvaTrubka6;
        -TypTrubkaOV : Pen.Color := BarvaTrubkaOV;
      end;
      Pen.Color := clBlack;
      Brush.Color := Pen.Color;
      Rectangle(BBod2.X-VelAktBodu, BBod2.Y-VelAktBodu,
                BBod2.X+VelAktBodu+1, BBod2.Y+VelAktBodu+1);
    end;
  end;
end;

procedure TFrForm99.FrFormDestroy;
begin
//  AFormP.Free;
//  AFormI.Free;
  DelejUkazatOznaceniVetvi_99(FALSE);

  if AFormP<>NIL then begin
    AFormP.FormPClosing := TRUE;
//    AFormP.Close;
//    AFormP.Release;
  end;
  if AFormI<>NIL then begin
    AFormI.FormIClosing := TRUE;
//    AFormI.Close;
//    AFormI.Release;
  end;
  AktBodBM.Free;

  BitMapGrid.Free;
  BiMa.Free;

  PosicevNastZoomu := -1;
  DelejZrusNastZoomu_99;
  ListNastaveniZoomu.Free;

  BarvyStoupacekList.Free;
  StoupStrList.Free;
  ATopChlad.Free;
end;

Procedure TFrForm99.PrepocitejGrid(Koef : extended);
begin
  AbsGriq.X := Max(1,Round(Koef*Griq.X/10));
  AbsGriq.Y := Max(1,Round(Koef*Griq.Y/10));
end;

procedure TFrForm99.OblastProTisk1Click_99;
begin
  CisloCimJede_99 := 0;
  with ATopChlad do begin
    OznList.Clear;
    VybList.Clear;
    KontrList.Clear;
    DelejOznAmi_99(NIL);
    BZobrazitsKontrolou := FALSE;
  end;
  ZobrazitKontrolu_99(FALSE, FALSE);
{  PageControl1Change(Self); }
  if BDelejOblastProTisk then begin
    DelejVyberKurzor_99(212);  { vymenit kurzor ! }
  end else begin
    DelejVyberKurzor_99(crDefault);
  end;
  DelejInvalidu_99;
end;

Procedure TFrForm99.DokonciNastaveniZoom_99;
begin
  BitBtn0.Caption := IntToStr(Round(100*KoefZvetseni));
  PrepocitejGrid(KoefZvetseni);
  Sitnice := SpSit(KoefZvetseni);
  PripravGrid(BitMapGrid,KoefZvetseni,clDkGray,Griq);

  EpsilonRel := Round(EpsilonAbs/(KoefZvetseni*JMetrMM));
  VidPanel1_99(FALSE);
  SpoctiKorku_99;

  with ScrollBar1 do begin
    SmallChange := SpSit(KoefZvetseni);
    LargeChange := 10*SmallChange;
  end;
  with ScrollBar2 do begin
    SmallChange := SpSit(KoefZvetseni);
    LargeChange := 10*SmallChange;
  end;

  PosRad1.NastavGKoefPS(KoefZvetseni, PocAmi);
  PosRad1.Pocatek := PocAmi;
  PosRad1.AbsObd(KoefZvetseni, PocAmi);

  PosRad2.NastavGKoefPS(KoefZvetseni, PocAmi);
  PosRad2.Pocatek := PocAmi;
  PosRad2.AbsObd(KoefZvetseni, PocAmi);

  PosChladic1.NastavGKoefPS(KoefZvetseni, PocAmi);
  PosChladic1.Pocatek := PocAmi;
  PosChladic1.AbsObd(KoefZvetseni, PocAmi);

  PosOTChladic1.NastavGKoefPS(KoefZvetseni, PocAmi);
  PosOTChladic1.Pocatek := PocAmi;
  PosOTChladic1.AbsObd(KoefZvetseni, PocAmi);

  PosKotel.NastavGKoefPS(KoefZvetseni, PocAmi);
  PosKotel.Pocatek := PocAmi;
  PosKotel.AbsObd(KoefZvetseni, PocAmi);

  PosSchema.NastavGKoefPS(KoefZvetseni, PocAmi);
  PosSchema.Pocatek := PocAmi;
  PosSchema.AbsObd(KoefZvetseni, PocAmi);
  PosSchema.Kresli(NIL, KoefZvetseni, 4, PocAmi);

  PosPneuH.NastavGKoefPS(KoefZvetseni, PocAmi);
  PosPneuH.Pocatek := PocAmi;
  PosPneuH.AbsObd(KoefZvetseni, PocAmi);
  PosPneuH.Kresli(NIL, KoefZvetseni, 4, PocAmi);

  MuzeScroll := TRUE;
  DelejInvalidu_99;
end;

Procedure TFrForm99.DelejProvedZoom(APosX, APosY, AKoefInt : integer);
var
  BPosX, BPosY : integer;
begin
  KoefZvetseni := AKoefInt/1000000;
  if KoefZvetseni>MaxKoeficientZvetseni then
    KoefZvetseni := MaxKoeficientZvetseni;
{
  BPosX := APosX+Round(BiMa.Width/(KoefZvetseni*JMetrMM));
  BPosY := APosY+Round(BiMa.Height/(KoefZvetseni*JMetrMM));
  ScrollBar1.Position := BPosX;
  ScrollBar2.Position := BPosY; }
{  DokonciNastaveniZoom; }

  MuzeScroll := FALSE;
  ScrollBar1.Position := APosX;
  ScrollBar2.Position := APosY;
  DokonciNastaveniZoom_99;
  NastavToolB97Zobr5_6_FormA(PosicevNastZoomu>0, PosicevNastZoomu<ListNastaveniZoomu.Count-1);
end;

Procedure TFrForm99.ZoomZpet;
var
  PRecZoom : PPosiceOknaZ;
begin
  if PosicevNastZoomu>0 then begin
    Dec(PosicevNastZoomu);
    PRecZoom := ListNastaveniZoomu[PosicevNastZoomu];
    with PRecZoom^ do DelejProvedZoom(PosX, PosY, KoefInt);
  end;
end;

Procedure TFrForm99.ZoomTam;
var
  PRecZoom : PPosiceOknaZ;
begin
  if PosicevNastZoomu<ListNastaveniZoomu.Count-1 then begin
    Inc(PosicevNastZoomu);
    PRecZoom := ListNastaveniZoomu[PosicevNastZoomu];
    with PRecZoom^ do DelejProvedZoom(PosX, PosY, KoefInt);
  end;
end;

procedure TFrForm99.ToolBZobr5Click_99;
begin
  ZoomZpet;
//  PaintBox1.Canvas.Draw(0,0, BiMa);
//  Invalidate;
end;

procedure TFrForm99.ToolBZobr6Click_99;
begin
  ZoomTam;
//  PaintBox1.Canvas.Draw(0,0, BiMa);
//  Invalidate;
end;

procedure TFrForm99.ToolBZobr4Click_99;
begin
  KnofZvClick(KnofZvets[9]);  // cely projekt
end;

(*procedure Form99.ToolBZobr1Click(Sender: TObject);
begin
  AToolB97Click(Sender);
  ToolB97Zobr1.Down := TRUE;
  DelejVyberKurzor_99(crLUPA);
end;

procedure Form99.AToolBZobrClick(Sender: TObject);
begin
  AToolBZobr.Checked := NOT AToolBZobr.Checked;
  ToolBar97Zobr.Visible := AToolBZobr.Checked;
end;

procedure Form99.Zobrazeni2Click(Sender: TObject);
begin
  Zobrazeni2.Checked := NOT Zobrazeni2.Checked;
  ToolBar97Zobr.Visible := Zobrazeni2.Checked;
end;

procedure Form99.ToolBZobr2Click(Sender: TObject);
begin
  AToolB97Click(Sender);
  ToolB97Zobr2.Down := TRUE;
  DelejVyberKurzor_99(crPacka);
end;

procedure Form99.ToolBZobr3Click(Sender: TObject);
begin
  AToolB97Click(Sender);
  ToolB97Zobr3.Down := TRUE;
  DelejVyberKurzor_99(crSTREDA);
end; *)

Procedure TFrForm99.ZobrazNeaktivniLogo;
var
  LogoBitmap : TBitmap;
const
  LogoWidth = 676;
  LogoHeight = 109;

begin
  LogoBitmap := TBitmap.Create;
  Try
    with Logobitmap do begin
      Width := LogoWidth;
      Height := LogoHeight;
      Canvas.Brush.Color := BarvaNeaktProjektu;
//      Canvas.Brush.Color := clWhite;
      Canvas.FillRect(Rect(0, 0, Width, Height));
      Canvas.BrushCopy(Rect(Width-ImageLogo_V.Picture.Width, 0, Width, ImageLogo_V.Picture.Height),
          ImageLogo_V.Picture.Bitmap, Rect(0, 0, ImageLogo_V.Picture.Width, ImageLogo_V.Picture.Height),
          clWhite);
      Canvas.BrushCopy(Rect(0, Height-ImageLogo_T_16.Picture.Height, ImageLogo_T_16.Picture.Width, Height),
          ImageLogo_T_16.Picture.Bitmap, Rect(0, 0, ImageLogo_T_16.Picture.Width, ImageLogo_T_16.Picture.Height),
          clWhite);
//      Paintbox1.Canvas.Pen.Color := clWhite;
//      PaintBox1.Canvas.Rectangle(2, PaintBox1.Height-Height-6, 6+Width, PaintBox1.Height-2);
//      PaintBox1.Canvas.Rectangle(3, PaintBox1.Height-Height-5, 5+Width, PaintBox1.Height-3);
      PaintBox1.Canvas.Draw(8, PaintBox1.Height-Height-8, Logobitmap);

    end;
  finally
    LogoBitmap.Free;
  end;
end;

procedure TFrForm99.PaintBox1Paint(Sender: TObject);
var
  ASch : TAmiClass;
begin
  Meritko(PaintBoxMeritkoX.Canvas, PaintBoxMeritkoY.Canvas, KoefZvetseni, PocAmi,
    PaintBoxMeritkoX.Width, PaintBoxMeritkoY.Height);
  if OtevrenyProjekt then begin
    with ATopChlad do begin
      if Assigned(MetF) then begin
        PaintBox1.Canvas.Draw(PoAAmi.X, PoAAmi.Y, MetF);
      end else begin
        PaintBox1.Canvas.Draw(0,0, BiMa);
      end;

      if AktAmiOzn<>NIL then begin
        if AmiLispik.IndexOf(AktAmiOzn)>=0 then begin
          AktAmiOzn.Kresli(PaintBox1.Canvas, KoefZvetseni, 4, PocAmi);
        end else begin
          AktAmiOzn := NIL;
        end;
      end;

      if AktAmiLisq<>NIL then begin
        if AmiLispik.IndexOf(AktAmiLisq)>=0 then begin
          AktAmiLisq.Kresli(PaintBox1.Canvas, KoefZvetseni, 7, PocAmi);
        end else begin
          AktAmiLisq := NIL;
        end;
      end;

      if AktAmiveSchematu<>NIL then begin
        Try
          AktAmiveSchematu.Kresli(PaintBox1.Canvas, KoefZvetseni, 8, PocAmi);
        except
          AktAmiveSchematu := NIL;
        end;
      end;

      if AktAmiSchemaF<>NIL then begin
        Try
          ASch := AktAmiSchemaF.AnCm;
          if ASch is TAmiSchema then begin
            TAmiSchema(ASch).SkutecneSouradniceObjektu;
            Try
              AktAmiSchemaF.Kresli(PaintBox1.Canvas, KoefZvetseni, 8, PocAmi);
            finally
              TAmiSchema(ASch).VratSouradniceObjektu;
            end;
          end else begin
            AktAmiSchemaF := NIL;
          end;
        except
          AktAmiSchemaF := NIL;
        end;
      end;

      UkazOblastProTisk_99;
      AktBodAmi := Point(-MaxInt div 2, -MaxInt div 2);
      MysiKriz([], TRUE, FALSE);
    end;
  end else begin
    with PaintBox1 do begin
      Canvas.Brush.Color := BarvaNeaktProjektu;
      Canvas.FillRect(Rect(0, 0, Width, Height));
    end;
    ZobrazNeaktivniLogo;
  end;
  AktBodAmi := Point(-MaxInt div 2, -MaxInt div 2);
end;

procedure TFrForm99.DelejPohniViceKotRad(ABod : TPoint;
  CoDelat : integer; Kreslit, KonecRotace : boolean);

{Procedure AKresli(TT : TAmiClass);
var
  AB1, AB2 : TPoint;
begin
  DelejSpocAbsBodik(PocAmi, TT.Pocatek, KoefZvetseni, AB1);
  DelejSpocAbsBodik(PocAmi, TT.AbsKonec, KoefZvetseni, AB2);
end; }
const
  PrvniBod : TPoint = (X:0; Y:0);
  Boy : Array[0..1] of TPoint = ((X:0; Y:0), (X:0; Y:0));

var
  i : integer;
  AT : TAmiClass;
  BBod, CBod : TPoint;

begin
  if CoDelat=0 then
    PrvniBod := ABod;

  with ATopChlad do begin
    for i := 0 to VybList.Count-1 do begin
      AT := VybList[i];
      if CoDelat=0 then
        Boy[i] := AT.AbsKonec;
      CBod := Point(ABod.X-PrvniBod.X+Boy[i].X, ABod.Y-PrvniBod.Y+Boy[i].Y);
      DelejPohniObjektyNaTrubce(CBod, AT, TRUE ,TRUE, KonecRotace);

      PaintBox1.Canvas.Pen.Mode := pmXOR;
      if Kreslit then AT.KreslAbs(PaintBox1.Canvas, Point(0, 0));
      if FALSE {AT.Orientace>0} then begin
        BBod := AT.AbsKonec;
        AT.Pocatek := CBod;
        AT.AbsKonec := BBod;
      end else begin
        AT.AbsKonec := CBod;
      end;
      AT.AbsObd(KoefZvetseni, PocAmi);
      AT.PraveVlozeny := TRUE;

      ZmenaProjektu := TRUE;
      PaintBox1.Canvas.Pen.Mode := pmXOR;
      if Kreslit then AT.KreslAbs(PaintBox1.Canvas, Point(0, 0));

      {    if NOT Kreslit then begin
        if AT.Orientace>0 then begin
          BBod := AT.AbsKonec;
          AT.Pocatek := ABod;
          AT.AbsKonec := BBod;
        end else begin
          AT.AbsKonec := ABod;
        end;
        ZmenaProjektu := TRUE;
      end; }

      {    if Kreslit then begin
        AC.AbsObd(KoefZvetseni, PocAmi);
        AC.KreslAbs(PaintBox1.Canvas, Point(0, 0));
      end; }
    end;
  end;
end;

procedure TFrForm99.DelejPohniObjektyNaKapilarachb(ABod : TPoint; AT : TAmiClass;
                        CisloBodu : integer; Kreslit, Prepocitat : boolean);
var
  BodKotva : TPoint;
  i, j, ACary : integer;
  AC, AX : TAmiClass;

  Dist1, Dist2, L : extended;

  R, EX, EY, Uhel : extended;
  ADrzatko : TPoint;

  VectK : TPoint;
  Alf : extended;
  BBod : TPoint;

  NBoduKapilary : integer;
  B1, B2 : TPoint;
  CisloBodv : integer;
begin
  HejbalObjektyNaKapilare := TRUE;
  for ACary := 1 to 2 do begin
    if ACary=1 then begin
      CisloBodv := CisloBodu-1;
      BodKotva := AT.AbsKonec;

    end else begin
      CisloBodv := CisloBodu+1;
      BodKotva := AT.AbsKonec;
    end;
    EX := ABod.X-BodKotva.X;
    EY := ABod.Y-BodKotva.Y;
    Uhel := ArcTan2(EY, EX);

  {  if Prepocitat then  begin
      if PevnyPocatek then begin
        AT.AbsKonec := ABod;
      end else begin
        BBod := AT.AbsKonec;
        AT.Pocatek := ABod;
          AT.AbsKonec := BBod;
        end;
        AT.AbsObd(KoefZvetseni, PocAmi);
      end; }

    with ATopChlad do begin
      for i := 0 to AmiLispik.Count-1 do begin
        AC := AmiLispik.Items[i];
        begin
          if AC.Typ=TypVentiPneuHShutoffValve then begin
            if AC.AmCl=AT then begin
              EX := AC.Pocatek.X-BodKotva.X;
              EY := AC.Pocatek.Y-BodKotva.Y;
              R := Sqrt(Sqr(EX)+Sqr(EY));
              if Kreslit then begin
    {            AC.AbsObd)KoefZvetseni, PocAmi); }
                AC.KreslAbs(PaintBox1.Canvas, Point(0, 0));
                for j := 0 to AmiLispik.Count-1 do begin
                  AX := AmiLispik.Items[j];
                  if AX is TAmiPopis then begin
                    if AX.AmCl=AC then begin
                      PaintBox1.Canvas.Pen.Mode := pmXOR;
                      AX.AbsObd(KoefZvetseni, PocAmi);
                      AX.KreslAbs(PaintBox1.Canvas, Point(0, 0));
                    end;
                  end;
                end;
              end;
              AC.Pocatek := Point(BodKotva.X+Round(R*Cos(Uhel)),
                                  BodKotva.Y+Round(R*Sin(Uhel)));
              if Kreslit then begin
                AC.AbsObd(KoefZvetseni, PocAmi);
                AC.KreslAbs(PaintBox1.Canvas, Point(0, 0));
              end;

              for j := 0 to AmiLispik.Count-1 do begin
                AX := AmiLispik.Items[j];
                if AX is TAmiPopis then begin
                  if AX.AmCl=AC then begin
                    PaintBox1.Canvas.Pen.Mode := pmXOR;
                    if AX.Typ=TypPopisVent then begin
                      AX.Pocatek := Point(AC.Pocatek.X, AC.Pocatek.Y+150);
                      AX.SpocitejORect;
                    end else begin
                      TAmiPopis(AX).AbsDrzatko := AC.Pocatek;
                    end;
                    if Kreslit then begin
                      AX.AbsObd(KoefZvetseni, PocAmi);
                      AX.KreslAbs(PaintBox1.Canvas, Point(0, 0));
                    end;
                  end;
                end;

              end;
            end;
          end;
        end;
      end;

    {  if NOT Prepocitat then  begin
        if AT.Orientace>0 then begin
          BBod := AT.AbsKonec;
          AT.Pocatek := ABod;
          AT.AbsKonec := BBod;
        end else begin
          AT.AbsKonec := ABod;
        end;
        AT.AbsObd(KoefZvetseni, PocAmi);
      end; }
    end;
  end;   // for ACary
end;

Procedure TFrForm99.OtocObjektemAC(AAC : TAmiClass; ABodKotva : TPoint;
          AUhel : extended; AKreslit : boolean);
var
  j : integer;
  R, EX, EY : Extended;
  NBoduKapilary : integer;
  AX : TAmiClass;
  B1, B2 : TPoint;
begin
  AAC.Rotuje := TRUE;
  EX := AAC.Pocatek.X-ABodKotva.X;
  EY := AAC.Pocatek.Y-ABodKotva.Y;
  R := Sqrt(Sqr(EX)+Sqr(EY));
  if AKreslit then begin
    AAC.KreslAbs(PaintBox1.Canvas, Point(0, 0));
    for j := 0 to ATopChlad.AmiLispik.Count-1 do begin
      AX := ATopChlad.AmiLispik.Items[j];
      if AX is TAmiPopis then begin
        if AX.AmCl=AAC then begin
          PaintBox1.Canvas.Pen.Mode := pmXOR;
          AX.AbsObd(KoefZvetseni, PocAmi);
          AX.KreslAbs(PaintBox1.Canvas, Point(0, 0));
        end;
      end;
    end;
  end;
  AAC.Pocatek := Point(ABodKotva.X+Round(R*Cos(AUhel)),
                       ABodKotva.Y+Round(R*Sin(AUhel)));
  AAC.Alfa := UpravAlfaAAAVent1(AAC.Orientace, AUhel);
  AAC.Kresli(NIL, KoefZvetseni, 0, PocAmi);  // kvuli prepoctu FBodyUch[6] a SpocitejORect
  if AKreslit then begin
    AAC.AbsObd(KoefZvetseni, PocAmi);
    AAC.KreslAbs(PaintBox1.Canvas, Point(0, 0));
  end;

  for j := 0 to ATopChlad.AmiLispik.Count-1 do begin
    AX := ATopChlad.AmiLispik.Items[j];
    if AX is TAmiPopis then begin
      if AX.AmCl=AAC then begin
        PaintBox1.Canvas.Pen.Mode := pmXOR;
        if AX.Typ=TypPopisVent then begin
          AX.Pocatek := Point(AAC.Pocatek.X, AAC.Pocatek.Y+150);
          AX.SpocitejORect;
        end else begin
          TAmiPopis(AX).AbsDrzatko := AAC.Pocatek;
        end;
        if AKreslit then begin
          AX.AbsObd(KoefZvetseni, PocAmi);
          AX.KreslAbs(PaintBox1.Canvas, Point(0, 0));
        end;
      end;
    end;

    if VentilsKapilarou(AX) AND (AX.AnCm=AAC) then begin
      NBoduKapilary := Length(TAmiVentil(AX).Kapilara);
//              EX := AC.BodyUch[NBoduKapilary].X-BodKotva.X;
//              EY := AC.BodyUch[NBoduKapilary].Y-BodKotva.Y;
//              R := Sqrt(Sqr(EX)+Sqr(EY));
{      if NOT AT.Rotuje then begin
        if DistBodu(AX.BodyUch[NBoduKapilary], AAC.BodyPrip[1])<
           DistBodu(AX.BodyUch[NBoduKapilary], AAC.BodyPrip[2]) then
              TAmiVentil(AX).CilKapilary := 1 else
              TAmiVentil(AX).CilKapilary := 2;

      end; }
      if AKreslit then begin
{            AC.AbsObd)KoefZvetseni, PocAmi); }
        DelejSpocAbsBodik(PocAmi, AX.BodyUch[NBoduKapilary-1], KoefZvetseni, B1);
        DelejSpocAbsBodik(PocAmi, AX.BodyUch[NBoduKapilary], KoefZvetseni, B2);
        PaintBox1.Canvas.Pen.Style := psDot;
        PaintBox1.Canvas.Pen.Mode := pmXOR;
        PaintBox1.Canvas.Polyline([B1, B2]);
      end;
//              AX.BodyUch[NBoduKapilary] := AC.BodyUch[1];
//      AX.BodyUch[NBoduKapilary] := AAC.Pocatek;
      AX.BodyUch[NBoduKapilary] := AAC.BodyPrip[TAmiVentil(AX).CilKapilary];
      if AKreslit then begin
        DelejSpocAbsBodik(PocAmi, AX.BodyUch[NBoduKapilary], KoefZvetseni, B2);
        PaintBox1.Canvas.Pen.Style := psDot;
        PaintBox1.Canvas.Pen.Mode := pmXOR;
        PaintBox1.Canvas.Polyline([B1, B2]);
      end;
    end;
  end;
  PaintBox1.Canvas.Pen.Style := psDot;
  PaintBox1.Canvas.Pen.Mode := pmXOR;
end;

Procedure TFrForm99.PohniKoncemKapilary(APocatek : TPoint; AKapilara : TArrayPoints; ABodKotva : TPoint;
      AUhel : extended; AKreslit : boolean);
var
  R, EX, EY : Extended;
  NBK : integer;
  AX : TAmiClass;
  B1, B2 : TPoint;
  P1, P2 : TPoint;
begin
  NBK := Length(AKapilara);
  P1 := Point(APocatek.X+AKapilara[NBK-1].X, APocatek.Y+AKapilara[NBK-1].Y);
  P2 := Point(APocatek.X+AKapilara[NBK-2].X, APocatek.Y+AKapilara[NBK-2].Y);
  EX := P1.X-ABodKotva.X;
  EY := P1.Y-ABodKotva.Y;
  R := Sqrt(Sqr(EX)+Sqr(EY));
  if AKreslit then begin
{            AC.AbsObd)KoefZvetseni, PocAmi); }
    DelejSpocAbsBodik(PocAmi, P2, KoefZvetseni, B2);
    DelejSpocAbsBodik(PocAmi, P1, KoefZvetseni, B1);
    PaintBox1.Canvas.Pen.Style := psDot;
    PaintBox1.Canvas.Pen.Mode := pmXOR;
    PaintBox1.Canvas.Polyline([B2, B1]);
  end;
  P1 := Point(ABodKotva.X+Round(R*Cos(AUhel)),
              ABodKotva.Y+Round(R*Sin(AUhel)));
  AKapilara[NBK-1] := Point(P1.X-APocatek.X, P1.Y-APocatek.Y);
  if AKreslit then begin
    DelejSpocAbsBodik(PocAmi, P1, KoefZvetseni, B1);
    PaintBox1.Canvas.Pen.Style := psDot;
    PaintBox1.Canvas.Pen.Mode := pmXOR;
    PaintBox1.Canvas.Polyline([B2, B1]);
  end;
  PaintBox1.Canvas.Pen.Style := psDot;
  PaintBox1.Canvas.Pen.Mode := pmXOR;
end;

procedure TFrForm99.DelejPohniObjektyNaTrubce(ABod : TPoint; AT : TAmiClass;
                        PevnyPocatek, Kreslit, KonecRotace : boolean);

Procedure OtocShutoffVentilynakoncikapilary(AAC : TAmiClass; ANBoduKapilary : integer; AKreslit : boolean);
var
  j : integer;
  AX : TAmiClass;
  B1, B2 : TPoint;
  AUhel : extended;
begin
  for j := 0 to ATopChlad.AmiLispik.Count-1 do begin
    AX := ATopChlad.AmiLispik[j];
    if (AX is TAmiVentiPneuH) AND (AX.AnCl=AAC) then begin
      if (TAmiVentiPneuH(AX).CilKapilary=ANBoduKapilary-1) then begin
        B1 := AAC.BodyUch[ANBoduKapilary-1];
        B2 := AAC.BodyUch[ANBoduKapilary];
        AUhel := ArcTan2(B2.Y-B1.Y, B2.X-B1.X);
//                          AUhel1 := UpravAlfaAAAVent1(AC.Orientace, AUhel1);
        OtocObjektemAC(AX, B1, AUhel, AKreslit);
      end;
    end;
  end;
end;

var
  BodKotva : TPoint;
  i, j : integer;
  AC, AX : TAmiClass;

  Dist1, Dist2, L : extended;

  R, EX, EY, {EX1, EY1,} BUhel : extended;
  ADrzatko : TPoint;

  VectK : TPoint;
  Alf : extended;
  BBod : TPoint;

  NBoduKapilary : integer;
  B1, B2 : TPoint;
  AUhel : extended;
begin
  HejbalObjektyNaTrubce := TRUE;
  if PevnyPocatek then BodKotva := AT.Pocatek
                  else BodKotva := AT.AbsKonec;
  EX := ABod.X-BodKotva.X;
  EY := ABod.Y-BodKotva.Y;
  BUhel := ArcTan2(EY, EX);

{  if Prepocitat then  begin
    if PevnyPocatek then begin
      AT.AbsKonec := ABod;
    end else begin
      BBod := AT.AbsKonec;
      AT.Pocatek := ABod;
        AT.AbsKonec := BBod;
      end;
      AT.AbsObd(KoefZvetseni, PocAmi);
    end; }

  with ATopChlad do begin
    for i := 0 to AmiLispik.Count-1 do begin
      AC := AmiLispik.Items[i];
      begin
        if AC.JeAAAVent1 then begin
//          if AC.AmCl=AT then begin
          if AC.AnCl=AT then begin
            for j := 0 to AmiLispik.Count-1 do begin
              AX := AmiLispik.Items[j];

              if VentilsKapilarou(AX) AND (AX.AnCm=AC) then begin
                NBoduKapilary := Length(TAmiVentil(AX).Kapilara);
                if NOT AT.Rotuje then begin
                  if DistBodu(AX.BodyUch[NBoduKapilary], AC.BodyPrip[1])<
                     DistBodu(AX.BodyUch[NBoduKapilary], AC.BodyPrip[2]) then
                        TAmiVentil(AX).CilKapilary := 1 else
                        TAmiVentil(AX).CilKapilary := 2;

                end;
              end;
            end;
            OtocObjektemAC(AC, BodKotva, BUhel, Kreslit);
          end;

//          if VentilsKapilarou(AC) AND (AC.AmCm=AT) then begin
          if VentilsKapilarou(AC) AND (AC.AnCm=AT) then begin
            TAmiVentil(AC).CilKapilary := 0;
            PohniKoncemKapilary(AC.Pocatek, TAmiVentil(AC).Kapilara, BodKotva, BUhel, Kreslit);
          end;
        end;

        if (AC is TAmiPneuH) AND (AC.AnCm=AT) then begin
          PohniKoncemKapilary(AC.Pocatek, TAmiPneuH(AC).Kapilarb2, BodKotva, BUhel, Kreslit);
          with TAmiPneuH(AC) do
            NBoduKapilary := 3+Length(Kapilarb1)+Length(Kapilarb2);
          OtocShutoffVentilynakoncikapilary(AC, NBoduKapilary, Kreslit);
        end;

        if (AC is TAmiPneuH) AND (AC.AnCl=AT) then begin
          PohniKoncemKapilary(AC.Pocatek, TAmiPneuH(AC).Kapilarb1, BodKotva, BUhel, Kreslit);
          with TAmiPneuH(AC) do
            NBoduKapilary := 3+Length(Kapilarb1);
          OtocShutoffVentilynakoncikapilary(AC, NBoduKapilary, Kreslit);
        end;

        if AC is TAmiPopis then begin
          if AC.AmCl=AT then begin
            EX := TAmiPopis(AC).AbsDrzatko.X-BodKotva.X;
            EY := TAmiPopis(AC).AbsDrzatko.Y-BodKotva.Y;
            R := Sqrt(Sqr(EX)+Sqr(EY));
            if Kreslit then begin
              AC.AbsObd(KoefZvetseni, PocAmi);
              AC.KreslAbs(PaintBox1.Canvas, Point(0, 0));
            end;
            { orientovana vzdalenost od primky }
            Dist2 := OrientVzdalOdPrimky(BodKotva, ABod, AC.Pocatek);
            { Delka drzatka }
            Dist1 := DelkaVektoru(TAmiPopis(AC).RelDrzatko)*Signum(Dist2);

            ADrzatko := Point(BodKotva.X+Round(R*Cos(BUhel)),
                              BodKotva.Y+Round(R*Sin(BUhel)));
            if (AC.Typ=TypPopisTru2) OR (AC.Typ=TypPopisTru3) OR
               (AC.Typ=TypPopisTru4) OR (AC.Typ=TypPopisTru5) then begin
              { definuje novy pocatek pro kotu trubky }
              L := DelkaVektoru(Point(ABod.X-BodKotva.X, ABod.Y-BodKotva.Y));
              if L=0 then begin
                VectK.X := 1;
                VectK.Y := 0;
              end else begin
                VectK.X :=  Round(Dist1*(ABod.Y-BodKotva.Y)/L);
                VectK.Y := -Round(Dist1*(ABod.X-BodKotva.X)/L);
              end;
          {    AC.Pocatek.X := ADrzatko.X+VectK.X;
              AC.Pocatek.Y := ADrzatko.Y+VectK.Y; }
              AC.Pocatek := Point(ADrzatko.X+VectK.X, ADrzatko.Y+VectK.Y);

              Alf := ArcTan2(VectK.Y, VectK.X);
              if Abs(Alf)<=0.25*Pi then begin
                AC.Orientace := 0;
              end else begin
                if Abs(Alf)>=0.75*Pi then begin
                  AC.Orientace := 2;
                end else begin
                  if Alf>0 then begin
                    AC.Orientace := 1;
                  end else begin
                    AC.Orientace := 3;
                  end;
                end;
              end;

            end;

            TAmiPopis(AC).AbsDrzatko := ADrzatko;
              Point(BodKotva.X+Round(R*Cos(BUhel)),
                    BodKotva.Y+Round(R*Sin(BUhel)));

            if Kreslit then begin
              AC.AbsObd(KoefZvetseni, PocAmi);
              AC.KreslAbs(PaintBox1.Canvas, Point(0, 0));
            end;
          end;
        end;

        if AC is TAmiVenti4 then begin
//          if AC.AmCl=AT then begin
          if AC.AnCl=AT then begin
            EX := AC.BodyUch[1].X-BodKotva.X;
            EY := AC.BodyUch[1].Y-BodKotva.Y;
            R := Sqrt(Sqr(EX)+Sqr(EY));
            if Kreslit then begin
              AC.AbsObd(KoefZvetseni, PocAmi);
              AC.KreslAbs(PaintBox1.Canvas, Point(0, 0));
            end;

            AC.BodyUch[1] := Point(BodKotva.X+Round(R*Cos(BUhel)),
                                   BodKotva.Y+Round(R*Sin(BUhel)));

            if Kreslit then begin
              AC.AbsObd(KoefZvetseni, PocAmi);
              AC.KreslAbs(PaintBox1.Canvas, Point(0, 0));
            end;
          end;

//          if AC.AmCm=AT then begin
          if AC.AnCm=AT then begin
            EX := AC.BodyUch[3].X-BodKotva.X;
            EY := AC.BodyUch[3].Y-BodKotva.Y;
            R := Sqrt(Sqr(EX)+Sqr(EY));
            if Kreslit then begin
              AC.AbsObd(KoefZvetseni, PocAmi);
              AC.KreslAbs(PaintBox1.Canvas, Point(0, 0));
            end;

            AC.BodyUch[3] := Point(BodKotva.X+Round(R*Cos(BUhel)),
                                   BodKotva.Y+Round(R*Sin(BUhel)));

            if Kreslit then begin
              AC.AbsObd(KoefZvetseni, PocAmi);
              AC.KreslAbs(PaintBox1.Canvas, Point(0, 0));
            end;
          end;
        end;

      end;
    end;  // for i
    AT.Rotuje := TRUE;
    if KonecRotace then
      AT.Rotuje := FALSE;
  {  if NOT Prepocitat then  begin
      if AT.Orientace>0 then begin
        BBod := AT.AbsKonec;
        AT.Pocatek := ABod;
        AT.AbsKonec := BBod;
      end else begin
        AT.AbsKonec := ABod;
      end;
      AT.AbsObd(KoefZvetseni, PocAmi);
    end; }
  end;
end;

Procedure TFrForm99.VidPanel1_99(Jak : boolean);
begin
  Panel1.Visible := Jak;
end;

procedure TFrForm99.Timer2Timer(Sender: TObject);
var
  ZmenaPocX,ZmenaPocY : integer;
begin
  if CisloSymbolu=SymPosunVykres then exit;

  if AZmana.X<>0 then begin
    ZmenaPocX := Round((6*(AZmana.X div 3)+3)/(KoefZvetseni*JMetrMM));
    with ScrollBar1 do
{      Position := Position+10*AZmana.X; }
      Position := Position+ZmenaPocX;
  end;
  if AZmana.Y<>0 then begin
    ZmenaPocY := Round((6*(AZmana.Y div 3)+3)/(KoefZvetseni*JMetrMM));
    with ScrollBar2 do
{      Position := Position+10*AZmana.Y; }
      Position := Position+ZmenaPocY;
  end;

{  if Timer2.Enabled then } begin
    if (AZmana.X<>0) OR (AZmana.Y<>0) then begin
      DelejSpocAbsBodik(PocAmi, AKatva, KoefZvetseni, Kotva);
      DelejSpocAbsBodik(PocAmi, AKatvb, KoefZvetseni, Kotvb);
      with BiMa.Canvas do begin
        Pen.Style := psDot;
        Pen.Mode := pmXOR;
        Pen.Width := 1;
{        Pen.Color := clDkGray; }
        Pen.Color := BarvaPozadiObr;
        Brush.Style := bsClear;

        Case CisloSymbolu of
          1,11..14, SymUpravStropy, SymOblastProTisk, SymDelejZoomLupa :
                  Polyline([Kotva,Point(Kotva.X,Myska.Y),
                            Myska,Point(Myska.X,Kotva.Y),Kotva]);
          2,21..24 : begin
                  Polyline([Kotva, Myska]);
          end;
          3,31..34 : Polyline([Kotva, Myska]);
          5,26,28    : Polyline([Kotva, Point(Myska.X,Kotva.Y), Myska]);
          27,29      : Polyline([Kotva, Point(Kotva.X,Myska.Y), Myska]);
          15,17 : Polyline([Kotva,Kotvb, Point(Kotvb.X,Myska.Y),
                            Point(Kotva.X,Myska.Y), Kotva]);
          16,18 : Polyline([Kotva,Kotvb, Point(Myska.X,Kotvb.Y),
                            Point(Myska.X,Kotva.Y), Kotva]);
        end;
        Pen.Style := psSolid;
      end;
    end;
  end;

{  if (AZmana.X<>0) OR (AZmana.Y<>0) then begin
    Kotva.X := Round((AKatva.X-PocAmi.X)*KoefZvetseni*JMetrMM);
    Kotva.Y := Round(-(AKatva.Y-PocAmi.Y)*KoefZvetseni*JMetrMM);
    with PaintBox1.Canvas do begin
      Pen.Style := psDot;
      Pen.Mode  := pmXOR;
      Pen.Width := 1;
      Pen.Color := clDkGray;
      Brush.Style := bsClear;

      Case CisloSymbolu of
        1 : Polyline([Kotva,Point(Kotva.X,Myska.Y),
                      Myska,Point(Myska.X,Kotva.Y),Kotva]);
        2,3 : Polyline([Kotva, Myska]);
        5 : Polyline([Kotva, Point(Myska.X,Kotva.Y), Myska]);
      end;
      Pen.Style := psSolid;
      DelejInvalidu_99;
    end;
  end; }
end;

procedure TFrForm99.DelejPohniViceTrubkami(ABod : TPoint; Kreslit, KonecRotace : boolean);

{Procedure AKresli(TT : TAmiClass);
var
  AB1, AB2 : TPoint;
begin
  DelejSpocAbsBodik(PocAmi, TT.Pocatek, KoefZvetseni, AB1);
  DelejSpocAbsBodik(PocAmi, TT.AbsKonec, KoefZvetseni, AB2);
end;}

var
  i : integer;
  AT : TAmiClass;
  BBod : TPoint;
begin
  for i := 0 to ATopChlad.VybList.Count-1 do begin
    AT := ATopChlad.VybList[i];
    PaintBox1.Canvas.Pen.Mode := pmXOR;
    DelejPohniObjektyNaTrubce(ABod, AT, AT.Orientace<0 ,TRUE, KonecRotace);

    PaintBox1.Canvas.Pen.Mode := pmXOR;
    if Kreslit then AT.KreslAbs(PaintBox1.Canvas, Point(0, 0));
    if AT.Orientace>0 then begin
      BBod := AT.AbsKonec;
      AT.Pocatek := ABod;
      AT.AbsKonec := BBod;
    end else begin
      AT.AbsKonec := ABod;
    end;
    AT.AbsObd(KoefZvetseni, PocAmi);
    AT.PraveVlozeny := TRUE;

    ATopChlad.ZmenaProjektu := TRUE;
    PaintBox1.Canvas.Pen.Mode := pmXOR;
    if Kreslit then AT.KreslAbs(PaintBox1.Canvas, Point(0, 0));

    {    if NOT Kreslit then begin
      if AT.Orientace>0 then begin
        BBod := AT.AbsKonec;
        AT.Pocatek := ABod;
        AT.AbsKonec := BBod;
      end else begin
        AT.AbsKonec := ABod;
      end;
      ZmenaProjektu := TRUE;
    end; }

    {    if Kreslit then begin
      AC.AbsObd(KoefZvetseni, PocAmi);
      AC.KreslAbs(PaintBox1.Canvas, Point(0, 0));
    end; }

  end;
end;

Procedure TFrForm99.KresliSymbol(Canvas : TCanvas; var Bodik : TPoint;
         SH : TShiftState; Pohnul, jak : boolean);

Procedure AA(ABod : TPoint);
var
  AVX, AVY : integer;
begin
  with Canvas do begin
    Pen.Color := clWhite;
    Polyline([Kotva, ABod]);
    if (CisloCimJede_99=-TypPopisTru1) OR (CisloCimJede_99=-TypPopisTru2) OR
       (CisloCimJede_99=-TypPopisTru3) OR (CisloCimJede_99=-TypPopisTru4) OR
       (CisloCimJede_99=-TypPopisTru5) OR (CisloCimJede_99=-TypAmiText2) OR
       (CisloSymbolu=31){ in [31..34])} then begin
      if CisloCimJede_99<0 then
        CisloSymbolu := 3;

      with ATopChlad do begin
        if (AktAmiOzn<>NIL) AND
           ((AktAmiOzn is TAmiPopis) OR (AktAmiOzn is TAmiTextik)) then begin
          with AktAmiOzn do begin
            AVX := ABod.X-AbsPoc.X;
            AVY := ABod.Y-AbsPoc.Y;
            Polyline([Point(AbsHoLe.X+AVX,AbsHoLe.Y+AVY),
                      Point(AbsHoLe.X+AVX,AbsDoPr.Y+AVY),
                      Point(AbsDoPr.X+AVX,AbsDoPr.Y+AVY),
                      Point(AbsDoPr.X+AVX,AbsHoLe.Y+AVY),
                      Point(AbsHoLe.X+AVX,AbsHoLe.Y+AVY)]);
          end;

        end else begin
          AVY := Round(200*(KoefZvetseni*JMetrMM));
          AVX := Round(250*(KoefZvetseni*JMetrMM));
          if ABod.X>=Kotva.X then begin
            Polyline([ABod,Point(ABod.X+AVX,ABod.Y),
                      Point(ABod.X+AVX,ABod.Y-AVY),Point(ABod.X,ABod.Y-AVY),
                      ABod]);
          end else begin
            Polyline([ABod,Point(ABod.X-AVX,ABod.Y),
                      Point(ABod.X-AVX,ABod.Y-AVY),Point(ABod.X,ABod.Y-AVY),
                      ABod]);
          end;
        end;
      end;  // with ATopChlad
    end;
  end;
end;

Procedure PrepocitejPolohuPopisu1(AmiClass : TAmiClass; Koef : extended);
var
  i : integer;
  AC, AP : TAmiClass;
begin
  if AmiClass is TAmiSchema then
    with AmiClass as TAmiSchema do begin
      for i := 0 to Seznam3.Count-1 do begin
        AC := Seznam3[i];
        if AC is TAmiVenti1 then begin

        end;
      end;
    end;
end;

var
  KoefSirka, KoefVyska : integer;
  SchemaOkraj, MinSchv : integer;
  OtocilSchema : boolean;
  SX, SY : integer;
  KladnaOrientace : boolean;
  NaselCilPneuH : integer;

  // pro roztazeni PneuH
  KoefVysPneuH : extended;

  KresliObd, KresliCaru1, KresliCaru2, KresliCaru3, KresliCaru4 : boolean;
  KresliPulObd : boolean;
  KresliElipsu : boolean;
  KresliVenti4 : boolean;
  KresliOblouk : boolean;

  // pro roztazeni nebo stlaceni rozvodnych ventilu
  Bod, Boe, BoP, BoK : TPoint;
  PocPrip : integer;
  DifV : integer;
  AUhel1, AUhel2 : extended;
  AOrientace : ShortInt;
  AVX, AVY : integer;

  Ve1, Ve2 : TPoint;
  TypAmiOzn : integer;

  i : integer;
  AC, AP : TAmiClass;
  AM : TAmiClass;
begin
  TypAmiOzn := -1;
  with Canvas do begin
    Pen.Mode := pmXOR;
    case CisloCimJede_99 of
      -TypClipboard : ZobrazAbsList(JakobyClipboard, Bodik);
      -TypRad1-20..-TypRad1 : PosRad1.KreslAbs(PaintBox1.Canvas, Bodik);
      -TypRad2-15..-TypRad2 : PosRad2.KreslAbs(PaintBox1.Canvas, Bodik);
      -TypChladic1-5..-TypChladic1 : PosChladic1.KreslAbs(PaintBox1.Canvas, Bodik);
      -TypOTChladic1-5..-TypOTChladic1 : PosOTChladic1.KreslAbs(PaintBox1.Canvas, Bodik);
      -TypObecnaPataC-4..-TypKotel : PosKotel.KreslAbs(PaintBox1.Canvas, Bodik);
      -TypSchema0-15..-TypSchema0 : PosSchema.KreslAbs(PaintBox1.Canvas, Bodik);
      -TypPneuH-79..-TypPneuHStatico : PosPneuH.KreslAbs(PaintBox1.Canvas, Bodik);
//      -TypPneuH-79..-TypPneuH : PosPneuH.KreslAbs(PaintBox1.Canvas, Bodik);
{        AmiClass := TAmiRad2.Creatf(AmiLispik,Bodik,-CisloCimJede_99); }
{      end; }
      SymJedeKrizem : begin
        if NOT ZoomKrizem then begin
          Pen.Mode := pmNotXor;
          Brush.Color := clBlue;
          Brush.Style := bsClear;
          Pen.Width := 1;
          Pen.Color := clGreen;
          MoveTo(Bodik.X, 0);
          LineTo(Bodik.X, PaintBox1.Height);
          MoveTo(0, Bodik.Y);
          LineTo(PaintBox1.Width, Bodik.Y);
        end;
      end;

    end;
    if (ssLeft in SH) AND PohnulMysivPB then begin
      Pen.Style := psDot;
      Pen.Width := 1;
{      Pen.Color := clDkGray; }
      Pen.Color := BarvaPozadiObr;
      Brush.Style := bsClear;


      JeRovnaCara := FALSE;
      with ATopChlad do begin
        if PohnoutViceTrubkami then begin
          DelejSpocitejBodGrid(PocAmi,Myska,Griq,KoefZvetseni,Bod);
          DelejPohniViceTrubkami(Bod, TRUE, Jak);
        end else begin
          if PohnoutViceRadKot then begin
            DelejSpocitejBodGrid(PocAmi,Myska,Griq,KoefZvetseni,Bod);
            DelejPohniViceKotRad(Bod, 1, TRUE, Jak);
          end else begin
            if (CisloSymbolu>=0) AND (CisloSymbolu<10) then begin
              CisloSymbolu := 0;
              KresliObd :=
                ((CisloCimJede_99=0) AND (AktAmiOzn=NIL) AND (AktAmiPom=NIL)) OR
                (CisloCimJede_99=-TypPokoj) OR
                (CisloCimJede_99=-TypStrop2) OR
                (CisloCimJede_99=-TypAmiObdelnik);
              if KresliObd then begin
                CisloSymbolu := 1;
                Polyline([Kotva,Point(Kotva.X,Bodik.Y),
                          Bodik,Point(Bodik.X,Kotva.Y),Kotva]);
              end;

              KresliCaru1 := (CisloCimJede_99=-TypTrubka1) OR
                             (CisloCimJede_99=-TypTrubka2) OR
                             (CisloCimJede_99=-TypTrubka0) OR
                             (CisloCimJede_99=-TypTrubka3) OR
                             (CisloCimJede_99=-TypTrubka4) OR

                             (CisloCimJede_99=-TypAmiCara) OR  // pridano sem
                             (CisloCimJede_99=-TypTrubkaCara1) OR
                             (CisloCimJede_99=-TypTrubkaCara2) OR
                             (CisloCimJede_99=-TypTrubkaCara3) OR
                             (CisloCimJede_99=-TypTrubkaCara4) OR
                             (CisloCimJede_99=-TypTrubkaCara5) OR
                             (CisloCimJede_99=-TypTrubkaCara6) OR
                             (CisloCimJede_99=-TypTrubkaCara7) OR
                             (CisloCimJede_99=-TypTrubkaCara8) OR
                             (CisloCimJede_99=-TypTrubkaCara9) OR
                             (CisloCimJede_99=-TypTrubkaCara10);
  // cara povolena je vodorovne nebo svisle.
              if KresliCaru1 then begin
                CisloSymbolu := 2;
      {          if NOT ShDnMovePB then
                  Polyline([Kotva, Bodik]); }
                JeRovnaCara := FALSE;
                if NOT (ssShift in SH) then begin
                  if Pohnul then begin
                    if Abs(Bodik.X-Kotva.X)>=Abs(Bodik.Y-Kotva.Y) then begin
                      Bodik.Y := Kotva.Y;
                    end else begin
                      Bodik.X := Kotva.X;
                    end;
                    JeRovnaCara := TRUE;
                  end;
                end;

                Polyline([Kotva, Bodik]);
              end;

              KresliCaru2 := (CisloCimJede_99=-TypPopisTru1) OR
                             (CisloCimJede_99=-TypPopisTru2) OR
                             (CisloCimJede_99=-TypPopisTru3) OR
                             (CisloCimJede_99=-TypPopisTru4) OR
                             (CisloCimJede_99=-TypPopisTru5) OR
                             (CisloCimJede_99=-TypAmiText2);
              if KresliCaru2 then begin
                CisloSymbolu := 3;
                AA(Bodik);
              end;

              KresliCaru3 := (CisloCimJede_99=-TypAmiText3){ OR
                             (CisloCimJede_99=-TypAmiCara) OR
                             (CisloCimJede_99=-TypTrubkaCara1) OR
                             (CisloCimJede_99=-TypTrubkaCara2) OR
                             (CisloCimJede_99=-TypTrubkaCara3) OR
                             (CisloCimJede_99=-TypTrubkaCara4) OR
                             (CisloCimJede_99=-TypTrubkaCara5)};
              if KresliCaru3 then begin
                CisloSymbolu := 2;
                Polyline([Kotva, Bodik]);
              end;

              KresliCaru4 := FALSE; {  (CisloCimJede_99=-TypPopisTru2); }
              if KresliCaru4 then begin
                CisloSymbolu := 2;

                if NOT (ssShift in SH) then begin
                  if Abs(Bodik.X-Kotva.X)>=Abs(Bodik.Y-Kotva.Y) then begin
                    Bodik.Y := Kotva.Y;
                  end else begin
                    Bodik.X := Kotva.X;
                  end;
                end;

                Polyline([Kotva, Bodik]);
              end;

              KresliPulObd := (CisloCimJede_99=-TypTrubkaOV);
              if KresliPulObd then begin
                Polyline([Kotva, Point(Bodik.X,Kotva.Y), Bodik]);
              end;

              KresliElipsu := (CisloCimJede_99=-TypAmiOblouk1);
              if KresliElipsu then begin
                if (ssCtrl in SH) then begin
                  // pokud drzi Ctrl, dela kruznici
                  if Abs(Bodik.X-Kotva.X)>=Abs(Bodik.Y-Kotva.Y) then begin
                    if Bodik.Y<Kotva.Y then Bodik.Y := Kotva.Y-Abs(Bodik.X-Kotva.X)
                                       else Bodik.Y := Kotva.Y+Abs(Bodik.X-Kotva.X);
                  end else begin
                    if Bodik.X<Kotva.X then Bodik.X := Kotva.X-Abs(Bodik.Y-Kotva.Y)
                                       else Bodik.X := Kotva.X+Abs(Bodik.Y-Kotva.Y);
                  end;
                end;
                { ohranicujici obdelnik }
                Polyline([Kotva,Point(Kotva.X,Bodik.Y),
                          Bodik,Point(Bodik.X,Kotva.Y),Kotva]);
                Ellipse(Kotva.X, Kotva.Y, Bodik.X, Bodik.Y);
              end;

              KresliVenti4 := (CisloCimJede_99>=-TypVenti4-20) AND
                              (CisloCimJede_99<=-TypVenti4);
              if KresliVenti4 then begin
                Polyline([Kotva, Bodik]);

    {            Polyline([Kotva,Point(Kotva.X,Bodik.Y),
                          Bodik,Point(Bodik.X,Kotva.Y),Kotva]); }
              end;

              KresliOblouk := (CisloCimJede_99=-TypAmiOblouk2);
              if KresliOblouk then begin
                case CitacKlikuObloucku of
                  1 : begin
                    case JakObloucek of
                      0 : OblKruznice(PaintBox1.Canvas, RObloucku, StredObloucku);
                      1 : OblUsecka(PaintBox1.Canvas, BodObloucku1, BodObloucku2);
                    end;
                  end;
                  2, 3 : begin
                    Obloucek(PaintBox1.Canvas, RObloucku, StredObloucku, Alf1Obloucku, Alf2Obloucku);
                    if JakObloucek=1 then
                      BodyTetivy(PaintBox1.Canvas, BodObloucku1, BodObloucku2);
                  end;
                end;
              end;

            end else begin
              if Assigned(AktAmiOzn) then
                TypAmiOzn := AktAmiOzn.Typ;

              DelejSpocitejBodGrid(PocAmi, Myska, Griq, KoefZvetseni, Bod);

              case CisloSymbolu of
                11..14, SymUpravStropy, SymOblastProTisk, SymDelejZoomLupa :
                                   Polyline([Kotva,Point(Kotva.X,Bodik.Y),
                                   Bodik,Point(Bodik.X,Kotva.Y),Kotva]);
                15 ,17  : Polyline([Kotva,Kotvb, Point(Kotvb.X,Bodik.Y),
                                    Point(Kotva.X,Bodik.Y), Kotva]);
                16, 18  : Polyline([Kotva,Kotvb, Point(Bodik.X,Kotvb.Y),
                                    Point(Bodik.X,Kotva.Y), Kotva]);

                SymDelejZoomKriz : begin
                  if ZoomKrizem then begin
                    Pen.Mode := pmNotXor;
                    Pen.Style := psSolid;
                    Brush.Color := clBlue;
                    Brush.Style := bsClear;
                    Pen.Color := clGreen;
                    Polyline([Kotva, Point(Kotva.X, Bodik.Y),
                       Bodik, Point(Bodik.X, Kotva.Y), Kotva]);

                  end;
                end;

                21..24 : begin
       {           if NOT ShDnMovePB then
                    Polyline([Kotva, Bodik]); }
      {              AA(Bodik); }

                  if  NOT (ssShift in SH) then begin
  //                  if (Abs(Myska.X-PointMousePaintboxDown.X)>2) OR
  //                     (Abs(Myska.Y-PointMousePaintboxDown.Y)>2) then begin
  //                  if (Abs(Bodik.X-PointMousePaintboxDown.X)>2) OR
  //                     (Abs(Bodik.Y-PointMousePaintboxDown.Y)>2) then begin
                    if Pohnul then begin
                      if Abs(Bodik.X-Kotva.X)>=Abs(Bodik.Y-Kotva.Y) then begin
                        Bodik.Y := Kotva.Y;
                      end else begin
                        Bodik.X := Kotva.X;
                      end;
                    end;
                  end;

                  Polyline([Kotva, Bodik]);
                  if AktAmiOzn is TAmiTrubka then begin
                    DelejSpocRealBodik(PocAmi, Bodik, KoefZvetseni, Bod);
      {              if jak then }
                      DelejPohniObjektyNaTrubce(Bod, AktAmiOzn, CisloSymbolu=23,
                        Jak, FALSE);  // at to nakresli

                    AM := AmiLispik.NajdiTrubkuBod(Bod, EpsilonRel, AktAmiOzn.Typ);
                    DelejMoveAmi_99(AM);
                  end;
                end;

                31..34 : begin
      //              AA(Bodik);
      {            if  ssShift in SH then begin
                    if Abs(Bodik.X-Kotva.X)>=Abs(Bodik.Y-Kotva.Y) then begin
                      Bodik.Y := Kotva.Y;
                    end else begin
                      Bodik.X := Kotva.X;
                    end;
                  end; }
                  AA(Bodik);
                  if (CisloSymbolu=33) AND // hybe drzatkem popisu, hleda trubku
                    (AktAmiOzn is TAmiPopis) AND
                    (AktAmiOzn.Typ-TypPopisTru1 in [0..5]) then begin
                    DelejSpocRealBodik(PocAmi, Bodik, KoefZvetseni, Bod);
                    AM := AmiLispik.NajdiTrubkuBod(Bod, EpsilonRel, 0);
                    DelejMoveAmi_99(AM);
                  end;
                end;

                26, 28 : Polyline([Kotva, Point(Bodik.X, Kotva.Y), Bodik]);

                27, 29 : Polyline([Kotva, Point(Kotva.X, Bodik.Y), Bodik]);

                35 : if (AktAmiOzn<>NIL){ AND jak }then begin
                  AVX := Bodik.X-AktAmiOzn.AbsPoc.X;
                  AVY := Bodik.Y-AktAmiOzn.AbsPoc.Y;
                  if Abs(AVX)>=Abs(AVY) then begin
                    if AVX>=0 then AOrientace := 0 else AOrientace := 2;
                  end else begin
                    if AVY>=0 then AOrientace := 3 else AOrientace := 1;
                  end;
                  if AktAmiOzn.Orientace<>AOrientace then begin
                    if AktAmiOzn is TAmiPopis then
                      with AktAmiOzn as TAmiPopis do
                        JenSpocitat := TRUE;
                    if AktAmiOzn is TAmiTextik then
                      with AktAmiOzn as TAmiTextik do
                        JenSpocitat := TRUE;

                    AktAmiOzn.Kresli(Canvas,KoefZvetseni,0,PocAmi);
                    AktAmiOzn.KreslAbs(PaintBox1.Canvas, Point(0,0));
                    AktAmiOzn.Orientace := AOrientace;
                    AktAmiOzn.Kresli(Canvas,KoefZvetseni,0,PocAmi);
                    AktAmiOzn.KreslAbs(PaintBox1.Canvas, Point(0,0));

                    if AktAmiOzn is TAmiPopis then
                      with AktAmiOzn as TAmiPopis do
                        JenSpocitat := FALSE;
                    if AktAmiOzn is TAmiTextik then
                      with AktAmiOzn as TAmiTextik do
                        JenSpocitat := FALSE;
                  end;

                end;
                { otoceni ventilu nebo fitinku o 180 }
                41 : if AktAmiOzn<>NIL then begin

                  if jak then begin
                    DelejSpocRealBodik(PocAmi,Bodik,KoefZvetseni,Bod);
                    with AktAmiOzn do begin
                      Ve1 := Point(BodyUch[1].X-Pocatek.X, BodyUch[1].Y-Pocatek.Y);
                      Ve2 := Point(Bod.X-Pocatek.X, Bod.Y-Pocatek.Y);
                      if AktAmiOzn.Typ=TypVentiPneuHSafetyValve then begin
                        // otaci se kolem svisle osy
                        Ve1 := Point(BodyUch[1].X-Pocatek.X, 0);
                        Ve2 := Point(Bod.X-Pocatek.X, 0);
                      end;
                      if Ve1.X*Ve2.X+Ve1.Y*Ve2.Y<0 then begin
                        AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                        AktAmiOzn.Orientace := 1-AktAmiOzn.Orientace;
                        AktAmiOzn.Kresli(NIL, KoefZvetseni, 4, PocAmi);
                        AktAmiOzn.KreslAbs(Canvas, Point(0, 0));

                      end;
                    end;
    {                AUhel2 := ArcTan2(AktAmiOzn.BodyUch.Y-AktAmiOzn.Pocatek.Y,Bod.X-AktAmiOzn.Pocatek.X);}

    {                AUhel1 := ArcTan2(Bod.Y-AktAmiOzn.Pocatek.Y,Bod.X-AktAmiOzn.Pocatek.X);
                    AUhel2 := AktAmiOzn.Alfa;

                    if AUhel1<>AUhel2 then
                      AktAmiOzn.Orientace := 1-AktAmiOzn.Orientace; }
                  end;
                    {            AktAmiOzn.KreslAbs(Canvas, Point(0,0)); }

                end;

                42 : begin
                  Polyline([Kotva, Bodik]);
                  if PorovnejBody(AKatva, AKatvb) then begin
                    DelejSpocRealBodik(PocAmi, Bodik, KoefZvetseni, Bod);
                    AM := AmiLispik.DotazExcl(Bod, EpsilonRel, AktAmiOzn);
                    if Assigned(AM) then begin
                      if (AM.Typ=TypTrubka1) OR (AM.Typ=TypTrubka2) OR
                         (AM.Typ=TypTrubka3) OR (AM.Typ=TypTrubka4) OR
                         (((AM.Typ-TypVentBalancni) in [0{, 1, 3}]) AND
                          ((AM.AmCm=NIL) OR (AM.AmCm=AktAmiOzn))) then begin
                        DelejMoveAmi_99(AM);
                        if Assigned(AktAmiOzn) then begin

                          AktAmiOzn.AmCm := AM;
                        end;
                      end else begin
                        DelejMoveAmi_99(NIL);
                        if Assigned(AktAmiOzn) then
                          AktAmiOzn.AmCm := NIL;
                      end;
                    end else begin
                      DelejMoveAmi_99(NIL);
                      if Assigned(AktAmiOzn) then
                        AktAmiOzn.AmCm := NIL;
                    end;
                  end else begin
                    Polyline([Kotvb, Bodik]);
                  end;
                end;

                46 : if AktAmiOzn<>NIL then begin
                  // TAmiKotel
                  if jak then begin
                    DelejSpocRealBodik(PocAmi,Bodik,KoefZvetseni,Bod);
                    with AktAmiOzn do begin
                      if (Bod.X>AktAmiOzn.Pocatek.X) AND (Bod.X<AktAmiOzn.AbsKonec.X) then begin
                        Ve1 := Point(Bod.X-BodyUch[1].X, 0);
                        Ve2 := Point(AktAmiOzn.Pocatek.X+AktAmiOzn.RelKonec.X div 2-Bod.X, 0);
                        if Ve1.X*Ve2.X+Ve1.Y*Ve2.Y<0 then begin

                          AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                          case AktAmiOzn.Orientace of
                            0 : AktAmiOzn.Orientace := 2;
                            1 : AktAmiOzn.Orientace := 3;
                            2 : AktAmiOzn.Orientace := 0;
                            3 : AktAmiOzn.Orientace := 1;
                          end;
                          AktAmiOzn.ZmenTyp(AktAmiOzn.Typ);
                          AktAmiOzn.Kresli(NIL, KoefZvetseni, 4, PocAmi);
                          AktAmiOzn.KreslAbs(Canvas, Point(0, 0));

                        end;
                      end;
                    end;
                  end;
                end;

                47 : if AktAmiOzn<>NIL then begin   // obecna pata
                  if jak then begin
                    DelejSpocRealBodik(PocAmi, Bodik, KoefZvetseni, Bod);
                    with AktAmiOzn do begin
                      if (Bod.X>AktAmiOzn.Pocatek.X) AND (Bod.X<AktAmiOzn.AbsKonec.X) then begin
                        Ve1 := Point(Bod.X-BodyUch[2].X, 0);
                        Ve2 := Point(AktAmiOzn.Pocatek.X+AktAmiOzn.RelKonec.X div 2-Bod.X, 0);
                        if Ve1.X*Ve2.X+Ve1.Y*Ve2.Y<0 then begin

                          AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                          case AktAmiOzn.Orientace of
                            0 : AktAmiOzn.Orientace := 1;
                            2 : AktAmiOzn.Orientace := 3;
                            1 : AktAmiOzn.Orientace := 0;
                            3 : AktAmiOzn.Orientace := 2;
                          end;
                          AktAmiOzn.ZmenTyp(AktAmiOzn.Typ);
                          AktAmiOzn.Kresli(NIL, KoefZvetseni, 4, PocAmi);
                          AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                        end;
                      end;
                    end;
                  end;
                end;
          //            Venti4
                50..54, 121, 123 : begin
                  Polyline([Kotva, Bodik]);
                end;

                61..64 : begin { oblouk }
                  Ellipse(Kotva.X, Kotva.Y, Bodik.X, Bodik.Y);
                  { radsi jeste ohranicujici obdelnik }
                  Polyline([Kotva,Point(Kotva.X,Bodik.Y),
                            Bodik,Point(Bodik.X,Kotva.Y),Kotva]);
                end;
                65, 67  : begin   { svisle }
                  Ellipse(Kotva.X, Kotva.Y, Kotvb.X, Bodik.Y);
                  Polyline([Kotva,Kotvb, Point(Kotvb.X,Bodik.Y),
                            Point(Kotva.X,Bodik.Y), Kotva]);
                end;
                66, 68  : begin   { vodorovne }
                  Ellipse(Kotva.X, Kotva.Y, Bodik.X, Kotvb.Y);
                  Polyline([Kotva,Kotvb, Point(Bodik.X,Kotvb.Y),
                            Point(Bodik.X,Kotva.Y), Kotva]);
                end;

                // otoceni PneuH kolem svisle osy
                71 : if AktAmiOzn<>NIL then begin  // PneuH zvetseni nebo zmenseni
                  if jak then begin
                    DelejSpocRealBodik(PocAmi, Bodik, KoefZvetseni, Bod);
//                    if (Bod.X>AktAmiOzn.Pocatek.X) AND(Bod.X<AktAmiOzn.AbsKonec.X) then begin
                    if (Bod.X>AktAmiOzn.HL.X) AND(Bod.X<AktAmiOzn.DP.X) then begin
                      with AktAmiOzn do begin
                        Ve1 := Point(Abs(Bod.X-BodyUch[1].X), 0);
         //               Ve2 := Point(AktAmiOzn.AbsKonec.X-Bod.X, 0);
         //               if Ve1.X*Ve2.X+Ve1.Y*Ve2.Y<0 then begin
//                        if Ve1.X>AktAmiOzn.RelKonec.X div 2 then begin
                        if Ve1.X>(AktAmiOzn.DP.X-AktAmiOzn.HL.X) div 2 then begin
                          AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                          case AktAmiOzn.Orientace of
                            0 : AktAmiOzn.Orientace := 2;
                            1 : AktAmiOzn.Orientace := 3;
                            2 : AktAmiOzn.Orientace := 0;
                            3 : AktAmiOzn.Orientace := 1;
                          end;
                          AktAmiOzn.Kresli(NIL, KoefZvetseni, 4, PocAmi);
                          AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                        end;
                      end;
                    end;
                  end;

                end;

                // zmena velikosti PneuH tazenim svisle
                72 : if AktAmiOzn is TAmiPneuH then begin
                  if jak then begin
                    DelejSpocRealBodik(PocAmi, Bodik, KoefZvetseni, Bod);
//                    if AktAmiOzn.Orientace in [0, 2] then begin
                    if TRUE then begin
                      Ve1 := Point(0, Bod.Y-AktAmiOzn.Pocatek.Y);
                      AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                      TAmiPneuH(AktAmiOzn).Vyska := Ve1.Y;
                      AktAmiOzn.Kresli(NIL, KoefZvetseni, 4, PocAmi);
                      AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                    end else begin
                      Ve1 := Point(0, AktAmiOzn.AbsKonec.Y-Bod.Y);
                      AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                      TAmiPneuH(AktAmiOzn).Vyska := Ve1.Y;
                      AktAmiOzn.Pocatek := Point(AktAmiOzn.Pocatek.X, Bod.Y);
                      AktAmiOzn.Kresli(NIL, KoefZvetseni, 4, PocAmi);
                      AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                    end;
                  end;
                end;

                // otoceni PneuH (jen PneuHInterVesselDD) kolem vodorovne osy
                73 : if AktAmiOzn<>NIL then begin  // PneuH zvetseni nebo zmenseni
                  if jak then begin
                    DelejSpocRealBodik(PocAmi, Bodik, KoefZvetseni, Bod);
                    if (Bod.Y>AktAmiOzn.Pocatek.Y) AND(Bod.Y<AktAmiOzn.AbsKonec.Y) then begin
                      with AktAmiOzn do begin
//                        BoK
                        Ve1 := Point(0, Abs(Bod.Y-BodyUch[4].Y));
//                        Ve2 := Point(0, BodyUch[2].Y-Bod.Y);
//                        if Ve1.X*Ve2.X+Ve1.Y*Ve2.Y<0 then begin
                        AOrientace := Orientace;
                        if Ve1.Y>RelKonec.Y div 2 then begin
                          case Orientace of
                            0 : AOrientace := 1;
                            1 : AOrientace := 0;
                            2 : AOrientace := 3;
                            3 : AOrientace := 2;
                          end;
//                        end;
//                        if Ve2.Y<RelKonec.Y div 2 then begin
//                        end else begin
//                          case Orientace of
//                          end;
                        end;
                        if AOrientace<>Orientace then begin
                          KreslAbs(Canvas, Point(0, 0));
                          Orientace := AOrientace;
                          Kresli(NIL, KoefZvetseni, 4, PocAmi);
                          KreslAbs(Canvas, Point(0, 0));
                        end;
                      end;
                    end;
                  end;

                end;

                74 : begin
                  if AktAmiOzn is TAmiPneuH then begin
                    for I := 0 to OznList.Count-1 do begin
                      AC := OznList[i];
                      if (AC is TAmiVentiPneuH) AND (AC.AnCl=AktAmiOzn) then begin
                        if (TAmiVentiPneuH(AC).CilKapilary=CisloBoduKapilary+2) then begin
                          AUhel1 := ArcTan2(Bod.Y-AKatva.Y, Bod.X-AKatva.X);
//                          AUhel1 := UpravAlfaAAAVent1(AC.Orientace, AUhel1);
                          OtocObjektemAC(AC, AKatva, AUhel1, TRUE);
                        end;
                      end;
                    end;

                    Pen.Mode := pmXor;
                    Pen.Style := psDot;
                    Polyline([Kotva, Bodik]);
                    if PorovnejBody(AKatva, AKatvb) then begin
                      DelejSpocRealBodik(PocAmi, Bodik, KoefZvetseni, Bod);
                      AM := AmiLispik.DotazExcl(Bod, EpsilonRel, AktAmiOzn);
                      with AktAmiOzn as TAmiPneuH do begin
                        NaselCilPneuH := JePripustnyCilAmi(AM, CisloBoduKapilary);
                        case NaselCilPneuH of
                          -3, -4 : begin
                             AM := NIL;
                             AktAmiOzn.AmCm := NIL;
                          end;
                          -1, -2 : begin
                             AM := NIL;
                             AktAmiOzn.AmCl := NIL;
                          end;
                          1 : begin
                            // satra koncovym bodem Kapilarb1
                            if AM is TAmiPneuH then
                              // ma byt pripojen na "telo"
                              if NOT TAmiPneuH(AM).DotazPneuH(Bod, EpsilonRel) then
                                AM := NIL;
                            AktAmiOzn.AmCl := AM;
                          end;

                          2 : begin
                            if AM is TAmiPneuH then begin
                              // ma byt pripojen na kapilarb1 (nebo na kapilarb2)
//                              if NOT TAmiPneuH(AM).DotazKapilarb1(Bod, EpsilonRel) then begin
                              if TAmiPneuH(AM).DotazKapilarb1(Bod, EpsilonRel)=0 then begin
                                if (Typ-TypPneuHInterVessel) in [0, 1, 2] then begin
                                  if TAmiPneuH(AM).DotazKapilarb2(Bod, EpsilonRel)=0 then
                                    AM := NIL;
                                end else begin
                                  AM := NIL;
                                end;
                              end;
                            end;
                            AktAmiOzn.AmCl := AM;
                          end;

                          3 : begin
                            // satra koncovym bodem Kapilarb2
                            if AM is TAmiPneuH then
                              // ma byt pripojen na "telo"
                              if NOT TAmiPneuH(AM).DotazPneuH(Bod, EpsilonRel) then
                                AM := NIL;
                            AktAmiOzn.AmCm := AM;
                          end;

                          4 : begin
                            if AM is TAmiPneuH then begin
                              // ma byt pripojen na kapilarb2
                              if TAmiPneuH(AM).DotazKapilarb2(Bod, EpsilonRel)=0 then begin
                                AM := NIL;
                              end;
                            end;
                            AktAmiOzn.AmCm := AM;
                          end;
                        end;

                        DelejMoveAmi_99(AM);
                      end;
                    end else begin
                      for I := 0 to OznList.Count-1 do begin
                        AC := OznList[i];
                        if (AC is TAmiVentiPneuH) AND (AC.AnCl=AktAmiOzn) then begin
                          if (TAmiVentiPneuH(AC).CilKapilary=CisloBoduKapilary+3) then begin
                            AUhel2 := ArcTan2(Bod.Y-AKatvb.Y, Bod.X-AKatvb.X);
//                            AUhel2 := UpravAlfaAAAVent1(AC.Orientace, AUhel2);
                            OtocObjektemAC(AC, AKatvb, AUhel2, TRUE);
                          end;
                        end;
                      end;
                      Pen.Mode := pmXor;
                      Pen.Style := psDot;
                      Polyline([Kotvb, Bodik]);
                    end;
                  end;
                end;

                81..88 : Obloucek(PaintBox1.Canvas, RObloucku, StredObloucku, Alf1Obloucku, Alf2Obloucku);

                { otoceni venti2 zrcadlove kolem svisle osy }
                91..98 : if AktAmiOzn<>NIL then begin

                  if jak then begin
                    DelejSpocRealBodik(PocAmi,Bodik,KoefZvetseni,Bod);
                    with AktAmiOzn do begin
                      Ve1 := Point(BodyUch[1].X-Pocatek.X, 0);
                      Ve2 := Point(Bod.X-Pocatek.X, 0);
                      if Ve1.X*Ve2.X+Ve1.Y*Ve2.Y<0 then begin
                        AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                        AktAmiOzn.Kresli(NIL, KoefZvetseni, 4, PocAmi);
                        if AktAmiOzn.Orientace>=0 then AktAmiOzn.Orientace := -1
                                                  else AktAmiOzn.Orientace := 0;
                        AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                      end;
                    end;
                  end;

                end;

                // otoceni schematu kolem svisle osy
                101 : if AktAmiOzn<>NIL then begin
                  if jak then begin
                    if AktAmiOzn.Orientace<=3 then begin
                      KoefSirka := Griq.X*Round(SchemaSirka*TAmiSchema(AktAmiOzn).KoeficientZv/Griq.X);
                    end else begin
                      KoefSirka := Griq.X*Round(SchemaVyska*TAmiSchema(AktAmiOzn).KoeficientZv/Griq.X);
                    end;
                    DelejSpocRealBodik(PocAmi, Bodik, KoefZvetseni, Bod);
                    if (Bod.X>AktAmiOzn.Pocatek.X) AND(Bod.X<AktAmiOzn.Pocatek.X+KoefSirka) then begin
                      with AktAmiOzn do begin
                        Ve1 := Point(Bod.X-BodyUch[1].X, 0);
                        Ve2 := Point(AktAmiOzn.Pocatek.X+KoefSirka div 2-Bod.X, 0);
                        if Ve1.X*Ve2.X+Ve1.Y*Ve2.Y<0 then begin

                          AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                          case AktAmiOzn.Orientace of
                            0 : AktAmiOzn.Orientace := 2;
                            1 : AktAmiOzn.Orientace := 3;
                            2 : AktAmiOzn.Orientace := 0;
                            3 : AktAmiOzn.Orientace := 1;
                            4 : AktAmiOzn.Orientace := 6;
                            5 : AktAmiOzn.Orientace := 7;
                            6 : AktAmiOzn.Orientace := 4;
                            7 : AktAmiOzn.Orientace := 5;
                          end;
                          TAmiSchema(AktAmiOzn).PrevratAbsSourPopisuSch(TRUE, FALSE);
                          TAmiSchema(AktAmiOzn).DejRelSourPopisuSch;
                          AktAmiOzn.Kresli(NIL, KoefZvetseni, 4, PocAmi);
                          AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                        end;
                      end;
                    end;
                  end;

                end;

                // otoceni schematu kolem vodorovne osy
                102 : if AktAmiOzn<>NIL then begin
                  if jak then begin
                    if AktAmiOzn.Orientace<=3 then begin
                      KoefVyska := Griq.Y*Round(SchemaVyska*TAmiSchema(AktAmiOzn).KoeficientZv/Griq.Y);
                    end else begin
                      KoefVyska := Griq.Y*Round(SchemaSirka*TAmiSchema(AktAmiOzn).KoeficientZv/Griq.Y);
                    end;
                    DelejSpocRealBodik(PocAmi, Bodik, KoefZvetseni, Bod);
                    if (Bod.Y>AktAmiOzn.Pocatek.Y) AND (Bod.Y<AktAmiOzn.Pocatek.Y+KoefVyska) then begin
                      with AktAmiOzn do begin
                        Ve1 := Point(0, Bod.Y-BodyUch[2].Y);
                        Ve2 := Point(0, AktAmiOzn.Pocatek.Y+KoefVyska div 2-Bod.Y);
                        if Ve1.X*Ve2.X+Ve1.Y*Ve2.Y<0 then begin
                          AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                          case AktAmiOzn.Orientace of
                            0 : AktAmiOzn.Orientace := 1;
                            1 : AktAmiOzn.Orientace := 0;
                            2 : AktAmiOzn.Orientace := 3;
                            3 : AktAmiOzn.Orientace := 2;
                            4 : AktAmiOzn.Orientace := 5;
                            5 : AktAmiOzn.Orientace := 4;
                            6 : AktAmiOzn.Orientace := 7;
                            7 : AktAmiOzn.Orientace := 6;
                          end;
                          TAmiSchema(AktAmiOzn).PrevratAbsSourPopisuSch(FALSE, TRUE);
                          TAmiSchema(AktAmiOzn).DejRelSourPopisuSch;
                          AktAmiOzn.Kresli(NIL, KoefZvetseni, 4, PocAmi);
                          AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                        end;
                      end;
                    end;
                  end;
                end;

                // zmena velikosti schematu tazenim vodorovne
                103 : if AktAmiOzn<>NIL then begin
                  if jak then begin
                    if AktAmiOzn.Orientace<=3 then begin
                      KoefSirka := Griq.X*Round(SchemaSirka*TAmiSchema(AktAmiOzn).KoeficientZv/Griq.X);
                      SchemaOkraj := SchemaOkrajX;
                      MinSchv := 100;
                    end else begin
                      KoefSirka := Griq.X*Round(SchemaVyska*TAmiSchema(AktAmiOzn).KoeficientZv/Griq.X);
                      SchemaOkraj := SchemaOkrajY;
                      MinSchv := 200;
                    end;
                    DelejSpocRealBodik(PocAmi, Bodik, KoefZvetseni, Bod);
  //                  with AktAmiOzn do begin
                    if (AktAmiOzn.Orientace in [0, 1, 4, 5]) then begin
                      Ve1 := Point(Bod.X-AktAmiOzn.BodyUch[1].X-2*SchemaOkraj, 0);
                      if (Ve1.X>MinSchv) then begin
                        Ve1.X := Griq.X*Round(Ve1.X/Griq.X);
                        AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                        TAmiSchema(AktAmiOzn).DejRelSourPopisuSch;
                        if AktAmiOzn.Orientace<=3 then begin
                          TAmiSchema(AktAmiOzn).KoeficientZv := Ve1.X/SchemaSirka;
                        end else begin
                          TAmiSchema(AktAmiOzn).KoeficientZv := Ve1.X/SchemaVyska;
                        end;
                        TAmiSchema(AktAmiOzn).KoeficientZv :=
                          0.001*Round(TAmiSchema(AktAmiOzn).KoeficientZv*1000);  // kvuli ukladani
                        AktAmiOzn.Kresli(NIL, KoefZvetseni, 4, PocAmi);
                        TAmiSchema(AktAmiOzn).DejRelSourPopisuSch;
                        AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                      end;
                    end;
                    if (AktAmiOzn.Orientace in [2, 3, 6, 7]) then begin
                      Ve1 := Point(AktAmiOzn.BodyUch[1].X-Bod.X-2*SchemaOkraj, 0);
                      if (Ve1.X>MinSchv) then begin
                        Ve1.X := Griq.X*Round(Ve1.X/Griq.X);
                        AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                        Bod := AktAmiOzn.AbsKonec;
                        TAmiSchema(AktAmiOzn).DejRelSourPopisuSch;
                        if AktAmiOzn.Orientace<=3 then begin
                          TAmiSchema(AktAmiOzn).KoeficientZv := Ve1.X/SchemaSirka;
                          TAmiSchema(AktAmiOzn).KoeficientZv :=
                            0.001*Round(TAmiSchema(AktAmiOzn).KoeficientZv*1000);  // kvuli ukladani
                          KoefSirka := Griq.X*Round(SchemaSirka*TAmiSchema(AktAmiOzn).KoeficientZv/Griq.X);
                        end else begin
                          TAmiSchema(AktAmiOzn).KoeficientZv := Ve1.X/SchemaVyska;
                          TAmiSchema(AktAmiOzn).KoeficientZv :=
                            0.001*Round(TAmiSchema(AktAmiOzn).KoeficientZv*1000);  // kvuli ukladani
                          KoefSirka := Griq.X*Round(SchemaVyska*TAmiSchema(AktAmiOzn).KoeficientZv/Griq.X);
                        end;
                        AktAmiOzn.Pocatek := Point(Bod.X-KoefSirka, AktAmiOzn.Pocatek.y);
                        AktAmiOzn.Kresli(NIL, KoefZvetseni, 4, PocAmi);
                        TAmiSchema(AktAmiOzn).DejRelSourPopisuSch;
                        AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                      end;
                    end;
  //                  SpocitatBodySpojTr := TRUE;
                  end;
                end;

                // zmena velikosti schematu tazenim svisle
                104 : if AktAmiOzn<>NIL then begin
                  if jak then begin
                    if AktAmiOzn.Orientace<=3 then begin
                      KoefVyska := Griq.X*Round(SchemaVyska*TAmiSchema(AktAmiOzn).KoeficientZv/Griq.X);
                      SchemaOkraj := SchemaOkrajY;
                      MinSchv := 200;
                    end else begin
                      KoefVyska := Griq.X*Round(SchemaSirka*TAmiSchema(AktAmiOzn).KoeficientZv/Griq.X);
                      SchemaOkraj := SchemaOkrajX;
                      MinSchv := 100;
                    end;
                    DelejSpocRealBodik(PocAmi, Bodik, KoefZvetseni, Bod);
                    if (AktAmiOzn.Orientace in [0, 2, 4, 6]) then begin
                      Ve1 := Point(0, Bod.Y-AktAmiOzn.BodyUch[2].Y-2*SchemaOkraj);
                      if (Ve1.Y>MinSchv) then begin
                        Ve1.Y := Griq.Y*Round(Ve1.Y/Griq.Y);
                        AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                        TAmiSchema(AktAmiOzn).DejRelSourPopisuSch;
                        TAmiSchema(AktAmiOzn).KresliPopisySchAbs(Canvas, Point(0, 0));
  //                      OldKoficientZv := TAmiSchema(AktAmiOzn).KoeficientZv;
                        if AktAmiOzn.Orientace<=3 then begin
                          TAmiSchema(AktAmiOzn).KoeficientZv := Ve1.Y/SchemaVyska;
                        end else begin
                          TAmiSchema(AktAmiOzn).KoeficientZv := Ve1.Y/SchemaSirka;
                        end;
                        AktAmiOzn.Kresli(NIL, KoefZvetseni, 4, PocAmi);
                        AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                        TAmiSchema(AktAmiOzn).DejRelSourPopisuSch;

                        TAmiSchema(AktAmiOzn).KresliPopisySchAbs(Canvas, Point(0, 0));
                      end;
                    end;
                    if (AktAmiOzn.Orientace in [1, 3, 5, 7]) then begin
                      Ve1 := Point(0, AktAmiOzn.BodyUch[2].Y-Bod.Y-2*SchemaOkraj);
                      if (Ve1.Y>MinSchv) then begin
                        Ve1.Y := Griq.Y*Round(Ve1.Y/Griq.Y);
                        AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                        TAmiSchema(AktAmiOzn).KresliPopisySchAbs(Canvas, Point(0, 0));
                        Bod := AktAmiOzn.AbsKonec;
                        if AktAmiOzn.Orientace<=3 then begin
                          TAmiSchema(AktAmiOzn).KoeficientZv := Ve1.Y/SchemaVyska;
                          TAmiSchema(AktAmiOzn).KoeficientZv :=
                            0.001*Round(TAmiSchema(AktAmiOzn).KoeficientZv*1000);  // kvuli ukladani
                          KoefVyska := Griq.Y*Round(SchemaVyska*TAmiSchema(AktAmiOzn).KoeficientZv/Griq.Y);
                        end else begin
                          TAmiSchema(AktAmiOzn).KoeficientZv := Ve1.Y/SchemaSirka;
                          TAmiSchema(AktAmiOzn).KoeficientZv :=
                            0.001*Round(TAmiSchema(AktAmiOzn).KoeficientZv*1000);  // kvuli ukladani
                          KoefVyska := Griq.Y*Round(SchemaSirka*TAmiSchema(AktAmiOzn).KoeficientZv/Griq.Y);
                        end;
                        AktAmiOzn.Pocatek := Point(AktAmiOzn.Pocatek.X, Bod.Y-KoefVyska );
                        AktAmiOzn.Kresli(NIL, KoefZvetseni, 4, PocAmi);
                        AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                        TAmiSchema(AktAmiOzn).DejRelSourPopisuSch;
                        TAmiSchema(AktAmiOzn).KresliPopisySchAbs(Canvas, Point(0, 0));
                      end;
                    end;
  //                  SpocitatBodySpojTr := TRUE;
                  end;
                end;

                // otoceni schematu
                105 : if AktAmiOzn<>NIL then begin
                  if jak then begin
                    OtocilSchema := FALSE;
                    if AktAmiOzn.Orientace<=3 then begin
                      KoefSirka := Griq.X*Round(SchemaSirka*TAmiSchema(AktAmiOzn).KoeficientZv/Griq.X);
                      KoefVyska := Griq.Y*Round(SchemaVyska*TAmiSchema(AktAmiOzn).KoeficientZv/Griq.Y);
                    end else begin
                      KoefSirka := Griq.X*Round(SchemaVyska*TAmiSchema(AktAmiOzn).KoeficientZv/Griq.X);
                      KoefVyska := Griq.Y*Round(SchemaSirka*TAmiSchema(AktAmiOzn).KoeficientZv/Griq.Y);
                    end;
                    SX := AktAmiOzn.Pocatek.X+KoefSirka div 2;
                    SY := AktAmiOzn.Pocatek.Y+KoefVyska div 2;
                    DelejSpocRealBodik(PocAmi, Bodik, KoefZvetseni, Bod);
                    if (Bod.X>AktAmiOzn.Pocatek.X) AND(Bod.X<AktAmiOzn.Pocatek.X+KoefSirka) then begin
                      with AktAmiOzn do begin
                        Ve1 := Point(Bod.X-BodyUch[5].X, 0);
                        Ve2 := Point(AktAmiOzn.Pocatek.X+KoefSirka div 2-Bod.X, 0);
                        if Ve1.X*Ve2.X+Ve1.Y*Ve2.Y<0 then begin
                          AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                          case AktAmiOzn.Orientace of
                            0 : begin
                              if Bod.Y>BodyUch[1].Y then begin
                                AktAmiOzn.Orientace := 4;
                                OtocilSchema := TRUE;
                                KladnaOrientace := TRUE;
                              end;
                            end;
                            1 : begin
                              if Bod.Y<BodyUch[1].Y then begin
                                AktAmiOzn.Orientace := 5;
                                OtocilSchema := TRUE;
                                KladnaOrientace := FALSE;
                              end;
                            end;
                            2 : begin
                              if Bod.Y>BodyUch[1].Y then begin
                                AktAmiOzn.Orientace := 6;
                                OtocilSchema := TRUE;
                                KladnaOrientace := FALSE;
                              end;
                            end;
                            3 : begin
                              if Bod.Y<BodyUch[1].Y then begin
                                AktAmiOzn.Orientace := 7;
                                OtocilSchema := TRUE;
                                KladnaOrientace := TRUE;
                              end;
                            end;
                            4 : begin
                              if Bod.Y>BodyUch[1].Y then begin
                                AktAmiOzn.Orientace := 0;
                                OtocilSchema := TRUE;
                                KladnaOrientace := FALSE;
                              end;
                            end;
                            5 : begin
                              if Bod.Y<BodyUch[1].Y then begin
                                AktAmiOzn.Orientace := 1;
                                OtocilSchema := TRUE;
                                KladnaOrientace := TRUE;
                              end;
                            end;
                            6 : begin
                              if Bod.Y>BodyUch[1].Y then begin
                                AktAmiOzn.Orientace := 2;
                                OtocilSchema := TRUE;
                                KladnaOrientace := TRUE;
                              end;
                            end;
                            7 : begin
                              if Bod.Y<BodyUch[1].Y then begin
                                AktAmiOzn.Orientace := 3;
                                OtocilSchema := TRUE;
                                KladnaOrientace := FALSE;
                              end;
                            end;
                          end;
                        end;
                      end;
                    end;

                    if NOT OtocilSchema then begin
                      if (Bod.Y>AktAmiOzn.Pocatek.Y) AND(Bod.Y<AktAmiOzn.Pocatek.Y+KoefVyska) then begin
                        with AktAmiOzn do begin
                          Ve1 := Point(0, Bod.Y-BodyUch[5].Y);
                          Ve2 := Point(0, AktAmiOzn.Pocatek.Y+KoefVyska div 2-Bod.Y);
                          if Ve1.X*Ve2.X+Ve1.Y*Ve2.Y<0 then begin
                            AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                            case AktAmiOzn.Orientace of
                              0 : begin
                                if Bod.X>BodyUch[2].X then begin
                                  AktAmiOzn.Orientace := 7;
                                  OtocilSchema := TRUE;
                                  KladnaOrientace := FALSE;
                                end;
                              end;
                              1 : begin
                                if Bod.X>BodyUch[2].X then begin
                                  AktAmiOzn.Orientace := 6;
                                  OtocilSchema := TRUE;
                                  KladnaOrientace := TRUE;
                                end;
                              end;
                              2 : begin
                                if Bod.X<BodyUch[2].X then begin
                                  AktAmiOzn.Orientace := 5;
                                  OtocilSchema := TRUE;
                                  KladnaOrientace := TRUE;
                                end;
                              end;
                              3 : begin
                                if Bod.X<BodyUch[2].X then begin
                                  AktAmiOzn.Orientace := 4;
                                  OtocilSchema := TRUE;
                                  KladnaOrientace := FALSE;
                                end;
                              end;
                              4 : begin
                                if Bod.X<BodyUch[2].X then begin
                                  AktAmiOzn.Orientace := 3;
                                  OtocilSchema := TRUE;
                                  KladnaOrientace := TRUE;
                                end;
                              end;
                              5 : begin
                                if Bod.X<BodyUch[2].X then begin
                                  AktAmiOzn.Orientace := 2;
                                  OtocilSchema := TRUE;
                                  KladnaOrientace := FALSE;
                                end;
                              end;
                              6 : begin
                                if Bod.X>BodyUch[2].X then begin
                                  AktAmiOzn.Orientace := 1;
                                  OtocilSchema := TRUE;
                                  KladnaOrientace := FALSE;
                                end;
                              end;
                              7 : begin
                                if Bod.X>BodyUch[2].X then begin
                                  AktAmiOzn.Orientace := 0;
                                  OtocilSchema := TRUE;
                                  KladnaOrientace := TRUE;
                                end;
                              end;
                            end;

                          end;
                        end;
                      end;
                    end;
                    if OtocilSchema then begin
                      AktAmiOzn.Pocatek := Point(Round((SX-KoefVyska div 2)/Griq.X)*Griq.X,
                                                 Round((SY-KoefSirka div 2)/Griq.Y)*Griq.Y);
                      TAmiSchema(AktAmiOzn).OtocAbsSourPopisuSch(KladnaOrientace);
                      TAmiSchema(AktAmiOzn).DejRelSourPopisuSch;
                      AktAmiOzn.Kresli(NIL, KoefZvetseni, 4, PocAmi);
                      AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                    end;
                  end;
                end;

                10*TypVenti3+1,10*(TypVenti3+1)+1,10*(TypVenti3+2)+1 : begin
                  if (AktAmiOzn<>NIL) AND jak then begin
                    BoP := AktAmiOzn.Pocatek;
                    BoK := AktAmiOzn.AbsKonec;
                    if CisloSymbolu=10*TypVenti3+1 then DifV := 200
                                                   else DifV := 150;
                    PocPrip := Round((BoK.X-Bod.X-200)/DifV);
                    PocPrip := Min(Max(0,PocPrip),MaxPocPripVent);
                    BoE := Point(BoK.X-200-PocPrip*DifV, BoK.Y);

                    if NOT PorovnejBody(AktAmiOzn.Pocatek, BoE) then begin
                      AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                      AktAmiOzn.Pocatek := BoE;
                      AktAmiOzn.AbsKonec := BoK;
                      AktAmiOzn.AbsObd(KoefZvetseni,PocAmi);
                      AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                    end;
                  end;
                end;

                122 : begin
                  Polyline([Kotva, Bodik]);
                  Polyline([Kotvb, Bodik]);
                end;

    {            50..54 : begin
                  Polyline([Kotva, Bodik]);
                end;

                10*TypVenti3+3,10*(TypVenti3+1)+3,10*(TypVenti3+2)+3 : begin
                  if (AktAmiOzn<>NIL) AND jak then begin
                    BoP := AktAmiOzn.Pocatek;
                    BoK := AktAmiOzn.AbsKonec;
                    if CisloSymbolu=10*TypVenti3+3 then DifV := 200
                                                   else DifV := 150;
                    PocPrip := Round((Bod.X-BoP.X-200)/DifV);
                    PocPrip := Min(Max(0,PocPrip),MaxPocPripVent);
                    BoE := Point(BoP.X+200+PocPrip*DifV, BoK.Y);

                    if NOT PorovnejBody(AktAmiOzn.AbsKonec,BoE) then begin
                      AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                      AktAmiOzn.AbsKonec := BoE;
                      AktAmiOzn.AbsObd(KoefZvetseni,PocAmi);
                      AktAmiOzn.KreslAbs(Canvas, Point(0, 0));
                    end;
                  end;
                end; }

              end;
            end;
          end;
        end;
      end;   // with ATopChlad
      Pen.Style := psSolid;
    end else begin
      if CisloCimJede_99=-TypAmiOblouk2 then begin
        case CitacKlikuObloucku of
          1 : begin
            case JakObloucek of
              0 : OblKruznice(PaintBox1.Canvas, RObloucku, StredObloucku);
              1 : OblUsecka(PaintBox1.Canvas, BodObloucku1, BodObloucku2);
            end;
          end;
          2, 3 : begin
            Obloucek(PaintBox1.Canvas, RObloucku, StredObloucku, Alf1Obloucku, Alf2Obloucku);
            if JakObloucek=1 then
              BodyTetivy(PaintBox1.Canvas, BodObloucku1, BodObloucku2);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrForm99.N101Click(Sender: TObject);
begin
  if AForm_A is TFormA then
    with AForm_A as TFormA do begin
      N101.Checked := NOT N101.Checked;
      ToolBar9711.Visible := N101.Checked;
      ToolB97Menu11.Down := N101.Checked;
    end;
end;

procedure TFrForm99.N102Click(Sender: TObject);
begin
  if AForm_A is TFormA then
    with AForm_A as TFormA do begin
      N102.Checked := NOT N102.Checked;
      ToolBar9712.Visible := N102.Checked;
      ToolB97Menu12.Down := N102.Checked;
    end;
end;

procedure TFrForm99.N103Click(Sender: TObject);
begin
  if AForm_A is TFormA then
    with AForm_A as TFormA do begin
      N103.Checked := NOT N103.Checked;
      ToolBar9713.Visible := N103.Checked;
      ToolB97Menu13.Down := N103.Checked;
    end;
end;

procedure TFrForm99.N104Click(Sender: TObject);
begin
  if AForm_A is TFormA then
    with AForm_A as TFormA do begin
      N104.Checked := NOT N104.Checked;
      ToolBar9714.Visible := N104.Checked;
      ToolB97Menu14.Down := N104.Checked;
    end;
end;

procedure TFrForm99.N105Click(Sender: TObject);
begin
  if AForm_A is TFormA then
    with AForm_A as TFormA do begin
      N105.Checked := NOT N105.Checked;
      ToolBar9715.Visible := N105.Checked;
      ToolB97Menu15.Down := N105.Checked;
    end;
end;

procedure TFrForm99.N106Click(Sender: TObject);
begin
  if AForm_A is TFormA then
    with AForm_A as TFormA do begin
      N106.Checked := NOT N106.Checked;
      ToolBar9716.Visible := N106.Checked;
      ToolB97Menu16.Down := N106.Checked;
    end;
end;

procedure TFrForm99.N107Click(Sender: TObject);
begin
  if AForm_A is TFormA then
    with AForm_A as TFormA do begin
      N107.Checked := NOT N107.Checked;
      ToolBar9717.Visible := N107.Checked;
      ToolB97Menu17.Down := N107.Checked;
    end;
end;

procedure TFrForm99.N108Click(Sender: TObject);
begin
  if AForm_A is TFormA then
    with AForm_A as TFormA do begin
      N108.Checked := NOT N108.Checked;
      ToolBar9718.Visible := N108.Checked;
      ToolB97Menu18.Down := N108.Checked;
    end;
end;

procedure TFrForm99.N109Click(Sender: TObject);
begin
  if AForm_A is TFormA then
    with AForm_A as TFormA do begin
      N109.Checked := NOT N109.Checked;
      ToolBar9719.Visible := N109.Checked;
      ToolB97Menu19.Down := N109.Checked;
    end;
end;

procedure TFrForm99.N110Click(Sender: TObject);
begin
  if AForm_A is TFormA then
    with AForm_A as TFormA do begin
      N110.Checked := NOT N110.Checked;
      ToolBar9720.Visible := N110.Checked;
      ToolB97Menu20.Down := N110.Checked;
    end;
end;

procedure TFrForm99.N111Click(Sender: TObject);
begin
  if AForm_A is TFormA then
    with AForm_A as TFormA do begin
      N111.Checked := NOT N111.Checked;
      ToolBar9721.Visible := N111.Checked;
      ToolB97Menu21.Down := N111.Checked;
    end;
end;

procedure TFrForm99.N112Click(Sender: TObject);
begin
  if AForm_A is TFormA then
    with AForm_A as TFormA do begin
      N112.Checked := NOT N112.Checked;
      ToolBar9722.Visible := N112.Checked;
      ToolB97Menu22.Down := N112.Checked;
    end;
end;

procedure TFrForm99.N113Click(Sender: TObject);
begin
  if AForm_A is TFormA then
    with AForm_A as TFormA do begin
      N113.Checked := NOT N113.Checked;
      ToolBar9723.Visible := N113.Checked;
      ToolB97Menu23.Down := N113.Checked;
    end;
end;

Procedure TFrForm99.NajdiBodSpojAmi(Bod : TPoint; Sh : TShiftState; Jak : integer);

var
  RidCislo : integer;
  Vent2Cislo : integer;

Function MoznyBod(ABod : TPoint; AmiClass : TAmiClass) : boolean;
var
  j, ind : integer;
  AX : TAmiClass;
  Opravdu : boolean;
begin
  Opravdu := FALSE;
  if RidCislo=TypTrubkaOV then begin

// mozna by chtelo pak upravit
    Opravdu := TRUE;

  end else begin
    if (AmiClass.Typ=RidCislo) OR
       ((AmiClass.Typ in [TypTrubka1..TypTrubka2]) AND (RidCislo=TypTrubka0)) OR
       ((AmiClass.Typ=TypTrubka0) AND (RidCislo in [TypTrubka1..TypTrubka2])) then begin
      { trubka TAM nebo ZPET, a stejneho typu }
      Opravdu := TRUE;
      with ATopChlad do begin
        for j := 0 to AmiLispik.Count-1 do begin
          AX := AmiLispik.Items[j];
          begin
            if AX.JeRadKot then begin
              case AmiClass.Typ of
                TypTrubka1 : if AX.Chladi_x_Topi<=0 then begin
                  if (AmiClass=AX.AmCl) AND
                  PorovnejBody(ABod,AX.BodproTrubTam(ABod, Ind)) then begin
                    Opravdu := FALSE;
                    Break;
                  end;
                end;

                TypTrubka2 : if AX.Chladi_x_Topi<=0 then begin
                  if (AmiClass=AX.AmCm) AND
                  PorovnejBody(ABod, AX.BodproTrubZpet(ABod, Ind)) then begin
                    Opravdu := FALSE;
                    Break;
                  end;
                end;

  // COTRUBKA0?
               TypTrubka0 : if AX.Chladi_x_Topi<=0 then begin
                  if (AmiClass=AX.AmCm) AND
                  PorovnejBody(ABod, AX.BodproTrubZpet(ABod, Ind)) then begin
                    Opravdu := FALSE;
                    Break;
                  end;
                  if (AmiClass=AX.AmCl) AND
                  PorovnejBody(ABod, AX.BodproTrubTam(ABod, Ind)) then begin
                    Opravdu := FALSE;
                    Break;
                  end;
                end;

                TypTrubka3 : if AX.Chladi_x_Topi>0 then begin
                  if (AmiClass=AX.AmCl) AND
                  PorovnejBody(ABod,AX.BodproTrubTam(ABod, Ind)) then begin
                    Opravdu := FALSE;
                    Break;
                  end;
                end;

                TypTrubka4 : if AX.Chladi_x_Topi>0 then begin
                  if (AmiClass=AX.AmCm) AND
                  PorovnejBody(ABod, AX.BodproTrubZpet(ABod, Ind)) then begin
                    Opravdu := FALSE;
                    Break;
                  end;
                end;

              end;
            end;
          end;
        end;         // for j 
      end;           // with ATopChlad
    end else begin
      { dalkove spojeni }

    end;
  end;
  Result := Opravdu;
end;

var
  BodRel : TPoint;
var
  i,j : integer;
  Ind : integer;
  AC, AX : TAmiClass;
  Opravdu : boolean;
  BB1, BB2 : TPoint;
  ind1, ind2 : integer;

  ACNejblBod : TAmiClass;
  NejblDist : extended;
  NejblBod : TPoint;
  Vzd : extended;
  AAmCl : TAmiClass;

  AC1, AC2 : TAmiClass;
  D1, Dist : extended;

  InPneuH : boolean;
begin
  RidCislo := -CisloCimJede_99;
  with ATopChlad do begin
    if RidCislo=0 then begin
      if AktAmiOzn<>NIL then begin
        case CisloSymbolu of
          20..29 : if (AktAmiOzn is TAmiTrubka) then begin
            if CisloSymbolu in [20..29] then begin
              RidCislo := AktAmiOzn.Typ;
            end;
          end;

          42 : if AktAmiOzn is TAmiVentil then begin
            if CisloBoduKapilary=Length(TAmiVentil(AktAmiOzn).Kapilara) then
              RidCislo := CisloSymbolu;
          end;

          74 : if AktAmiOzn is TAmiPneuH then begin
            if CisloBoduKapilary=Length(TAmiPneuH(AktAmiOzn).Kapilarb1)+
                                 Length(TAmiPneuH(AktAmiOzn).Kapilarb2) then
              RidCislo := CisloSymbolu+1;
            if CisloBoduKapilary=Length(TAmiPneuH(AktAmiOzn).Kapilarb1) then
              RidCislo := CisloSymbolu;
          end;
        end;
      end;
    end;

    DelejSpocRealBodik(PocAmi,Bod, KoefZvetseni, BodRel);

    if RidCislo in [TypTrubka1..TypTrubka6, TypTrubkaOV] then begin
//      DelejSpocRealBodik(PocAmi,Bod, KoefZvetseni, BodRel);
      for i := 0 to AmiLispik.Count-1 do begin
        AC := AmiLispik.Items[i];
        if ((CisloCimJede_99<>0) OR (AC<>AktAmiOzn)) then begin
          Opravdu := FALSE;
          if AC.JeRadKot then begin
            if AC.Dotaz(BodRel, EpsilonRel) then begin
              if AC is TAmiOTChladic1 then begin
                BB1 := (AC as TAmiOTChladic1).BodproTrubIndex(BodRel, RidCislo, Ind);
                if Ind<>0 then begin
                  DelejAktBod(BB1);
                  exit;
                end;
              end else begin
                Case RidCislo of
                  TypTrubka1 : if AC.Chladi_x_Topi<=0 then begin
                    if AC is TAmiVenti2 then
                      Case AC.Typ of
                        TypVenti2+5..TypVenti2+9 : continue;
                      end;
                    if NOT (Assigned(AC.AmCl) AND (AC.AmCl is TAmiVenti2)) then begin
                      if AC.JeRadKoupelnovy then
                        with AC as TAmiRad1 do
                          ZmenBodyPrip(0);
                      BB1 := AC.BodproTrubTam(BodRel, Ind);
                      if Ind<>0 then begin
                        DelejAktBod(BB1);
                        exit;
                      end;
                    end;
                  end;

                  TypTrubka2 : if AC.Chladi_x_Topi<=0 then begin
                    if AC is TAmiVenti2 then
                      Case AC.Typ of
                        TypVenti2+5..TypVenti2+9 : continue;
                      end;
                    if NOT (Assigned(AC.AmCm) AND (AC.AmCm is TAmiVenti2)) then begin
                      if AC.JeRadKoupelnovy then
                        with AC as TAmiRad1 do
                          ZmenBodyPrip(0);
                      BB1 := AC.BodproTrubZpet(BodRel, Ind);
                      if Ind<>0 then begin
                        DelejAktBod(BB1);
                        exit;
                      end;
                    end;
                  end;
    // COTRUBKA0?
                  TypTrubka0 : if AC.Chladi_x_Topi<=0 then begin
                    if AC is TAmiOTChladic1 then
                      continue;
                    if AC is TAmiKotel then
                      continue;
                    if AC is TAmiVenti2 then
                      Case AC.Typ of
                        TypVenti2+0..TypVenti2+4 : continue;
                      end;
                    if NOT (Assigned(AC.AmCl) AND (AC.AmCl is TAmiVenti2)) then begin
                      if AC.JeRadKoupelnovy then
                        with AC as TAmiRad1 do
                          ZmenBodyPrip(0);
                      BB1 := AC.BodproTrubTam(BodRel, Ind);
                      if Ind<>0 then begin
                        DelejAktBod(BB1);
                        exit;
                      end;
                    end;

                    if NOT (Assigned(AC.AmCm) AND (AC.AmCm is TAmiVenti2)) then begin
                      if AC.JeRadKoupelnovy then
                        with AC as TAmiRad1 do
                          ZmenBodyPrip(0);
                      BB1 := AC.BodproTrubZpet(BodRel, Ind);
                      if Ind<>0 then begin
                        DelejAktBod(BB1);
                        exit;
                      end;
                    end;
                  end;

                  TypTrubka3 : if AC.Chladi_x_Topi>0 then begin
                    if NOT (Assigned(AC.AmCl) AND (AC.AmCl is TAmiVenti2)) then begin
                      BB1 := AC.BodproTrubTam(BodRel, Ind);
                      if Ind<>0 then begin
                        DelejAktBod(BB1);
                        exit;
                      end;
                    end;
                  end;

                  TypTrubka4 : if AC.Chladi_x_Topi>0 then begin
                    if NOT (Assigned(AC.AmCm) AND (AC.AmCm is TAmiVenti2)) then begin
                      BB1 := AC.BodproTrubZpet(BodRel, Ind);
                      if Ind<>0 then begin
                        DelejAktBod(BB1);
                        exit;
                      end;
                    end;
                  end;
                end;
              end;
            end;
          end;

          if AC is TAmiTrubka then begin
            if BlizkeBody(BodRel,AC.Pocatek,Griq.Y-1) OR
               BlizkeBody(BodRel,AC.AbsKonec,Griq.Y-1) then begin
              if BlizkeBody(BodRel,AC.Pocatek,Griq.Y-1) then begin
                BB1 := AC.Pocatek;
                BB2 := AC.AbsKonec;
              end else begin
                BB1 := AC.AbsKonec;
                BB2 := AC.Pocatek;
              end;
              if MoznyBod(BB1, AC) then begin
                DelejAktBod(BB1);
                exit;
              end;
            end;
          end;

  {        if (AC is TAmiVenti2) AND AC.Dotaz(BodRel, EpsilonRel) then begin
            Case RidCislo of
              TypTrubka1 : begin
                BB1 := AC.BodproTrubTam(BodRel, Ind);
                if Ind<>0 then begin
                  DelejAktBod(BB1);
                  exit;
                end;
              end;

              TypTrubka2 : begin
                BB1 := AC.BodproTrubZpet(BodRel, Ind);
                if Ind<>0 then begin
                  DelejAktBod(BB1);
                  exit;
                end;
              end;
            end;
          end;  }

          if (AC is TAmiVenti3) then begin
            if CisloCimJede_99=0 then AX := AktAmiOzn else AX := NIL;
            BB1 := TAmiVenti3(AC).ANejblBodPrip(BodRel, RidCislo, AX, Ind);
            if Ind<>0 then begin
              DelejAktBod(BB1);
              exit;
            end;
          end;

        end;
      end;

      if KoefZvetseni<0.75 then begin
        NejblDist := Round((EpsilonAbs+2)/(KoefZvetseni*JMetrMM));

        ACNejblBod := NIL;
        NejblBod := Point(-MaxInt div 2, -MaxInt div 2);
        for i := 0 to AmiLispik.Count-1 do begin
          AC := AmiLispik.Items[i];
          if ((CisloCimJede_99<>0) OR (AC<>AktAmiOzn)) then begin
            if AC is TAmiTrubka then begin
              Vzd := DistBodu(BodRel,AC.Pocatek);
              if Vzd<NejblDist then begin
                if MoznyBod(AC.Pocatek, AC) then begin
                  NejblDist := Vzd;
                  ACNejblBod := AC;
                  NejblBod := AC.Pocatek;
                end;
              end;
              Vzd := DistBodu(BodRel,AC.AbsKonec);
              if Vzd<NejblDist then begin
                if MoznyBod(AC.AbsKonec, AC) then begin
                  NejblDist := Vzd;
                  ACNejblBod := AC;
                  NejblBod := AC.AbsKonec;
                end;
              end;
            end;
          end;
        end;
        DelejAktBod(NejblBod);
        exit;
      end;
    end;

    if RidCislo=42 then begin  // satra koncem kapilary ventilu
      for i := 0 to AmiLispik.Count-1 do begin
        AC := AmiLispik[i];
//        if (AC is TAmiVenti1) AND ((AC.Typ-TypVentBalancni) in [0]) AND
        if (AC is TAmiVenti1) AND (TAmiVentil(AC).JakoBalancniVentil) AND
            AC.Dotaz(BodRel, EpsilonRel) then begin
          if Assigned(AC.AmCm) then begin
            DelejAktBod(Point(-MaxInt div 2, -MaxInt div 2));
            exit;
          end;

{          for j := i+1 to AmiLispik.Count-1 do begin
            AX := AmiLispik[j];
            if (AX is TAmiVentil) AND (AX.AmCm=AC) then begin
              DelejAktBod(Point(-MaxInt div 2, -MaxInt div 2));
              exit;
            end;
          end; }

          NejblBod := AC.NejblBodPrip(BodRel, ind);
          if ind>0 then
            DelejAktBod(NejblBod);
{          if DistBodu(BodRel, TAmiVentil(AC).KotvaKapilary[1])<
             DistBodu(BodRel, TAmiVentil(AC).KotvaKapilary[2]) then begin
            DelejAktBod(TAmiVentil(AC).KotvaKapilary[1]);
          end else begin
            DelejAktBod(TAmiVentil(AC).KotvaKapilary[2]);
          end; }
          exit;
        end;
      end;
    end;

    if (RidCislo-TypVenti2) in [0..9] then begin
  //    Vent2Cislo := FunVent4(SymbolAmi[-CisloCimJede_99-TypVenti2+56]);
  //    Vent2Cislo := RidCislo-TypVenti2;
  //    Vent2Cislo := RidCislo;
      Vent2Cislo := FunVent4(RidCislo, SymbolAmi[RidCislo-TypVenti2+31]);
                                      // viz TypAmi
  //    DelejSpocRealBodik(PocAmi, Bod, KoefZvetseni, BodRel);
      for i := 0 to AmiLispik.Count-1 do begin
        AC := AmiLispik.Items[i];
        Opravdu := FALSE;
        if ((CisloCimJede_99<>0) OR (AC<>AktAmiOzn)) AND
                 AC.Dotaz(BodRel, EpsilonRel) then begin
          case RidCislo of
            TypVenti2+0, TypVenti2+5 : begin
              if (AC.JeRadseSpodnimPripojeni OR AC.JeRadseStrednimPripojeni OR
                 AC.JeRadseSpodPravPripojeni OR AC.JeRadseSpodLevPripojeni) then begin
                case Vent2Cislo of
                  TypVenti2+0 : Opravdu := TRUE;
                  TypVekoluxDv, TypVekoluxJe : Opravdu := AC.JeRadseSpodnimPripojeni OR
                    AC.JeRadseSpodPravPripojeni OR AC.JeRadseSpodLevPripojeni;
                  TypMultiluxDv, TypMultiluxJe : Opravdu := AC.JeRadseStrednimPripojeni;
                  TypVenti2+5 : Opravdu := TRUE;
                end;
              end;
            end;

            TypVenti2+1, TypVenti2+6 : begin
              if AC.JeRadsBocnimPripojeni then begin
                case Vent2Cislo of
                  TypVenti2+1 : Opravdu := TRUE;
                  TypVenti2+6 : Opravdu := TRUE;
                  TypEZ_VENTIL_ONE : Opravdu := TRUE;
                end;
              end;
              if AC.JeRadKoupelnovy then begin
                case Vent2Cislo of
                  TypVenti2+6 : Opravdu := TRUE;
                  TypEZ_System_Immersion : Opravdu := TRUE;
                end;
              end;
            end;

            TypVenti2+2, TypVenti2+7 : begin
              if AC.JeRadKoupelnovy then begin
                case Vent2Cislo of
                  TypVenti2+2 : Opravdu := TRUE;
                  TypVenti2+7 : Opravdu := TRUE;
                end;
              end;
            end;

            TypVenti2+3, TypVenti2+8 : begin
              if AC.JeRadsBocnimPripojeni then begin
                case Vent2Cislo of
                  TypVenti2+3 : Opravdu := TRUE;
                  TypVenti2+8 : Opravdu := TRUE;
                end;
              end;
            end;
          end;
          if Opravdu then begin
            if Assigned(AC.AmCl) then begin
              if NOT (AC.AmCl is TAmiVenti2) then begin
                BB1 := AC.DejBodTrubTam(Ind);
                if Ind<>0 then begin
                  if AC.JeRadsBocnimPripojeni OR AC.JeRadKoupelnovy then
                    Opravdu := FALSE;
  // pokud je k OT se spodnim pripojenim uz pripojena trubka,
  // muze tam strcit prip.soustavu
                  if Opravdu then begin
                    DelejAktBod(BB1);
                    exit;
                  end;
                end;
              end;
            end else begin
  {            if AC.JeRadKoupelnovy then
                with AC as TAmiRad1 do
                   ZmenBodyPrip(1); }
              BB1 := AC.BodproTrubTam(BodRel, Ind);
              if Ind<>0 then begin
                if AC.JeRadsBocnimPripojeni then
  // nesmi pripojit prip.soustavu na horni pripojovaci body.
                  if Ind in [2, 4] then
                    Opravdu := FALSE;
                if AC.JeRadKoupelnovy then
  // muze pripojit prip.soustavu jen na spodni pripojovaci body.
                  if Ind in [1..4] then
                    Opravdu := FALSE;
                if Opravdu then begin
                  DelejAktBod(BB1);
                  exit;
                end;
              end;
            end;
  //        end;
          end;
        end;
      end;
    end;

    if RidCislo=TypOdvzdVent then begin
      // Odvzdusnovaci ventil pro radiatory
//      DelejSpocRealBodik(PocAmi,Bod, KoefZvetseni, BodRel);
      AC := AmiLispik.NajdiRadiatorBod(BodRel, EpsilonRel, TypOdvzdVent, BB1);
      if AC<>NIL then begin
        DelejAktBod(BB1);
        exit;
      end;
    end;

    if RidCislo=TypVypoustVent then begin
      // Vypousteci ventil, pokud jede pres radiator
//      DelejSpocRealBodik(PocAmi,Bod, KoefZvetseni, BodRel);
      AC := AmiLispik.NajdiRadiatorBod(BodRel, EpsilonRel, TypVypoustVent, BB1);
      if AC<>NIL then begin
        DelejAktBod(BB1);
        exit;
      end;
    end;

    if RidCislo=TypAlpha then begin
      // Koef. zatekani, pokud jede pres trubku typtrubka0
//      DelejSpocRealBodik(PocAmi, Bod, KoefZvetseni, BodRel);
      Dist := MaxInt;
  //    AC2 := NIL;
      for i := 0 to AmiLispik.Count-1 do begin
        AC1 := AmiLispik[i];
        if AC1.Typ=TypTrubka0 then begin
          D1 := DistBodu(AC1.Pocatek, BodRel);
          if D1<Dist then begin
            BB1 := AC1.Pocatek;
  //          AC2 := AC1;
            Dist := D1;
          end;
          D1 := DistBodu(AC1.AbsKonec, BodRel);
          if D1<Dist then begin
            BB1 := AC1.AbsKonec;
  //          AC2 := AC1;
            Dist := D1;
          end;
        end;
      end;
      if Dist<EpsilonRel then begin
        DelejAktBod(BB1);
        exit;
      end;
    end;

    if RidCislo-74 in [0, 1] then begin  // satra koncem "kapilary" PneuH
      for i := 0 to AmiLispik.Count-1 do begin
        AC := AmiLispik[i];
        if (AC<>AktAmiOzn) AND (AC is TAmiPneuH) AND TAmiPneuH(AC).DotazPneuH(BodRel, EpsilonRel) then begin
          if RidCislo=74 then
            InPneuH := TAmiPneuH(AktAmiOzn).PripustnyAmi1(AC, 0, 1);
          if RidCislo=75 then
            InPneuH := TAmiPneuH(AktAmiOzn).PripustnyAmi2(AC, 0, 1);
          if InPneuH then begin
            if AC.NPrip>0 then begin
              BB1 := AC.BodyPrip[1];
              Dist := DistBodu(BB1, BodRel);
              for j := 2 to AC.NPrip do begin
                D1 := DistBodu(AC.BodyPrip[j], BodRel);
                if D1<Dist then begin
                  Dist := D1;
                  BB1 := AC.BodyPrip[j];
                end;
              end;
              DelejAktBod(BB1);
              exit;
            end;
          end;
        end;
      end;
    end;

  end;  // with ATopChlad

  DelejAktBod(Point(-MaxInt div 2, -MaxInt div 2));
end;

procedure TFrForm99.DelejVlozit1Click_99;
var
  i : integer;
  AC : TAmiClass;
//  ATypOtSous,
  BTypOtSous : integer;
begin
  if JakobyClipboard.Count>0 then begin
//    ATypOtSous := ZjistiJednotrubku(AmiLispik);
    BTypOtSous := ZjistiJednotrubku(JakobyClipboard);
    with ATopChlad do begin
      if (NOT BJeOchlazovani OR NastaveniTopChlad.BCooling) AND (BTypOtSous<0) then begin
  // nepovolime vlozit jednotrubku do neochlazovaneho vypoctu
        JakobyClipboard.ZnicList;
        ShowMessage(SNelzeVlozitJednotrubku);
      end else begin
        JakobyPageControlChange;
        CisloCimJede_99 := -TypClipboard;
      end;
    end;
  end;
end;

procedure TFrForm99.Odstranit1Click_99;
begin
  VidPanel1_99(FALSE);
  VidPanel3_99(FALSE);
  DelejDelete_99;
end;

procedure TFrForm99.Odstranit2Click(Sender: TObject);
begin
  DelejDelete_99;
end;

procedure TFrForm99.Vyjmout1Click_99;
begin
  DelejVlozdoClipboardu_99;
  VidPanel1_99(FALSE);
  VidPanel3_99(FALSE);
  DelejDelete_99;
end;

procedure TFrForm99.Vyjmout2Click(Sender: TObject);
begin
  Vyjmout1Click_99;
end;

procedure TFrForm99.ToolBStr3Click_99;
begin
  VidPanel1_99(FALSE);
  CisloCimJede_99 := 0;
  with FormStrop1 do begin
    if ShowModal=mrOK then begin
      if CheckBox1.Checked then begin
        DelejVlozStrop1(Point(0, 0), ATopChlad.AmiLispik);
        JakobyPageControlChange;
        MuzeScroll := FALSE;
        ScrollBar1.Position := -200;
        ScrollBar2.Position := -Round(Round(PaintBox1.Height*0.9)/(KoefZvetseni*JMetrMM));
        MuzeScroll := TRUE;
      end else begin
        CisloCimJede_99 := -TypStrop1;
        DelejVyberKurzor_99(62);
      end;
      ATopChlad.ZmenaProjektu := TRUE;
    end else begin
      JakobyPageControlChange;
    end;
    DelejInvalidu_99;
  end;
end;

Procedure TFrForm99.DelejVyberKurzor_99Old(CisloKurzoru : integer);
var
  i : integer;
  JmKurs : PChar;
  NaselKurzor : boolean;
begin
  AktCisloKurzoru := CisloKurzoru;
  if CisloKurzoru<=0 then begin
    PaintBox1.Cursor := CisloKurzoru;
    exit;
  end;

  NaselKurzor := FALSE;
  JmKurs := OznKurzoru[CisloKurzoru];
  if JmKurs<>'' then begin
    for i := 1 to PocetKurzoru do begin
{$IFDEF VER130}
      if ShortString(JmKurs)=ShortString(JmenaKurzoru[i]) then begin
{$ELSE}
      if SysUtils.StrComp(JmKurs, JmenaKurzoru[i]) = 0 then begin
{$ENDIF}
        NaselKurzor := TRUE;
        PaintBox1.Cursor := i;
        Break;
      end
    end;
    if NOT NaselKurzor then begin
      PaintBox1.Cursor := crDefault;
      AktCisloKurzoru := 0;
    end;
  end else begin
    PaintBox1.Cursor := crDefault;
    AktCisloKurzoru := 0;
  end;
end;

Procedure TFrForm99.DelejVyberKurzor_99(CisloKurzoru : integer);
begin
  AktCisloKurzoru := CisloKurzoru;
  PaintBox1.Cursor := CisloKurzoru;
end;

(*  if CisloKurzoru<=0 then begin
    PaintBox1.Cursor := CisloKurzoru;
    exit;
  end;

  NaselKurzor := FALSE;
  JmKurs := OznKurzoru[CisloKurzoru];
  if JmKurs<>'' then begin
    for i := 1 to PocetKurzoru do begin
{$IFDEF VER130}
      if ShortString(JmKurs)=ShortString(JmenaKurzoru[i]) then begin
{$ELSE}
      if SysUtils.StrComp(JmKurs, JmenaKurzoru[i]) = 0 then begin
{$ENDIF}
        NaselKurzor := TRUE;
        PaintBox1.Cursor := i;
        Break;
      end
    end;
    if NOT NaselKurzor then begin
      PaintBox1.Cursor := crDefault;
      AktCisloKurzoru := 0;
    end;
  end else begin
    PaintBox1.Cursor := crDefault;
    AktCisloKurzoru := 0;
  end;
end; *)

procedure TFrForm99.HSplitterCanResize(Sender: TObject; var NewSize: Integer;
  var Accept: Boolean);
begin
  if BottomDockPanel.DockClientCount=0 then begin
    Accept := FALSE;
  end else begin
    if NewSize<40 then
      Accept := FALSE;
  end;
end;

procedure TFrForm99.HSplitterMoved(Sender: TObject);
begin
  if Sender=HSplitter then begin
    if Statusbar1.Visible then begin
      StatusBar1.Height := 17;
//      StatusBar1.Top := HSplitter.Top-StatusBar1.Height;
      StatusBar1.Top := Height-StatusBar1.Height;
    end;
    BottomDockPanel.Top := HSplitter.Top+DifHSplitter;
  end;
  SpocitejPosScroll_99;
end;

procedure TFrForm99.DelejKreslAbs(Bod : TPoint);
var
  i : integer;
begin
  with ATopChlad do begin
    AmiLispik.AbsObd(KoefZvetseni, PocAmi);
    for i := 0 to OznList.Count-1 do
      TAmiClass(OznList.Items[i]).KreslAbs(PaintBox1.Canvas,Bod);
  end;
end;

Procedure TFrForm99.DelejUmozniUNDO_99;
begin
  ATopChlad.DelejUmozniUNDO_TChl;
end;

Procedure TFrForm99.DelejUmozniUNDQ_99(KodUndo, KodZmeny: integer; AC : TAmiClass; List : TAmiList);
begin
  ATopChlad.DelejUmozniUNDQ_TChl(KodUndo, KodZmeny, AC, List);
end;

Procedure TFrForm99.DelejPrvniREDQ_99(KodUndo, KodZmeny : integer; AC : TAmiClass; List : TAmiList);
begin
  ATopChlad.DelejPrvniREDQ_TChl(KodUndo, KodZmeny, AC, List);
end;

Procedure TFrForm99.DelejVratKrokUNDQ_99;
begin
  ATopChlad.DelejVratKrokUNDQ_TChl;
end;

Function TFrForm99.NicSeNedeje_99 : boolean;
begin
  Result := TRUE;
  if AForm_A is TFormA then
    Result := TFormA(AForm_A).NicSeNedeje01;
  if AForm_A is TForm_Rb1 then
    Result := TForm_Rb1(AForm_A).NicSeNedeje01;
end;

Procedure TFrForm99.PrepocitejObloucek_99(Bod : TPoint; SH : TShiftState);
var
  AStred : TPoint;
  R, AAlf1, AAlf2 : integer;
  CtrlAlfaBodObl, CtrlAlfaStredObl, CtrlAlfaKotvaObl, AlfaOtoceni : extended;
begin
  if VkladatObloucky then begin
    case JakObloucek of
      0 : begin
  //      if ssLeft in SH then begin
        begin
          case CitacKlikuObloucku of
            1 : begin
              R := Round(Sqrt(Sqr(Bod.X-BodObloucku1.X)+Sqr(Bod.Y-BodObloucku1.Y)));
              StredObloucku := Bod;
              RObloucku := R;
            end;
          end;
        end;
        case CitacKlikuObloucku of
          2, 3 : begin
            if (StredObloucku.Y<>Bod.Y) OR (StredObloucku.X<>Bod.X) then begin
              AAlf2 := 180000-Round(ArcTan2(StredObloucku.Y-Bod.Y, StredObloucku.X-Bod.X)/Pi*180000);
              Alf2Obloucku := AAlf2;
            end;
          end;
        end;
      end;

      1 : begin
  //      if ssLeft in SH then begin
        begin
          case CitacKlikuObloucku of
            1 : begin
              BodObloucku2 := Bod;
            end;
          end;
        end;
        case CitacKlikuObloucku of
          2, 3 : begin
            if SpocitejParam1Obloucku1(BodObloucku1, BodObloucku2, Bod,
                AStred, R, AAlf1, AAlf2) then begin
              if R<MaxRObloucku2 then begin
//              begin
                Alf1Obloucku := AAlf1;
                Alf2Obloucku := AAlf2;

                RObloucku := R;
                StredObloucku := AStred;
              end;
            end;
          end;

        end;
      end;
    end;
  end;

  with ATopChlad do begin
    if AktAmiOzn is TAmiOblouk then begin
      Case CisloSymbolu of
        81, 82 : begin
          if NOT ((ssShift in SH) OR (ssCtrl in SH)) then begin
            DelejSpocAbsBodik(Point(0, 0), AktAmiOzn.RelKonec, KoefZvetseni, AStred);
            RObloucku := Round(Abs(AStred.X)/2);
            AStred.X := AktAmiOzn.Pocatek.X+AktAmiOzn.RelKonec.X div 2;
            AStred.Y := AktAmiOzn.Pocatek.Y+AktAmiOzn.RelKonec.Y div 2;
            DelejSpocAbsBodik(PocAmi, AStred, KoefZvetseni, AStred);

            CtrlAlfaKotvaObl := ArcTan2(Kotva.Y-Kotvb.Y, Kotva.X-Kotvb.X);
            CtrlAlfaBodObl := ArcTan2(Bod.Y-Kotvb.Y, Bod.X-Kotvb.X);
            AlfaOtoceni := CtrlAlfaBodObl-CtrlAlfaKotvaObl;
            CtrlAlfaStredObl := ArcTan2(AStred.Y-Kotvb.Y, AStred.X-Kotvb.X);
            CtrlAlfaStredObl := CtrlAlfaStredObl + AlfaOtoceni;
            AStred.X := Kotvb.X+Round(RObloucku*Cos(CtrlAlfaStredObl));
            AStred.Y := Kotvb.Y+Round(RObloucku*Sin(CtrlAlfaStredObl));
            Alf1Obloucku := TAmiOblouk(AktAmiOzn).Alfa1 - Round(AlfaOtoceni/Pi*180000);
            if Alf1Obloucku<0 then
              Alf1Obloucku := Alf1Obloucku+360000;
            if Alf1Obloucku>360000 then
              Alf1Obloucku := Alf1Obloucku-360000;
            Alf2Obloucku := TAmiOblouk(AktAmiOzn).Alfa2 - Round(AlfaOtoceni/Pi*180000);
            if Alf2Obloucku<0 then
              Alf2Obloucku := Alf2Obloucku+360000;
            if Alf2Obloucku>360000 then
              Alf2Obloucku := Alf2Obloucku-360000;
            StredObloucku := AStred;
          end else begin
            StredObloucku.X := AktAmiOzn.Pocatek.X+AktAmiOzn.RelKonec.X div 2;
            StredObloucku.Y := AktAmiOzn.Pocatek.Y+AktAmiOzn.RelKonec.Y div 2;
            DelejSpocAbsBodik(PocAmi, StredObloucku, KoefZvetseni, StredObloucku);
            DelejSpocAbsBodik(Point(0, 0), AktAmiOzn.RelKonec, KoefZvetseni, AStred);
            RObloucku := Round(Abs(AStred.X)/2);
            if CisloSymbolu=82 then begin
              Alf1Obloucku := TAmiOblouk(AktAmiOzn).Alfa1;
              Alf2Obloucku := 180000-Round(ArcTan2(StredObloucku.Y-Bod.Y, StredObloucku.X-Bod.X)/Pi*180000);
            end;
            if CisloSymbolu=81 then begin
              Alf1Obloucku := 180000-Round(ArcTan2(StredObloucku.Y-Bod.Y, StredObloucku.X-Bod.X)/Pi*180000);
              Alf2Obloucku := TAmiOblouk(AktAmiOzn).Alfa2;
            end;
          end;
        end;

        86, 88 : begin
          StredObloucku.X := AktAmiOzn.Pocatek.X+AktAmiOzn.RelKonec.X div 2;
          StredObloucku.Y := AktAmiOzn.Pocatek.Y+AktAmiOzn.RelKonec.Y div 2;
          DelejSpocAbsBodik(PocAmi, StredObloucku, KoefZvetseni, StredObloucku);
          R := Round(Sqrt(Sqr(Bod.X-StredObloucku.X)+Sqr(Bod.Y-StredObloucku.Y)));
          if R<MaxRObloucku2 then begin
            Alf1Obloucku := TAmiOblouk(AktAmiOzn).Alfa1;
            Alf2Obloucku := TAmiOblouk(AktAmiOzn).Alfa2;
            RObloucku := R;
          end;
        end;

        87 : begin
          if SpocitejParam1Obloucku2(Kotva, Kotvb, Bod, AStred, R, AAlf1, AAlf2) then begin
            if R<MaxRObloucku2 then begin
              Alf1Obloucku := AAlf1;
              Alf2Obloucku := AAlf2;
              RObloucku := R;
              StredObloucku := AStred;
            end;
          end;
        end;
      end;
    end;
  end;    // with ATopChlad
end;

Procedure TFrForm99.MysiKriz(SH : TShiftState; Pohnul, jak : boolean);
begin
  if (Myska.X+Korka.X>0) AND (Myska.Y+Korka.Y>0) then begin
    CarkyNaPravitkach;
    KresliSymbol(PaintBox1.Canvas, Myska, SH, Pohnul, jak);
  end;
end;

Procedure TFrForm99.NajdiObjektAmi(Bod : TPoint; SH : TShiftState; Jak : integer);
var
  AC, AmiClass : TAmiClass;
  BodRel, BodRad : TPoint;
  i, CB : integer;
begin
  DelejSpocRealBodik(PocAmi, Bod, KoefZvetseni, BodRel);
  with ATopChlad do begin
    if CisloCimJede_99=0 then begin
      AmiClass := AmiLispik.DotaX(BodRel, EpsilonRel);
      if AmiClass<>NIL then
        AmiClass.AbsObd(KoefZvetseni,PocAmi);
      if (SH=[]) AND (Jak=1) then begin
        if AmiClass<>AktAmiMove then begin
          if AktAmiMove<>NIL then begin
            if BUkazatStoupacky then begin
              AktAmiMove.Kresli(PaintBox1.Canvas, KoefZvetseni, 10, PocAmi);
            end else begin
              if AktAmiMove=AktAmiOzn then begin
                AktAmiMove.Kresli(PaintBox1.Canvas, KoefZvetseni, 5, PocAmi);
              end else begin
                if AktAmiMove=AktAmiLisq then begin
                  AktAmiMove.Kresli(PaintBox1.Canvas, KoefZvetseni, 7, PocAmi);
                end else begin
                  if VybList.IndexOf(AktAmiMove)>=0 then
                    AktAmiMove.Kresli(PaintBox1.Canvas, KoefZvetseni, 2, PocAmi)
                  else begin
                    AktAmiMove.Kresli(PaintBox1.Canvas, KoefZvetseni, 0, PocAmi);
                    UkazOblastProTisk_99;
                  end;
                end;
              end;
            end;
          end;
          AktAmiMove := AmiClass;
          if AktAmiMove<>NIL then begin
            if AktAmiMove=AktAmiOzn then begin
              AktAmiMove.Kresli(PaintBox1.Canvas, KoefZvetseni, 4, PocAmi);
            end else begin
              AktAmiMove.Kresli(PaintBox1.Canvas, KoefZvetseni, 1, PocAmi);
            end;
          end;
          Application.CancelHint;

  //        PaintBox1.Hint := UdelejHint(AktAmiMove);
        end;
      end else begin
        if Assigned(AmiClass) then begin
          if (AmiClass is TAmiSchema) AND (ssCtrl in SH) then begin
  // hleda objekt ve schematu


          end else begin
            if (ssLeft in SH) then begin
              { ted se nepouziva }
              if (ssCtrl in SH) then begin
                Case Jak of
                  0 : begin
                    if AmiClass<>AktAmiOzn then begin
                      if AktAmiOzn=NIL then begin
                        AktAmiOzn := AmiClass;
                        AktAmiOzn.Oznaceny := TRUE;
                      end else begin
                        AktAmiOzn.Oznaceny := FALSE;
                        AktAmiOzn.Vybrany := TRUE;
                        VybList.Add(AktAmiOzn);
                        AmiClass.Vybrany := TRUE;
                        VybList.Add(AmiClass);
                        AktAmiOzn := NIL;
                      end;
                      DelejTabulky_99;
                      DelejInvalidu_99;
                    end;
                  end;

                  -1 : begin
                    if VybList.IndexOf(AmiClass)<0 then begin
                      VybList.Add(AmiClass);
                      AktAmiOzn := NIL;
                      DelejTabulky_99;
                      DelejInvalidu_99;
                    end;
                  end;

                end;

              end else begin
                Case Jak of
                  0 : begin
                    if AmiClass<>AktAmiOzn then begin
                      AktAmiOzn := AmiClass;
                      if AktAmiOzn<>NIL then
                        DelejTabulky_99;
                      DelejInvalidu_99;
                    end;
                  end;

                  -1 : begin
                    AktAmiPom := AmiClass;
                    if (AktAmiPom=NIL) OR (VybList.IndexOf(AktAmiPom)<0) then begin
                      VybList.Clear;
                      OznList.Clear;
                      if AktAmiPom<>NIL then begin
                        AktAmiOzn := AktAmiPom;
                        AktAmiPom := NIL;
                      end;
                      DelejTabulky_99;
                      DelejInvalidu_99;
                    end;
                  end;

                end;
              end;
            end;
          end;
        end;
      end;
    end else begin
      case CisloCimJede_99 of
        -TypVentiPneuHShutoffValve : begin
          AmiClass := NIL;
          for i := 0 to AmiLispik.Count-1 do begin
            AC := AmiLispik[i];
            if (AC is TAmiPneuH) AND (AC.Typ-TypPneuH in PripustneKapilaryproShutOff) then begin
              if TAmiPneuH(AC).DotazKapilary(BodRel, EpsilonRel, CB)>0 then begin
                AmiClass := AC;
                break;
              end;
            end;
          end;   // for i
          DelejMoveAmi_99(AmiClass);
        end;

//        -TypPneuHAirVent,
        -TypVentiPneuHAirVent,
        -TypVenti4-29..-TypVenti4,
        -TypBubSluVent..-TypSludgeVent,
        -TypVypoustVent..-TypVenti1,
        -TypArm1-20..-TypArm1,
        -TypSoucArm,
        -TypCeTeMa-10..-TypCeTeMa,
        -TypPopisTru1, -TypPopisTru2, -TypPopisTru3, -TypPopisTru4, -TypPopisTru5 : begin
          if (SH=[]) AND (Jak=1) then begin
            AmiClass := AmiLispik.NajdiTrubkuBod(BodRel, EpsilonRel, 0);
            if AmiClass=NIL then begin
              case CisloCimJede_99 of
                -TypVentiPneuHAirVent,
                -TypMer2-10..-TypMer2,
                -TypBubSluVent..-TypSludgeVent,
                -TypVypoustVent..-TypVenti1,
                -TypArm1-20..-TypArm1,
                -TypSoucArm,
                -TypCeTeMa-10..-TypCeTeMa :
                  AmiClass := AmiLispik.NajdiTrubkuBod(BodRel, EpsilonRel, -1);
              end;
            end;

            DelejMoveAmi_99(AmiClass);
          end;
        end;

        -TypVentiPneuHSafetyValve : begin
          if (SH=[]) AND (Jak=1) then begin
            AmiClass := AmiLispik.NajdiTrubkuBod(BodRel, EpsilonRel, TypTrubkaCara10);
            DelejMoveAmi_99(AmiClass);
          end;
        end;

        -TypOdvzdVent : begin
          if (SH=[]) AND (Jak=1) then begin
            AmiClass := AmiLispik.NajdiRadiatorBod(BodRel, EpsilonRel, TypOdvzdVent,
                                                 BodRad);
            DelejMoveAmi_99(AmiClass);
          end;
        end;

        -TypTrubka6..-TypTrubka1 : begin
          if (SH=[]) AND (Jak=1) then begin
            AmiClass := AmiLispik.NajdiRaKoBod(BodRel, EpsilonRel, -CisloCimJede_99);
            if AmiClass=NIL then
              AmiClass := AmiLispik.NajdiTrubkuBod(BodRel, EpsilonRel,
                -CisloCimJede_99);
            DelejMoveAmi_99(AmiClass);
          end;
          if (ssLeft in SH) AND (Jak=1) then begin
            AmiClass := AmiLispik.NajdiTrubkuBod(BodRel, EpsilonRel,
                -CisloCimJede_99);
            DelejMoveAmi_99(AmiClass);
          end;
        end;

        -TypTrubkaCara10..-TypTrubkaCara1 : begin
           if (Jak=1) then begin

            AmiClass := AmiLispik.NajdiTrubCaru(BodRel, EpsilonRel, 0);
            if (CisloCimJede_99=-TypTrubkaCara10) AND (AmiClass=NIL) then begin
              for i := 0 to AmiLispik.Count-1 do begin
                AC := AmiLispik[i];
                if (AC is TAmiPneuH) AND (AC.Typ-TypPneuH in PripustneKapilaryproShutOff) then begin
                  if TAmiPneuH(AC).DotazKapilary(BodRel, EpsilonRel, CB)>0 then begin
                    AmiClass := AC;
                    break;
                  end;
                end;
              end;   // for i
            end;
            DelejMoveAmi_99(AmiClass);
          end;
        end;
      end;
    end;
  end;   // with ATopChlad
end;

Procedure TFrForm99.ZobrazitKontrolu_99(AChecked, AEnabled : boolean);
begin
  if AForm_A is TFormA then
    with TFormA(AForm_A) do begin
      ZobrazitKontrolu1.Checked := AChecked;
      ZobrazitKontrolu1.Enabled := AEnabled;
      AZobrazitKontrolu1.Checked := AChecked;
      AZobrazitKontrolu1.Enabled := AEnabled;
    end;
end;

Procedure KresliGrid(BitMap : TBitMap; Canvas : TCanvas);
begin
  Canvas.Draw(0,0,BitMap);
end;

procedure TFrForm99.DelejInvalidu_99;
{ var
  i : integer;
  AC : TAmiClass;
  DummyRect : TRect; }
begin
  DelejSpocRealBodik(PocAmi,Point(0, BiMa.Height),KoefZvetseni,ObdBiMa.TopLeft);
  DelejSpocRealBodik(PocAmi,Point(BiMa.Width, 0),KoefZvetseni,ObdBiMa.BottomRight);
  PoOAmi := PocAmi;

{  ObdBiMa.Left :=  : TRect; }
  if BZobrazitGrid AND (KoefZvetseni>=1) then begin
    KresliGrid(BitMapGrid,BiMa.Canvas);
  end else begin
    With BiMa.Canvas do begin
      Pen.Mode := pmCopy;
      Brush.Color := BarvaPozadiObr;
      Brush.Style := bsSolid;
      FillRect(Rect(0, 0, BiMa.Width, BiMa.Height));
    end;
  end;

  BiMa.Canvas.Pen.Mode := pmCopy;

  ATopChlad.DelejKresliBiMa_TChl(BiMa, ObdBiMa, KoefZvetseni, PocAmi);

  if Timer2.Enabled then begin
    if (AZmana.X<>0) OR (AZmana.Y<>0) then begin
      DelejSpocAbsBodik(PocAmi, AKatva, KoefZvetseni, Kotva);
      DelejSpocAbsBodik(PocAmi, AKatvb, KoefZvetseni, Kotvb);
      with BiMa.Canvas do begin
        Pen.Style := psDot;
        Pen.Mode := pmXOR;
        Pen.Width := 1;
{        Pen.Color := clDkGray; }
        Pen.Color := BarvaPozadiObr;
        Brush.Style := bsClear;

        Case CisloSymbolu of
          1,11..14, SymUpravStropy, SymOblastProTisk, SymDelejZoomLupa :
                       Polyline([Kotva,Point(Kotva.X,Myska.Y),
                                 Myska,Point(Myska.X,Kotva.Y),Kotva]);
          2,21..24 : begin
            Polyline([Kotva, Myska]);
          end;
          3,31..34 : Polyline([Kotva, Myska]);
          5,26,28    : Polyline([Kotva, Point(Myska.X,Kotva.Y), Myska]);
          27,29      : Polyline([Kotva, Point(Kotva.X,Myska.Y), Myska]);
          15,17 : Polyline([Kotva,Kotvb, Point(Kotvb.X,Myska.Y),
                            Point(Kotva.X,Myska.Y), Kotva]);
          16,18 : Polyline([Kotva,Kotvb, Point(Myska.X,Kotvb.Y),
                            Point(Myska.X,Kotva.Y), Kotva]);
        end;
        Pen.Style := psSolid;
      end;
    end;
  end;

//  Formpaint(Self);
  PaintBox1.Invalidate; 
end;

Procedure TFrForm99.DelejMoveAmi_99(AmiClass : TAmiClass);
begin
  with ATopChlad do begin
    if AmiClass<>AktAmiMove then begin
      Try
        if AktAmiMove<>NIL then begin
          if BUkazatStoupacky then begin
            AktAmiMove.Kresli(PaintBox1.Canvas, KoefZvetseni, 10, PocAmi);
          end else begin
            if AktAmiMove=AktAmiOzn then begin
              AktAmiMove.Kresli(PaintBox1.Canvas, KoefZvetseni, 5, PocAmi);
            end else begin
              if AktAmiMove=AktAmiLisq then begin
                AktAmiMove.Kresli(PaintBox1.Canvas, KoefZvetseni, 7, PocAmi);
              end else begin
                if VybList.IndexOf(AktAmiMove)>=0 then
                  AktAmiMove.Kresli(PaintBox1.Canvas, KoefZvetseni, 2, PocAmi)
                else
                  AktAmiMove.Kresli(PaintBox1.Canvas, KoefZvetseni, 0, PocAmi);
              end;
            end;
          end;
        end;
        AktAmiMove := AmiClass;
        if AktAmiMove<>NIL then begin
          AktAmiMove.Kresli(PaintBox1.Canvas, KoefZvetseni, 1, PocAmi);
        end;
      except
        AktAmiMove := NIL;
      end;
    end;
  end;
end;

Procedure TFrForm99.DelejTabulky_99;
begin
  with ATopChlad do begin
    if AFormP<>NIL then
      TFormP(AFormP).DelejTabulky(VybList);

    if (AktAmiOzn<>NIL) AND (AktAmiOzn is TAmiTextik) then begin
      TextTextik := TAmiTextik(AktAmiOzn).Napis;
      TextFont.Assign(TAmiTextik(AktAmiOzn).Font);
    end;
  end;
  if ScrollBar1.CanFocus then begin
    if Owner is TForm then
      (Owner as TForm).ActiveControl := ScrollBar1;
  end;
end;

Function TFrForm99.ZadejAmiSoucAAA_99(AmiSoucAAA : TAmiSoucAAA; Opravuje : boolean) :
        boolean;
var
  i : integer;
  Zmena : boolean;
begin
  Result := TRUE;
  Zmena := FALSE;
  with AmiSoucAAA do begin
    with FormM do begin
      ListHod.Clear;
      For i := 0 to LHodnoty.Count-1 do
        ListHod.Add(LHodnoty[i]);
      StringOdp := Komponenty;

      ShowModal;
      if FormM.ModalResult=mrCancel then begin
        Result := FALSE;
      end else begin
        if Opravuje then begin
          Zmena := (Komponenty<>StringOdp) OR (ListHod.Count<>LHodnoty.Count);
          if NOT Zmena then begin
            for i := 0 to LHodnoty.Count-1 do begin
              Zmena := Zmena OR (LHodnoty[i]<>ListHod[i]);
              if Zmena then break;
            end;
          end;
          if Zmena then begin
            with ATopChlad do begin
              ZmenaProjektu := TRUE;
              MaVymazatVypocet := TRUE;
            end;
            DelejUmozniUndo_99;
            DelejUmozniUNDQ_99(histInsert, histAmiSoucAAA, NIL, NIL);          //?????
          end;
        end;
        LHodnoty.Clear;
        For i := 0 to ListHod.Count-1 do
          LHodnoty.Add(ListHod[i]);
        Komponenty := StringOdp;
      end;
    end;
  end;
  if Zmena then
    DelejPrvniREDQ_99(histInsert, histAmiSoucAAA, NIL, NIL);          //?????
end;

Function TFrForm99.BJsouTepelneZtraty : boolean;
var
  JmProjTepZtr : String;
//  JsouTepelneZtraty : boolean;
  Jmeno : String;
begin
  JmProjTepZtr := ProjektTepelnychZtrat;
  if JmProjTepZtr<>'' then begin
    JmProjTepZtr := ChangeFileExt(JmProjTepZtr, ExtensionIMI);
    JmProjTepZtr := ExtractFileName(JmProjTepZtr);
  end else begin
    Result := FALSE;
    exit;
  end;

  Jmeno := ATopChlad.JmenoProjektu;
  if Jmeno<>'' then begin
    Jmeno := ChangeFileExt(Jmeno, ExtensionIMI);
    Jmeno := ExtractFileName(Jmeno);
  end;

  if Jmeno='' then begin
    Result := TRUE;
//    JsouTepelneZtraty := TRUE;
  end else begin
    Result := UpperCase(JmProjTepZtr)=UpperCase(Jmeno);
//    JsouTepelneZtraty := UpperCase(JmProjTepZtr)=UpperCase(Jmeno);
  end;
end;

Procedure TFrForm99.VlozNovyZoom_99(APosX, APosY : integer; AKoef : extended);
var
  PRecZoom : PPosiceOknaZ;
begin
  DelejZrusNastZoomu_99;
  New(PRecZoom);
  with PRecZoom^ do begin
    PosX := APosX;
    PosY := APosY;
    KoefInt := Round(AKoef*1000000);
  end;
  ListNastaveniZoomu.Add(PRecZoom);
  inc(PosicevNastZoomu);
  if AForm_A is TFormA then
    TFormA(AForm_A).NastavToolB97Zobr5_6(PosicevNastZoomu>0, FALSE);
end;

Procedure TFrForm99.DelejZrusNastZoomu_99;
var
  i : integer;
  PRecZoom : PPosiceOknaZ;
begin
  if Assigned(ListNastaveniZoomu) then begin
    for i := ListNastaveniZoomu.Count-1 downto PosicevNastZoomu+1 do begin
      PRecZoom := PPosiceOknaZ(ListNastaveniZoomu[i]);
      ListNastaveniZoomu.Delete(i);
      Dispose(PRecZoom);
    end;
  end;
end;

Procedure TFrForm99.SpoctiKorku_99;
var
  Sit : integer;
  X,Y : integer;
begin
  Sit := SpSit(KoefZvetseni);
  X := (PocAmi.X mod Sit);
  if X<0 then X := X+Sit;
  Korka.X := Round(X*KoefZvetseni*JMetrMM);
  if Korka.X>AbsGriq.X then Korka.X := Korka.X-AbsGriq.X;
  Y := (-PocAmi.Y mod Sit);
  if Y<0 then Y := Y+Sit;
  Korka.Y := Round(Y*KoefZvetseni*JMetrMM);
  if Korka.Y>AbsGriq.Y then Korka.Y := Korka.Y-AbsGriq.Y;
end;

procedure TFrForm99.BitBtn0MouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if Button=mbLeft then begin
    if NOT Timer4.Enabled then Timer4.Enabled := TRUE;
    KnofZvets[1].Down := FALSE;
  end;
end;

procedure TFrForm99.BitBtn0MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  P1, P2 : TPoint;
  Control : TControl;
begin
{  if NOT SpeedButton1.MouseInControl then} begin
    if ssLeft in Shift then begin
      if Sender is TSpeedButton then begin
        P1 := TSpeedButton(Sender).ClientToScreen(Point(X,Y));
        P2 := Panel1.ScreenToClient(P1);
        Control := Panel1.ControlAtPos(P2, FALSE);
        if Control=NIL then begin

          KnofZvets[1].Down := TRUE;
          KnofZvets[1].Down := FALSE;
        end else begin
          if Control is TSpeedButton then begin
            if NOT TSpeedButton(Control).Down then
              TSpeedButton(Control).Down := TRUE;

          end;
        end;
      end;
    end;
  end;
end;

procedure TFrForm99.BitBtn0MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  i : integer;
  Control : TControl;
  ATag : integer;
begin
  Timer4.Enabled := FALSE;
  ATag := TControl(Sender).Tag;
  if Panel1.Visible then begin
    for i := 0 to Panel1.ControlCount-1 do begin
      Control := Panel1.Controls[i];
      if Control is TSpeedButton then begin
        if TSpeedButton(Control).Down then begin

          TSpeedButton(Control).Down := FALSE;
          KnofZvClick(Control);

          Panel1.Visible := FALSE;
          if Sender is TSpeedButton then
            TSpeedButton(Sender).Down := TRUE;
          exit;
        end;
      end;
    end;
    KnofZvets[1].Down := TRUE;
    KnofZvets[1].Down := FALSE;
  end;
end;

procedure TFrForm99.BitBtn0Click(Sender: TObject);
begin
  Timer4.Enabled := FALSE;
  VidPanel1_99(TRUE);
end;

procedure TFrForm99.Timer4Timer(Sender: TObject);
begin
  Timer4.Enabled := FALSE;
  if NOT Panel1.Visible then
    Panel1.Visible := TRUE;
end;

procedure TFrForm99.AToolB97Click_99(ATag : integer);
var
  V : integer;
begin

  VidPanel1_99(FALSE);
  JakobyPageControlChange;
  CisloCimJede_99 := -TypAmi[ATag];

  DelejVyberKurzor_99(ATag);

  if CisloCimJede_99=0 then begin
    JakobyPageControlChange;
    DelejVyberKurzor_99(crDefault);
  end;

  VkladatObloucky := FALSE;
  CitacKlikuObloucku := 0;

  Case CisloCimJede_99 of
    -TypRad1-20..-TypRad1 : begin
      PosRad1.Pocatek := PocAmi;
      V := DejVyskuRadiatoru(ATopChlad.SymbolAmi[ATag]);
      PosRad1.ZmenTyp(-CisloCimJede_99);
      PosRad1.ZadejVysku(V);
      PosRad1.AbsObd(KoefZvetseni, PocAmi);
    end;

    -TypRad2-15..-TypRad2 : begin
      PosRad2.Pocatek := PocAmi;
      PosRad2.ZmenTyp(-CisloCimJede_99);
      PosRad2.AbsObd(KoefZvetseni, PocAmi);
    end;

    -TypChladic1-5..-TypChladic1 : begin
      PosChladic1.Pocatek := PocAmi;
      PosChladic1.ZmenTyp(-CisloCimJede_99);
      PosChladic1.AbsObd(KoefZvetseni, PocAmi);
    end;

    -TypOTChladic1-5..-TypOTChladic1 : begin
      PosOTChladic1.Pocatek := PocAmi;
      PosOTChladic1.ZmenTyp(-CisloCimJede_99);
      PosOTChladic1.AbsObd(KoefZvetseni, PocAmi);
    end;

    -TypObecnaPataC-4..-TypKotel : begin
      PosKotel.Pocatek := PocAmi;
      PosKotel.ZmenTyp(-CisloCimJede_99);
      PosKotel.AbsObd(KoefZvetseni, PocAmi);
    end;

    -TypSchema0-15..-TypSchema0 : begin
      PosSchema := PosPoleSchemat[-CisloCimJede_99-TypSchema0];
      PosSchema.Pocatek := PocAmi;
      PosSchema.ZmenTyp(-CisloCimJede_99);
      PosSchema.AbsObd(KoefZvetseni, PocAmi);
      PosSchema.Kresli(NIL, KoefZvetseni, 4, PocAmi);
      DelejInvalidu_99;
    end;

    -TypAmiOblouk2 : VkladatObloucky := TRUE;

//    -TypPneuH-79..-TypPneuH : begin
//    -TypPneuHSafetyValve+1..-TypPneuHStatico : begin
    -TypPneuH-79..-TypPneuHStatico : begin
      PosPneuH := PosPolePneuH[-CisloCimJede_99];
      PosPneuH.Pocatek := PocAmi;
      PosPneuH.ZmenTyp(-CisloCimJede_99);
      PosPneuH.AbsObd(KoefZvetseni, PocAmi);
      PosPneuH.Kresli(NIL, KoefZvetseni, 4, PocAmi);
      DelejInvalidu_99;
    end;

  end;

end;

procedure TFrForm99.VybratVse1Click_99;
var
  i : integer;
  AC : TAmiClass;
begin
  with ATopChlad do begin
    DelejOznAmi_99(NIL);
    VybList.Clear;
    for i := 0 to AmiLispik.Count-1 do begin
      AC := AmiLispik.Items[i];
      VybList.Add(AC);
    end;
  end;

  DelejUmozniUpravy_99;
  DelejTabulky_99;
  DelejInvalidu_99;
end;

procedure TFrForm99.VybratVse2Click(Sender: TObject);
begin
  VybratVse1Click_99;
end;

procedure TFrForm99.NastavPrazdnyProjekt_99;
var
  i : integer;
  S : String;
  JmProjTepZtr : String;
  JsouTepelneZtraty : boolean;
begin
  KoefZvetseni := 1;
  if ATopChlad=NIL then
    exit;
  with ATopChlad do begin
    ZadatJmeno := TRUE;
  //  Caption := DejZakladniCaption;
  //  FormularGridu.Caption := Caption;
    AFormP.Caption := Caption;

    KnofZvClick(KnofZvets[3]);

    for i := 1 to PocPopisuEdit do
      PopisyEdit[i] := '';
    for i := 1 to PocPopisuMemo do
      PopisyMem1[i] := '';

    MuzeScroll := FALSE;
    PocAmi := Pocatek;
    PoOAmi := Pocatek;
    ScrollBar1.Position := PocAmi.X;
    ScrollBar2.Position := -PocAmi.Y;
    MuzeScroll := TRUE;

  {  ZobrVrazOdpory    := TRUE;
    ZobrVyplnOT := TRUE;
    ZobrPopisTrubek   := TRUE;
    ZobrPopisStoup    := TRUE;
    ZobrPrutokTrubek  := TRUE;

    ZobrPopisVentilu  := TRUE;
    ZobrPrutokVentilu := TRUE;

    ZobrCimru         := TRUE;
    ZobrPopisPokoju   := TRUE;
    ZobrPopisPoknadOT := FALSE;
    ZobrJmemoPokoju   := TRUE;
    ZobrTeplaQPokoju  := TRUE;
    ZobrCool_Heat     := FALSE;



    ZobrPopisOT       := TRUE;
    ZobrPopisProcent  := TRUE;

    ZobrKoty          := TRUE;
    ZobrTextiky       := TRUE;
    ZobrCary          := TRUE;  }

    SpocitatBodySpojTr := TRUE;
    SpocitatBodyNedotahuTr := TRUE;
{    KoefZvetseni := 1;
    Sitnice := SpSit(KoefZvetseni);
    PripravGrid(BitMapGrid,KoefZvetseni,clDkGray,Grid); }

  {  GenerovatSmerVody1.Checked := TRUE;
    GenerovatZeslTrub1.Checked := TRUE;
    AGenerovatSmerVody1.Checked := TRUE;
    AGenerovatZeslTrub1.Checked := TRUE; }

    PosicevNastZoomu := -1;
    DelejZrusNastZoomu_99;

  //  BJeOchlazovani := FALSE;

  //  ToolB97Zobr2.Down := FALSE;
  //  ToolB97Zobr3.Down := FALSE;

    NastavToolB97Zobr5_6_FormA(FALSE, FALSE);

  //  PrycsVypoctem;

    if AForm_A is TFormA then
      TFormA(AForm_A).NastavListyKnofliky(FALSE);
    if AForm_A is TForm_Rb1 then
      TForm_Rb1(AForm_A).NastavRibbonKnofliky(FALSE);

    NastavDataPrazdnehoProjektu_99;

  (*  TeplotaTamH := TeplotaNormTamH;
    TeplotaZpetH := TeplotaNormZpetH;
    TeplotaStredH := Round((TeplotaTamH+TeplotaZpetH)*0.5);
    KoefAlfa := KoefAlfaNorm;
    KoefDPC := KoefDPCNorm;

    DeltaTH := TeplotaTamH-TeplotaZpetH;
    dPZdrojeH := 0;
    dPTermostVentiluH := dPNormTermostVentilu;
    dPBalancnihoVentiluH := dPNormBalancnihoVentilu;
    dPZpetSroubeniH := dPNormLibVentilu;
    dPRegulacnihoVentiluH := dPNormRegulacnihoVentilu;
    MinAutorita := MinNormAutorita;
    dispTlakCerpadla := dispNormTlakCerpadla;
    Korekce1dP_Ro := Korekce1NormdP_Ro;
    TlakovySpad := TlakovyNormSpad;         {150 Pa/m }
    BAbsTlakovySpad := FALSE;
    MaxRychlostvTrubce := 300;  { 3.0 m/s}
    RychlostvTrubce := 30;     { 0.3 m/s}
    BAbsRychlostvTrubce := FALSE;
    BPocitat_sKoefDPC := FALSE;

    TeplotaNevytapeneMistnosti := 0;
    MinimalniDiamTrubky := 0;

    TeplotaTamC := TeplotaNormTamC;
    TeplotaZpetC := TeplotaNormZpetC;
    TeplotaStredC := Round((TeplotaTamC+TeplotaZpetC)*0.5);

    DeltaTC := TeplotaZpetC-TeplotaTamC;
    TeplotaNechlazeneMistnosti := TeplotaNormNechlazeneMistnosti;
    dPZdrojeC := 0;
  //  Parametry_Latky(TeplotaTamH, TeplotaZpetH, Ro_Tam, Ro_Zpet, Ro_M, dp_ro,
  //                  Ny_M, Ny_Tam, Ny_Zpet);  *)
  end;
end;

procedure TFrForm99.NastavDataPrazdnehoProjektu_99;
begin
  if ATopChlad<>NIL then
    ATopChlad.NastavDataPrazdnehoProjektu;
end;

procedure TFrForm99.OznacitMistnosti1Click_99;
begin
  if ATopChlad<>NIL then
    ATopChlad.OznacitMistnosti_TChl;
  DelejInvalidu_99;
end;

Function TFrForm99.ZadejPolohuRazitka_99(ARazitko : TAmiRazitko; Opravuje : boolean) :
         boolean;
var
  Oprav : boolean;
begin
  Oprav := FALSE;
  Result := TRUE;
  with FormR do begin
    AUmisteni := ARazitko.Umisteni;
    case AUmisteni of
      1 : RadioButton1.Checked := TRUE;
      2 : RadioButton2.Checked := TRUE;
      3 : RadioButton3.Checked := TRUE;
      4 : RadioButton4.Checked := TRUE;
      5 : RadioButton5.Checked := TRUE;
      6 : RadioButton6.Checked := TRUE;
      7 : RadioButton7.Checked := TRUE;
      8 : RadioButton8.Checked := TRUE;
      9 : RadioButton9.Checked := TRUE;
    end;
    AVMeritku := ARazitko.VMeritku;
    ASirkaR := ARazitko.Sirka;
    Edit1.Text := IntToStr(ASirkaR);

    if AVMeritku then begin
      RadioButtonR1.Checked := TRUE;
      Label2.Caption := SSirkaRazitkaM10;
    end else begin
      RadioButtonR2.Checked := TRUE;
      Label2.Caption := SSirkaRazitkaAbs;
    end;

    FormR.ShowModal;
    if FormR.ModalResult=mrCancel then begin
      Result := FALSE;
    end else begin
      AVmeritku := RadioButtonR1.Checked;
      if Opravuje AND ((ARazitko.Umisteni<>AUmisteni) OR
                       (ARazitko.VMeritku<>AVmeritku) OR
                       (ARazitko.Sirka<>ASirkaR)) then begin
        ATopChlad.ZmenaProjektu := TRUE;
        DelejUmozniUndo_99;
        DelejUmozniUNDQ_99(histInsert, histRazitko1, NIL, NIL);          //?????
        Oprav := TRUE;
      end;
      ARazitko.Umisteni := AUmisteni;
      ARazitko.VMeritku := AVMeritku;
      ARazitko.Sirka := ASirkaR;
      if Oprav then begin
        DelejPrvniREDQ_99(histInsert, histRazitko1, NIL, NIL);          //?????
        DelejInvalidu_99;
      end;
    end;
  end;
end;

Procedure TFrForm99.DelejVlozAmi(AbsBod : TPoint; ACisloCimJede : integer);

Function SpocitejPolohuVenti4(BodUch1, BodUch2 : TPoint;
              var AC1, AC2 : TAmiClass;
              var B1, B2, B3 : TPoint; TypObjektu : integer) : integer;

Procedure UpravKonce(Jak : integer);
begin
  case Jak of
    -1 : begin

    end;
  end;   { case }

end;


var
  DifAlfa : extended;
  DifVekt : TPoint;
  BodUch3 : TPoint;
  Bp3A, Bp3B, Bp4B, Bp3, Bp4 : TPoint;
  DistB3B4 : extended;
  AC3 : TAmiClass;

  VektHor, VektVert : TPoint;
  VektB2 : TPoint;

  SmerovyVektor : TPoint;
  DV : extended;
const
  VzdHor  : array[TypVenti4..TypVenti4+3] of integer = (150,   0, 200, 150);
  VzdVert : array[TypVenti4..TypVenti4+3] of integer = (200, 100, 150,   0);
  VzdB2   : array[TypVenti4..TypVenti4+3] of integer = (300, 200, 400, 250);
  MaxKorekce = 300;

begin
  Result := 0;
  with ATopChlad do begin
    AC1 := AmiLispik.NajdiTrubkuBod(BodUch1, Griq.Y, 0);
    if (AC1=NIL) AND ((ACisloCimJede>=TypMer2-10) AND (ACisloCimJede<=TypMer2)) then
      AC1 := AmiLispik.NajdiTrubkuBod(BodUch1, Griq.Y, -1);
    if AC1<>NIL then
      BodUch1 := NejblBodUsecky(BodUch1, AC1.Pocatek, AC1.AbsKonec);

    AC2 := AmiLispik.NajdiTrubkuBod(BodUch2, Griq.Y, 0);
    if (AC2=NIL) AND ((ACisloCimJede>=TypMer2-10) AND (ACisloCimJede<=TypMer2)) then
      AC2 := AmiLispik.NajdiTrubkuBod(BodUch2, Griq.Y, -1);
    if AC2<>NIL then
      BodUch2 := NejblBodUsecky(BodUch2, AC2.Pocatek, AC2.AbsKonec);
    if (AC1=NIL) AND (AC2<>NIL) then begin
      AC1 := AC2;
      BodUch3 := BodUch1;
      BodUch1 := BodUch2;
      BodUch2 := BodUch3;
      AC2 := NIL;
    end;
    BodUch3 := BodUch2;

    DifVekt := Point(BodUch2.X-BodUch1.X, BodUch2.Y-BodUch1.Y);

    B1 := BodUch1;
    B2 := BodUch2;
    B3 := Point((B1.X+B2.X) div 2, (B1.Y+B2.Y) div 2);


    Case TypObjektu of
      TypVenti4+1, TypVenti4+2, TypMer2+5 : begin
        if (AC1<>NIL) AND (AC1.Typ<>TypTrubka1) then begin
          AC3 := AC1;
          AC1 := AC2;
          AC2 := AC3;
          BodUch3 := BodUch1;
          BodUch1 := BodUch2;
          BodUch2 := BodUch3;
        end;
        if (AC1<>NIL) AND (AC1.Typ=TypTrubka1) then SmerovyVektor := AC1.RelKonec
               { predpokladame, ze AC1 je cervena trubka }
                                               else SmerovyVektor := Point(1000, 0);
               { jinak vodorovne }
        if DelkaVektoru(SmerovyVektor)=0 then SmerovyVektor := Point(1000, 0);
        if (Abs(SmerovyVektor.X)<Abs(SmerovyVektor.Y)) AND
           (TypObjektu=TypVenti4+1) then
          TypObjektu := TypVenti4;
        if (TypObjektu=TypMer2+5) then
          TypObjektu := TypVenti4+3;

        DV := DelkaVektoru(SmerovyVektor);
        VektVert.X :=  Round(SmerovyVektor.Y*VzdVert[TypObjektu]/DV);
        VektVert.Y := -Round(SmerovyVektor.X*VzdVert[TypObjektu]/DV);
        VektHor.X  :=  Round(SmerovyVektor.X*VzdHor[TypObjektu]/DV);
        VektHor.Y  :=  Round(SmerovyVektor.Y*VzdHor[TypObjektu]/DV);
        VektB2.X  :=  Round(SmerovyVektor.X*VzdB2[TypObjektu]/DV);
        VektB2.Y  :=  Round(SmerovyVektor.Y*VzdB2[TypObjektu]/DV);
        { zkoumame polohu BodUch2 vzhledem k SmerovyVektor, }
        {  B3 musi lezet na druhe strane }
        { zkousi vzdalenost symetrickych bodu od BodUch2 }
        Bp3A := Point(BodUch1.X+VektVert.X, BodUch1.Y+VektVert.Y);
        Bp3B := Point(BodUch1.X-VektVert.X, BodUch1.Y-VektVert.Y);
        if DistBodu(Bp3B, BodUch2)>DistBodu(Bp3A, BodUch2) then
          VektVert := Point(-VektVert.X, -VektVert.Y);

        Bp3A := Point(BodUch1.X+VektB2.X, BodUch1.Y+VektB2.Y);
        Bp3B := Point(BodUch1.X-VektB2.X, BodUch1.Y-VektB2.Y);
        if DistBodu(Bp3A, BodUch2)>DistBodu(Bp3B, BodUch2) then begin
          VektHor := Point(-VektHor.X, -VektHor.Y);
          VektB2 := Point(-VektB2.X, -VektB2.Y);
          Bp3A := Bp3B;
        end;

        B3.X := BodUch1.X+VektVert.X+VektHor.X;
        B3.Y := BodUch1.Y+VektVert.Y+VektHor.Y;

        if AC2<>NIL then begin
        {  bylo by asi dobre upresnit spocitat polohu BodUch2, pokud BodUch2 lezi
           dostatecne blizko zhruba ocekavanemu bodu na trubce, }
          if PrusecikB(Bp3A, Point(Bp3A.X+SmerovyVektor.Y, Bp3A.Y-SmerovyVektor.X),
                       AC2.Pocatek, AC2.AbsKonec, B2) then begin
            if DistBodu(BodUch2, B2)<=MaxKorekce then
              BodUch2 := B2;
          end;
        end;
        B1 := BodUch1;
        B2 := BodUch2;
      end;

      TypMer2+1, TypMer2+2, TypMer2+3 : begin
        if AC1<>NIL then begin
          if (AC2<>NIL) AND (AC1<>AC2) then begin
            if SkoroRovnobezneVekt(AC1.RelKonec, AC2.RelKonec) then begin
              if ChteneKolmeVekt(AC1.RelKonec, DifVekt) then
                BodUch3 := NejblBodUsecky(BodUch1, AC2.Pocatek, AC2.AbsKonec);
              if DistBodu(BodUch1, BodUch3)>=MinDistUchytuMerice2 then begin
                { kolecko se vejde mezi useky }
                B1 := BodUch1;
                B2 := BodUch3;
                B3 := Point((B1.X+B2.X) div 2, (B1.Y+B2.Y) div 2);
              end else begin
                B1 := BodUch1;
                { hleda bod na AC2 ve vzdalenosti MinDistUchytuMerice2
                  ve smeru BodUch2-BodUch3 }
                B2 := NajdiBodVeSmeru(BodUch3, AC2, MinDistUchytuMerice2, BodUch2);
                Bp3 := Point((BodUch3.X+B2.X) div 2, (BodUch3.Y+B2.Y) div 2);
                Bp4 := Point(B1.X+Bp3.X-BodUch3.X, B1.Y+Bp3.Y-BodUch3.Y);
                DistB3B4 := DistBodu(Bp3, Bp4);
                if DistB3B4>0 then begin
                  B3.X := Bp3.X+Round((Bp4.X-Bp3.X)*
                               (DistB3B4+MinDistUchytuMerice1)/DistB3B4);
                  B3.Y := Bp3.Y+Round((Bp4.Y-Bp3.Y)*
                               (DistB3B4+MinDistUchytuMerice1)/DistB3B4);
                end else begin
                  B3.X := Bp3.X+(Bp3.Y-BodUch3.Y);
                  B3.Y := Bp3.Y-(Bp3.X-BodUch3.X);
                end;
              end;
            end else begin
              if DistBodu(BodUch1, BodUch3)>=MinDistUchytuMerice2 then begin
                { kolecko se vejde mezi useky }
                B1 := BodUch1;
                B2 := BodUch3;
                B3 := Point((B1.X+B2.X) div 2, (B1.Y+B2.Y) div 2);
              end else begin
                B1 := BodUch1;
                { hleda bod na AC2 ve vzdalenosti MinDistUchytuMerice2
                  ve smeru BodUch2-BodUch3 }
                B2 := NajdiBodVeSmeru(BodUch3, AC2, MinDistUchytuMerice2, BodUch2);
                Bp3 := Point((BodUch3.X+B2.X) div 2, (BodUch3.Y+B2.Y) div 2);
                Bp4 := Point(B1.X+Bp3.X-BodUch3.X, B1.Y+Bp3.Y-BodUch3.Y);
                DistB3B4 := DistBodu(Bp3, Bp4);
                if DistB3B4>0 then begin
                  B3.X := Bp3.X+Round((Bp4.X-Bp3.X)*
                               (DistB3B4+MinDistUchytuMerice1)/DistB3B4);
                  B3.Y := Bp3.Y+Round((Bp4.Y-Bp3.Y)*
                               (DistB3B4+MinDistUchytuMerice1)/DistB3B4);
                end else begin
                  B3.X := Bp3.X+(Bp3.Y-BodUch3.Y);
                  B3.Y := Bp3.Y-(Bp3.X-BodUch3.X);
                end;
              end;
            end;    { zatim }
          end else begin
            if AC1=AC2 then begin
              { snazi se oba konce pripojit na tyz usek trubky }
              Result := -1;
            end else begin
              { druhy konec visi ve vzduchu }
              Result := -2;
            end;
          end;
        end else begin
          if AC2<>NIL then begin
          { prvni konec visi ve vzduchu }
            Result := -3;
          end else begin
          { oba konce visi ve vzduchu }
            Result := -4;
          end;
        end;
        if Result<0 then
          UpravKonce(Result);
      end;  {  TypMer2+1, TypMer2+2, TypMer2+3  }
    end;    {  case }
  end;
end;

var
  AmiClass, AmiClast, AC1, AC2 : TAmiClass;

  AmiLispikCountOld : integer;

  DifAlfa : extended;

  ABod, BBod, Bodik, Bodil, BodiP : TPoint;
  DX : integer;
  S : String;
  i, CB, N : integer;
  VyskaR : integer;
  Bo1, Bo2, Bo3 : TPoint;
  D1, Dist : extended;

  SA, CA : extended;
  AR : extended;
  Alf : extended;
{  VlozilTypVyskaA : boolean; }
begin
{  VlozilTypVyskaA := FALSE; }
  with ATopChlad do begin
    MaVymazatVypocet := TRUE;
    DelejSpocRealBodik(PocAmi, AbsBod, KoefZvetseni, BodiP);
    DelejSpocitejBodGrid(PocAmi, AbsBod, Griq, KoefZvetseni, Bodik);
    DelejSpocitejBodGrid(PocAmi, Kotva, Griq, KoefZvetseni, Bodil);
    AmiClass := NIL;
    AmiClast := NIL;
    PraveVlozenyFalse(AmiLispik);
    AmiLispikCount := AmiLispik.Count;
    AmiLispikCountOld := AmiLispikCount;

    case ACisloCimJede of
      -TypClipboard : begin
        if JakobyClipBoard.Count>0 then begin
          ZkusSpojeniaRozpojeniTrubek(JakobyClipBoard);
          SpojitaRozdelitTrubky :=
            SpojitaRozdelitTrubky OR RozdelitTrubkyPokoji;

          DelejUmozniUNDO_TChl;
          DelejUmozniUNDQ_TChl(histInsert, histClipboard, NIL, NIL);

          DelejVlozClipboard_99(Bodik);
          JakobyPageControlChange;
          AmiClass := NIL;
          DelejPrvniREDQ_TChl(histInsert, histClipboard, NIL, NIL);
          SpocitatBodySpojTr := TRUE;
          SpocitatBodyNedotahuTr := TRUE;
        end;
      end;

      -TypStrop1 : begin
        DelejUmozniUNDO_TChl;
        DelejUmozniUNDQ_TChl(histInsert, histVlozitStropy, NIL, NIL);

        MaVymazatVypocet := FALSE;
        FormStrop1.DelejVlozStrop1(Bodik, ATopChlad.AmiLispik);
  {      AktAmiOzn := NIL;

        DelejInvalidu_TChl; }
        JakobyPageControlChange;
        AmiClass := NIL;
        DelejPrvniREDQ_TChl(histInsert, histVlozitStropy, NIL, NIL);
      end;

      -TypStrop2 : begin
        MaVymazatVypocet := FALSE;
        if ((Abs(Bodik.X-Bodil.X)<MinDelkaStr1) OR
            (Abs(Bodik.Y-Bodil.Y)<MinSilaStr1)) then begin

        end else begin
          ABod.X := Min(Bodik.X,Bodil.X);
          ABod.Y := Min(Bodik.Y,Bodil.Y);
          BBod.X := Max(Bodik.X,Bodil.X);
          BBod.Y := Max(Bodik.Y,Bodil.Y);
          if DelejUpravStrop2(ABod, BBod) then begin
            AmiClass := TAmiStrop1.Creatf(AmiLispik,
              ABod, Point(BBod.X-ABod.X, BBod.Y-ABod.Y), 300);
          end;
        end;
      end;


      -TypVyskaA : begin
        MaVymazatVypocet := FALSE;
        AmiClass := TAmiVyska.Creatf(AmiLispik, Bodik, TypVyskaA);
        TAmiVyska(AmiClass).NajdiStrop(AmiLispik);
  {      AForm99.JakobyPageControlChange;

        MuzeScroll := FALSE;
        ScrollBar1.Position := -Round(AbsBod.X/(KoefZvetseni*JMetrMM));
        ScrollBar2.Position := -Round(AbsBod.Y/(KoefZvetseni*JMetrMM));
        MuzeScroll := TRUE; }
        SpocitatBodySpojTr := TRUE;
        SpocitatBodyNedotahuTr := TRUE;

      end;

      -TypVyskaR : begin
        MaVymazatVypocet := FALSE;
        AmiClass := TAmiVyska.Creatf(AmiLispik, Bodik, TypVyskaR);
        TAmiVyska(AmiClass).NajdiStrop(AmiLispik);
      end;

      -TypCeTeMa-9..-TypCeTeMa, -TypArm101-13..-TypArm101 : begin
        AC1 := AmiLispik.NajdiTrubkuBod(Bodip, EpsilonRel, 0);
        if AC1=NIL then
          AC1 := AmiLispik.NajdiTrubkuBod(Bodip, Griq.Y, 0);
        if AC1=NIL then
          AC1 := AmiLispik.NajdiTrubkuBod(Bodip, Griq.Y, -1);

        if AC1<>NIL then
          Bodik := NejblBodPrimky(BodiP,AC1.Pocatek,AC1.AbsKonec);
        AmiClass := TAmiAAA.Creatf(AmiLispik,Bodik,-ACisloCimJede);
        if AC1<>NIL then begin
          AmiClass.AmCl := AC1;
  {        AC1.Pripojeni.Add(AmiClass); }
        end;
      end;

      -TypSoucArm : begin
        AC1 := AmiLispik.NajdiTrubkuBod(Bodip, EpsilonRel, 0);
        if AC1=NIL then
          AC1 := AmiLispik.NajdiTrubkuBod(Bodip, Griq.Y, 0);
        if AC1=NIL then
          AC1 := AmiLispik.NajdiTrubkuBod(Bodip, Griq.Y, -1);
        if AC1<>NIL then
          Bodik := NejblBodPrimky(BodiP,AC1.Pocatek,AC1.AbsKonec);
        AmiClass := TAmiSoucAAA.Creatf(AmiLispik,Bodik,-ACisloCimJede);
        AmiClass.Kresli(PaintBox1.Canvas,KoefZvetseni,0,PocAmi);
        if AC1<>NIL then begin
          AmiClass.AmCl := AC1;
        end;
        with AmiClass as TAmiSoucAAA do begin
          For i := 0 to ListKompOdp.Count-1 do
            LHodnoty.Add(ListKompOdp[i]);
          Komponenty := StrKompOdp;
        end;

        if NOT ZadejAmiSoucAAA_99(TAmiSoucAAA(AmiClass), FALSE) then begin
          AmiClass.Free;
          AmiClass := NIL;
        end;
      end;


      -TypBubSluVent..-TypVenti1 : begin
        if ACisloCimJede=-TypOdvzdVent then begin
          AC1 := AmiLispik.NajdiRadiatorBod(Bodip, Griq.Y, TypOdvzdVent, Bodik);
        end else begin
          if ACisloCimJede=-TypVypoustVent then begin
            AC1 := AmiLispik.NajdiRadiatorBod(Bodip, Griq.Y, TypVypoustVent, Bodik);
            if AC1=NIL then begin
              AC1 := AmiLispik.NajdiTrubkuBod(Bodip, Griq.Y, 0);
              if AC1=NIL then
                AC1 := AmiLispik.NajdiTrubkuBod(Bodip, Griq.Y, -1);
              if AC1<>NIL then
                Bodik := NejblBodPrimky(BodiP,AC1.Pocatek,AC1.AbsKonec);
            end;
          end else begin
            AC1 := AmiLispik.NajdiTrubkuBod(Bodip, Griq.Y, 0);
            if AC1=NIL then
              AC1 := AmiLispik.NajdiTrubkuBod(Bodip, Griq.Y, -1);
            if AC1<>NIL then
              Bodik := NejblBodPrimky(BodiP,AC1.Pocatek,AC1.AbsKonec);
          end;
        end;

        AmiClass := TAmiVenti1.Creatf(AmiLispik,Bodik,-ACisloCimJede);
        TAmiVentil(AmiClass).Symbol := SymbolAmi[FunTypAmi(-ACisloCimJede)];
        if (ACisloCimJede=-TypVentRegTlakDifOld) OR (ACisloCimJede=-TypVentRegPrutok) then
          TAmiVentil(AmiClass).Symbol := SymbolAmi[-ACisloCimJede-TypVentRegTlakDifOld+59];

{        if (ACisloCimJede>-TypVenti1-20) OR (ACisloCimJede>-TypVenti1-20) then
          TAmiVentil(AmiClass).Symbol := SymbolAmi[-ACisloCimJede-TypVenti1+41];
        if (ACisloCimJede=-TypVentRegTlakDifOld) OR (ACisloCimJede=-TypVentRegPrutok) then
          TAmiVentil(AmiClass).Symbol := SymbolAmi[-ACisloCimJede-TypVentRegTlakDifOld+59];
        if (ACisloCimJede=-TypVentDPC) then
          TAmiVentil(AmiClass).Symbol := SymbolAmi[-ACisloCimJede-TypVentDPC+59]; // 57];
        if (ACisloCimJede=-TypVentABV) OR (ACisloCimJede=-TypVentABV-1) OR
           (ACisloCimJede=-TypVentABV-2) OR (ACisloCimJede=-TypVentABV-3) OR
           (ACisloCimJede=-TypVentABV-4) then
          TAmiVentil(AmiClass).Symbol := SymbolAmi[-ACisloCimJede-TypVentABV+1]; // 61]; }

        if AC1<>NIL then begin
          AmiClass.AmCl := AC1;
          if (ACisloCimJede=-TypFiltr) OR (ACisloCimJede=-TypZpetnaKlapka) then begin
            if ((AC1.Alfa>Pi/2) OR (AC1.Alfa<-Pi/2)) AND (AC1.Typ in [TypTrubka1, TypTrubka0, TypTrubka3]) then
              AmiClass.Orientace := 1;
            if ((AC1.Alfa<Pi/2) AND (AC1.Alfa>-Pi/2) AND (AC1.Typ in [TypTrubka2, TypTrubka4])) then
              AmiClass.Orientace := 1;
  // COTRUBKA0?
          end;
  {        AC1.Pripojeni.Add(AmiClass); }
        end;
      end;


      -TypVentiPneuH-20..-TypVentiPneuH : begin
        case ACisloCimJede of
          -TypVentiPneuHAirVent : begin
            AC1 := AmiLispik.NajdiTrubkuBod(Bodip, Griq.Y, 0);
            if AC1=NIL then
              AC1 := AmiLispik.NajdiTrubkuBod(Bodip, Griq.Y, -1);
            if AC1<>NIL then
              Bodik := NejblBodPrimky(BodiP, AC1.Pocatek, AC1.AbsKonec);
          end;

          -TypVentiPneuHSafetyValve : begin
            AC1 := AmiLispik.NajdiTrubkuBod(Bodip, Griq.Y, TypTrubkaCara10);
            if AC1<>NIL then
              Bodik := NejblBodPrimky(BodiP, AC1.Pocatek, AC1.AbsKonec);
          end;

          -TypVentiPneuHShutoffValve : begin
            for i := 0 to AmiLispik.Count-1 do begin
              AC1 := AmiLispik[i];
              if AC1 is TAmiPneuH then begin
                if TAmiPneuH(AC1).DotazKapilary(Bodip, EpsilonRel, CB)>0 then begin
                  ABod := AC1.BodyUch[CB];
                  BBod := AC1.BodyUch[CB+1];
                  Bodik := NejblBodPrimky(BodiP, ABod, BBod);
                  break;
                end;
              end;
            end;   // for i
          end;
        end;

        AmiClass := TAmiVentiPneuH.Creatf(AmiLispik, Bodik, -ACisloCimJede);
        if AC1<>NIL then begin
          AmiClass.AmCl := AC1;
        end;
      end;

      -TypAlpha : begin
        Dist := MaxInt;
        AC2 := NIL;
        for i := 0 to AmiLispik.Count-1 do begin
          AC1 := AmiLispik[i];
          if AC1.Typ=TypTrubka0 then begin
            D1 := DistBodu(AC1.Pocatek, BodiK);
            if D1<Dist then begin
              ABod := AC1.Pocatek;
              AC2 := AC1;
              Dist := D1;
            end;
            D1 := DistBodu(AC1.AbsKonec, BodiK);
            if D1<Dist then begin
              ABod := AC1.AbsKonec;
              AC2 := AC1;
              Dist := D1;
            end;
          end;
        end;
        if Dist>=EpsilonRel then
          ABod := Bodik;
        AmiClass := TAmiVenti1.Creatf(AmiLispik, ABod, -ACisloCimJede);
        if Dist<EpsilonRel then
          AmiClass.AmCl := AC2;
      end;

      -TypVenti2-9..-TypVenti2 : begin
        if NOT PorovnejBody(AktBodAmi, Point(-MaxInt div 2, -MaxInt div 2)) then begin
          Bodik := AktBodAmi;
        end;
  {      AC1 := AmiLispik.NajdiTrubkuBod(Bodip, Griq.Y, 0);
        if AC1<>NIL then
          Bodik := NejblBodPrimky(BodiP,AC1.Pocatek,AC1.AbsKonec); }
        AmiClass := TAmiVenti2.Creatf(AmiLispik,Bodik,-ACisloCimJede);
        TAmiVentil(AmiClass).Symbol := SymbolAmi[FunTypAmi(-ACisloCimJede)];
{        Case ACisloCimJede of
          -TypVenti2-9..-TypVenti2-5 : TAmiVentil(AmiClass).Symbol := SymbolAmi[-ACisloCimJede-TypVenti2+31];
          -TypVenti2-4..-TypVenti2-0 : TAmiVentil(AmiClass).Symbol := SymbolAmi[-ACisloCimJede-TypVenti2+31];
        end; }
        SpocitatBodySpojTr := TRUE;
        SpocitatBodyNedotahuTr := TRUE;
      end;

      -TypVenti3-3..-TypVenti3 : begin
        AmiClass := TAmiVenti3.Creatf(AmiLispik, Bodik, -ACisloCimJede);
        SpocitatBodySpojTr := TRUE;
        SpocitatBodyNedotahuTr := TRUE;
      end;

      -TypRad1-20..-TypRad1 : begin
//        VyskaR := DejVyskuRadiatoru(SymbolAmi[-ACisloCimJede-TypRad1+81]);
        VyskaR := DejVyskuRadiatoru(SymbolAmi[FunTypAmi(-ACisloCimJede)]);
        AmiClass := TAmiRad1.Creatf(AmiLispik,Bodik,VyskaR,-ACisloCimJede);
//        TAmiRad1(AmiClass).Symbol := SymbolAmi[-ACisloCimJede-TypRad1+81];
        TAmiRad1(AmiClass).Symbol := SymbolAmi[FunTypAmi(-ACisloCimJede)];
        if BDodrzovatVzdalodPodlahyH then begin
          AC1 := ATopChlad.NajdiNejblizsiStrop(AmiClass);
          if AC1<>NIL then begin
            AmiClass.Pocatek := Point(AmiClass.Pocatek.X,
                       Max(AmiClass.Pocatek.Y, AC1.HL.Y+VzdalenostOdPodlahyH));
            AmiClass.SpocitejORect;
          end;
        end;
        SpocitatBodySpojTr := TRUE;
        SpocitatBodyNedotahuTr := TRUE;
      end;

      -TypRad2-15..-TypRad2 : begin
        AmiClass := TAmiRad2.Creatf(AmiLispik,Bodik,-ACisloCimJede);
        if BDodrzovatVzdalodPodlahyH AND (-ACisloCimJede-TypRad2 in [4, 5, 14, 15]) then begin
          AC1 := ATopChlad.NajdiNejblizsiStrop(AmiClass);
          if AC1<>NIL then begin
            AmiClass.Pocatek := Point(AmiClass.Pocatek.X,
                       Max(AmiClass.Pocatek.Y, AC1.HL.Y+VzdalenostOdPodlahyH));
            AmiClass.SpocitejORect;
          end;
        end;
        SpocitatBodySpojTr := TRUE;
        SpocitatBodyNedotahuTr := TRUE;
      end;

      -TypChladic1-5..-TypChladic1: begin
  //      AmiClass := TAmiChladic1.Creatf(AmiLispik,Bodik,-ACisloCimJede);
        AmiClass := TAmiRad2.Creatf(AmiLispik,Bodik,-ACisloCimJede);
        if BDodrzovatVzdalodPodlahyC {AND (-ACisloCimJede=TypRad2+5)} then begin
          AC1 := NajdiNejblizsiStrop(AmiClass);
          if AC1<>NIL then begin
            AmiClass.Pocatek := Point(AmiClass.Pocatek.X,
                       Max(AmiClass.Pocatek.Y, AC1.HL.Y+VzdalenostOdPodlahyC));
            AmiClass.SpocitejORect;
          end;
        end;
        SpocitatBodySpojTr := TRUE;
        SpocitatBodyNedotahuTr := TRUE;
      end;

      -TypOTChladic1-5..-TypOTChladic1: begin
        AmiClass := TAmiOTChladic1.Creatf(AmiLispik,Bodik,-ACisloCimJede);
        if BDodrzovatVzdalodPodlahyC {AND (-ACisloCimJede=TypRad2+5)} then begin
          AC1 := NajdiNejblizsiStrop(AmiClass);
          if AC1<>NIL then begin
            AmiClass.Pocatek := Point(AmiClass.Pocatek.X,
                       Max(AmiClass.Pocatek.Y, AC1.HL.Y+VzdalenostOdPodlahyC));
            AmiClass.SpocitejORect;
          end;
        end;
        SpocitatBodySpojTr := TRUE;
        SpocitatBodyNedotahuTr := TRUE;
      end;

      -TypModul : begin
        AmiClass := TAmiModul.Creatf(AmiLispik,Bodik,Point(800,800),-ACisloCimJede);
        SpocitatBodySpojTr := TRUE;
        SpocitatBodyNedotahuTr := TRUE;
      end;

      -TypSchema0-15..-TypSchema0 : begin
        AmiClass := TAmiSchema.Creatf(AmiLispik, Bodik , -ACisloCimJede);
        for i := 0 to TAmiSchema(AmiClass).Seznam3.Count-1 do begin
          AC1 := TAmiSchema(AmiClass).Seznam3[i];
          if AC1 is TAmiTrubka then begin
  //          Case AC1.Typ of
  //            TypTrubka1, TypTrubka2 : TAmiTrubka(AC1).Symbol := SymbolAmi[AC1.Typ-TypTrubka1+11];
  //            TypTrubka3..TypTrubka6 : TAmiTrubka(AC1).Symbol := SymbolAmi[AC1.Typ-TypTrubka3+6];
  //          end;
            TAmiTrubka(AC1).Symbol := SymbolAmi[FunTypAmi(AC1.Typ)];
            TAmiTrubka(AC1).Izol   := AIzolace;
          end;
        end;
        SpocitatBodySpojTr := TRUE;
        SpocitatBodyNedotahuTr := TRUE;
      end;

      -TypObecnaPataC-4..-TypKotel : begin
        AmiClass := TAmiKotel.Creatf(AmiLispik,Bodik,-ACisloCimJede);
        SpocitatBodySpojTr := TRUE;
        SpocitatBodyNedotahuTr := TRUE;
      end;

      -TypPokoj : Begin
        if ((Abs(Bodik.X-Bodil.X)<MinDelkaPokoje) OR
            (Abs(Bodik.Y-Bodil.Y)<MinVyskaPokoje)) then begin

        end else begin
          AmiClass := TAmiPokoj.Creatf(AmiLispik, Bodil,
                 Point(Bodik.X-Bodil.X,Bodik.Y-Bodil.Y));

          RozdelitTrubkyPokoji := TRUE;
        end;
      end;

      -TypPopisTru1, -TypPopisTru2, -TypPopisTru3, -TypPopisTru4, -TypPopisTru5 : begin
        MaVymazatVypocet := FALSE;
        if Bodil.X<Bodik.X then DX := 250 else DX := -250;
        AmiClass := TAmiPopis.Creatf(AmiLispik, Bodik,
                         Point(DX, 200),Bodil,-ACisloCimJede,NIL);

        if ACisloCimJede=-TypPopisTru1 then begin
          if Bodik.X<Bodil.X then
            AmiClass.Orientace := 2;
        end;

        if ACisloCimJede=-TypPopisTru4 then begin
          S := IntToStr(ASklon);
          if DialogsCZ.InputQuery(SZapisteSklon,'',S) then begin
            if S<>'' then begin
              Try
                i := StrToInt(S);
                if (i>=0) AND (i<1000) then begin
                  ASklon := i;
                  TAmiPopis(AmiClass).Cislicko := i;
                end;
              except

              end;
            end;
          end;
        end;
      end;

  {    -TypPopisTru2 : begin
        MaVymazatVypocet := FALSE;
        DelejSpocitejBodGrid(PocAmi,Kotva,Griq,KoefZvetseni,Bodil);
        if Abs(Bodik.X-Bodil.X)+Abs(Bodik.Y-Bodil.Y)<MinDelkaTrub1 then begin

        end else begin
          AmiClass := TAmiPopis.Creatf(AmiLispik, Bodil,
             Point(Bodik.X-Bodil.X,Bodik.Y-Bodil.Y),Bodil,-ACisloCimJede,NIL);
        end;
      end;  }


      -TypTrubka6..-TypTrubka1, -TypTrubkaOV, -TypTrubkaCara10..-TypTrubkaCara1 : begin
        if NOT PorovnejBody(AktBodAmi, Point(-MaxInt div 2, -MaxInt div 2)) then begin
          if JeRovnaCara then begin
            if BylFixniZacatek then begin
              if (AktBodAmi.X=AKatva.X) OR (AktBodAmi.Y=AKatva.Y) then begin
                Bodik := AktBodAmi;
              end;
            end else begin
              Bodik := AktBodAmi;
              if Abs(Bodil.X-Bodik.X)<Abs(Bodil.Y-Bodik.Y) then Bodil.X := Bodik.X
                                                           else Bodil.Y := Bodik.Y;
            end;
          end else begin
            Bodik := AktBodAmi;
          end;
        end;
  {      DelejSpocitejBodGrid(PocAmi,Kotva,Griq,KoefZvetseni,Bodil); }
        if Abs(Bodik.X-Bodil.X)+Abs(Bodik.Y-Bodil.Y)<MinDelkaTrub1 then begin

        end else begin
          AmiClass := TAmiTrubka.Creatf(AmiLispik, Bodil ,
                  Point(Bodik.X-Bodil.X,Bodik.Y-Bodil.Y) ,-ACisloCimJede);

  {        S := SymbolAmi[-ACisloCimJede-TypTrubka1+11];
          if S<>'' then
            TAmiTrubka(AmiClass).TypTr := Ord(S[Length(S)]); }
          if (ACisloCimJede>=-TypTrubka6) AND (ACisloCimJede<=-TypTrubka1) then begin
  //          Case ACisloCimJede of
  //            -TypTrubka3, -TypTrubka4, -TypTrubka5, -TypTrubka6 : TAmiTrubka(AmiClass).Symbol := SymbolAmi[-ACisloCimJede-TypTrubka3+6];
  //            -TypTrubka1, -TypTrubka2, -TypTrubka0 : TAmiTrubka(AmiClass).Symbol := SymbolAmi[-ACisloCimJede-TypTrubka1+11];
  //          end;
//            TAmiTrubka(AmiClass).Symbol := SymbolAmi[FunTrubka(AmiClass.Typ)];
            TAmiTrubka(AmiClass).Symbol := SymbolAmi[FunTypAmi(AmiClass.Typ)];
            TAmiTrubka(AmiClass).Izol := AIzolace;
            SpocitatBodySpojTr := TRUE;
            SpocitatBodyNedotahuTr := TRUE;
            SpojitaRozdelitTrubky := TRUE;
          end;
          if ACisloCimJede=-TypTrubkaOV then begin
            SpocitatBodySpojTr := TRUE;
            SpocitatBodyNedotahuTr := TRUE;
          end;

          if ACisloCimJede=-TypTrubkaCara5 then begin
  {         if ZadejBarvaTypStylCary_99(AmiClass, TRUE)<0 then begin
              AmiClass.Free;
              AmiClass := NIL;
            end; }
            with AmiClass as TAmiTrubka do begin
              Prumer := Trub5Sila;
              Delka := Trub5Barva;
              TypTr := Trub5Styl;
            end;
          end;

          if (ACisloCimJede>=-TypTrubkaCara10) AND (ACisloCimJede<=-TypTrubkaCara1) then
            MaVymazatVypocet := FALSE;
        end;
      end;

      -TypAmiCara : begin
        MaVymazatVypocet := FALSE;
        if Abs(Bodik.X-Bodil.X)+Abs(Bodik.Y-Bodil.Y)<MinDelkaTrub1 then begin

        end else begin
          AmiClass := TAmiCara.Creatf(AmiLispik, Bodil ,
                  Point(Bodik.X-Bodil.X,Bodik.Y-Bodil.Y));
          with AmiClass as TAmiCara do begin
            Barva := CaraBarva;
            Sila  := CaraSila;
            Styl  := CaraStyl;
          end;

  {        if ZadejBarvaTypStylCary_99(AmiClass, TRUE)<0 then begin
            AmiClass.Free;
            AmiClass := NIL;
          end;  }

        end;
      end;

      -TypAmiObdelnik : begin
        MaVymazatVypocet := FALSE;
        if ((Abs(Bodik.X-Bodil.X)<MinDelkaTrub1) OR
            (Abs(Bodik.Y-Bodil.Y)<MinDelkaTrub1)) then begin

        end else begin
          AmiClass := TAmiObdelnik.Creatf(AmiLispik, Bodil,
                 Point(Bodik.X-Bodil.X,Bodik.Y-Bodil.Y));
          with AmiClass as TAmiObdelnik do begin
            SilaCary := ObdCaraSila;
            BarvaCary := ObdCaraBarva;
            Vzorek := ObdVzorStyl;
            BarvaVzorku := ObdVzorBarva;
          end;
  {        if ZadejBarvaTypStylCary_99(AmiClass, TRUE)<0 then begin
            AmiClass.Free;
            AmiClass := NIL;
          end; }
        end;
      end;

      -TypAmiOblouk1 : begin
        MaVymazatVypocet := FALSE;
        if ((Abs(Bodik.X-Bodil.X)<MinDelkaTrub1) OR
            (Abs(Bodik.Y-Bodil.Y)<MinDelkaTrub1)) then begin

        end else begin
          AmiClass := TAmiOblouk.Creatf(AmiLispik, Bodil,
                 Point(Bodik.X-Bodil.X,Bodik.Y-Bodil.Y), TypAmiOblouk1);

          with AmiClass as TAmiOblouk do begin
            SilaCary := EliCaraSila;
            BarvaCary := EliCaraBarva;
            Vzorek := EliVzorStyl;
            BarvaVzorku := EliVzorBarva;
          end;

          if ZadejBarvaTypStylElipsy_99(AmiClass, TRUE)<0 then begin
            AmiClass.Free;
            AmiClass := NIL;
          end;
        end;
      end;

      -TypAmiOblouk2 : begin
        if VkladatObloucky then begin

          if CitacKlikuObloucku=3 then begin
            MaVymazatVypocet := FALSE;

            DelejSpocRealBodik(PocAmi,
              Point(StredObloucku.X-RObloucku, StredObloucku.Y-RObloucku),
              KoefZvetseni, BodObloucku1);
            DelejSpocRealBodik(Point(0, 0),
              Point(2*RObloucku, 2*RObloucku), KoefZvetseni, BodObloucku2);
            AmiClass := TAmiOblouk.Creatf(AmiLispik,
              BodObloucku1, BodObloucku2, TypAmiOblouk2);

            with AmiClass as TAmiOblouk do begin
              SilaCary := EliCaraSila;
              BarvaCary := EliCaraBarva;
              Alfa1 := Alf1Obloucku;
              Alfa2 := Alf2Obloucku;
            end;

            if ZadejBarvaTypStylOblouku_99(AmiClass, TRUE)<0 then begin
              AmiClass.Free;
              AmiClass := NIL;
            end;
            CitacKlikuObloucku := 0;
          end;

          case JakObloucek of
            0 : begin
              case CitacKlikuObloucku of
                1 : begin
                  if (Abs(BodObloucku1.Y-AbsBod.Y)+Abs(BodObloucku1.X-AbsBod.X)>epsObl) then begin
                    Alf1Obloucku := -Round(ArcTan2(BodObloucku1.Y-AbsBod.Y, BodObloucku1.X-AbsBod.X)/Pi*180000);
            //        Alf2Obloucku := Alf1Obloucku+180000;
                    Alf2Obloucku := Alf1Obloucku;
                    OblKruznice(PaintBox1.Canvas, RObloucku, Point(AbsBod.X, AbsBod.Y));
                    Obloucek(PaintBox1.Canvas, RObloucku, StredObloucku, Alf1Obloucku, Alf2Obloucku);
                    CitacKlikuObloucku := 3;
                  end;
                end;
              end;
            end;

            1 : begin
              case CitacKlikuObloucku of
                1 : begin
                  if (Abs(BodObloucku1.Y-AbsBod.Y)+Abs(BodObloucku1.X-AbsBod.X)>epsObl) then begin
  //                  with PaintBox1.Canvas do begin
                    with BiMa.Canvas do begin
                      brush.style := bssolid;
                      brush.color := clDkGray;
                      Pen.Mode := pmCopy;
                      Pen.Style := psSolid;
                      pen.color := clDkGray;
                      rectangle(AbsBod.X-velboduuch, AbsBod.Y-velboduuch,
                                AbsBod.Y+velboduuch, AbsBod.Y+velboduuch);
                    end;
                    with PaintBox1.Canvas do begin
  //                  with BiMa.Canvas do begin
                      brush.style := bssolid;
                      brush.color := clDkGray;
                      Pen.Mode := pmCopy;
                      Pen.Style := psSolid;
                      pen.color := clDkGray;
                      rectangle(AbsBod.X-velboduuch, AbsBod.Y-velboduuch,
                                AbsBod.Y+velboduuch, AbsBod.Y+velboduuch);
                    end;
                    BodObloucku2.X := AbsBod.X;
                    BodObloucku2.Y := AbsBod.Y;
                    Obloucek(BiMa.Canvas, RObloucku, StredObloucku, Alf1Obloucku, Alf2Obloucku);
                    BodyTetivy(PaintBox1.Canvas, BodObloucku1, BodObloucku2);
                    CitacKlikuObloucku := 3;
      //              inc(CitacKlikuObloucku);
                  end;
                end;
              end;
            end;
          end;

          {          if ZadejBarvaTypStylElipsy_99(AmiClass, TRUE)<0 then begin
              AmiClass.Free;
              AmiClass := NIL;
            end; }
    {       with AmiClass as TAmiObdelnik do begin
              SilaCary := EliCaraSila;
              BarvaCary := EliCaraBarva;
              Vzorek := EliVzorStyl;
              BarvaVzorku := EliVzorBarva;
            end; }

        end;

      end;

      -TypAmiText1 : begin
        MaVymazatVypocet := FALSE;
        with PaintBox1.Canvas do begin
          Pen.Mode := pmCopy;
          Pen.Color := clBlack;
          Pen.Width := 3;
          Polyline([Point(AbsBod.X-10,AbsBod.Y),Point(AbsBod.X+10,AbsBod.Y)]);
          Polyline([Point(AbsBod.X,AbsBod.Y-10),Point(AbsBod.X,AbsBod.Y+10)]);
        end;
        if DialogsCZ.InputQuery(SZapisteText,'',TextTextik) then begin
          if TextTextik<>'' then begin
            AmiClass := TAmiTextik.Creatf(AmiLispik, Bodik, Bodik, -ACisloCimJede);
            TAmiTextik(AmiClass).Napis := TextTextik;
            TAmiTextik(AmiClass).Font := TextFont;
          end;
        end;
      end;

      -TypAmiText2 : begin
        MaVymazatVypocet := FALSE;
        if DialogsCZ.InputQuery(SZapisteText,'',TextTextik) then begin
          AmiClass := TAmiTextik.Creatf(AmiLispik, Bodik, Bodil, -ACisloCimJede);
          TAmiTextik(AmiClass).Napis := TextTextik;
          TAmiTextik(AmiClass).Font := TextFont;
        end;
      end;

      -TypAmiText3 : begin
        MaVymazatVypocet := FALSE;
        if DialogsCZ.InputQuery(SZapisteText,'',TextTextik) then begin
          AmiClass := TAmiTextik.Creatf(AmiLispik, Bodik, Bodil, -ACisloCimJede);
          TAmiTextik(AmiClass).Napis := TextTextik;
          TAmiTextik(AmiClass).Font := TextFont;
        end;
      end;

      -TypVenti4-20..-TypVenti4 : begin
        SpocitejPolohuVenti4(Bodil, Bodik, AC1, AC2, Bo1, Bo2, Bo3, -ACisloCimJede);

        AmiClass := TAmiVenti4.Creatf(AmiLispik, Bo3, -ACisloCimJede);
        AmiClass.BodyUch[1] := Bo1;
        AmiClass.BodyUch[3] := Bo2;
        AmiClass.AmCl := AC1;
        AmiClass.AmCm := AC2;
        {      if (ACisloCimJede= }

        if (ACisloCimJede=-TypVenti4-1) OR (ACisloCimJede=-TypVenti4-2) then
//          TAmiVentil(AmiClass).Symbol := SymbolAmi[-ACisloCimJede-TypVenti4+56];
          TAmiVentil(AmiClass).Symbol := SymbolAmi[FunTypAmi(-ACisloCimJede)];
      end;

      -TypRazitko-8..-TypRazitko : begin
        MaVymazatVypocet := FALSE;
        with PaintBox1.Canvas do begin
          Pen.Mode := pmCopy;
          Pen.Color := clBlack;
          Pen.Width := 3;
          Polyline([Point(AbsBod.X-10,AbsBod.Y),Point(AbsBod.X+10,AbsBod.Y)]);
          Polyline([Point(AbsBod.X,AbsBod.Y-10),Point(AbsBod.X,AbsBod.Y+10)]);
        end;

        AmiClass := TAmiRazitko.Creatf(AmiLispik,Bodik,-ACisloCimJede);
        if NOT ZadejPolohuRazitka_99(TAmiRazitko(AmiClass), FALSE) then begin
          AmiClass.Free;
          AmiClass := NIL;
        end;
      end;

      -TypPneuH-79..-TypPneuH : begin
        AmiClass := TAmiPneuH.Creatf(AmiLispik, Bodik, -ACisloCimJede);
        TAmiPneuH(AmiClass).Symbol := SymbolAmi[FunTypAmi(-ACisloCimJede)];
      end;

    end;
    AktAmiOzn := AmiClass;
    if AktAmiOzn<>NIL then begin
      DelejUmozniUNDO_TChl;
      DelejUmozniUNDQ_99(histInsert, AktAmiOzn.Typ, NIL, NIL);          //?????

      DelejTabulky_99;
      AktAmiOzn := AmiClass;
      AktAmiOzn.PraveVlozeny := TRUE;
      AmiLispik.Add(AktAmiOzn);    // AmiPokoj uz vlozil kvuli popisu
      if AktAmiOzn is TAmiPokoj then begin
        AktAmiOzn.SpocitejORect;
        AmiClast := TAmiPopis.Creatf(AmiLispik,
              Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y-300),
                     Point(500,-250),
              Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y-300),
                     TypPopisPok1,AktAmiOzn);
        AmiLispik.Add(AmiClast);
        AktAmiOzn.AmCl := AmiClast;
        AmiClast.PraveVlozeny := TRUE;

      end;

      if (AktAmiOzn is TAmiTrubka) AND (AktAmiOzn.Typ=TypTrubka0) then begin
        // u fialove trubky se podiva, zda se nepokousi pripojit k OT, a zda se pokousi
        // pripojit nahore nebo dole, podle toho nastavi u OT AmCl nebo AmCm
        ZkusAmClCm(AktAmiOzn, AmiLispik);
      end;

      if (AktAmiOzn is TAmiRad1) OR (AktAmiOzn is TAmiRad2) then begin
        AktAmiOzn.SpocitejORect;
        AmiClast := TAmiPopis.Creatf(AmiLispik,
              Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y+100),
                     Point(500,-250),
              Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y+100),
                     TypPopisRad1,AktAmiOzn);
        AmiLispik.Add(AmiClast);
        AmiClast.PraveVlozeny := TRUE;

      end;

  {    if AktAmiOzn is TAmiRad2 then begin
        AktAmiOzn.SpocitejORect;
        AmiClast := TAmiPopis.Creatf(AmiLispik,
              Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y+100),
                     Point(500,-250),
              Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y+100),
                     TypPopisRad1, AktAmiOzn);
        AmiLispik.Add(AmiClast);
        AmiClast.PraveVlozeny := TRUE;
      end;   }

      if AktAmiOzn is TAmiVenti4 then begin
        // tady by asi chtelo upravit polohu privodnich trubek
      end;

      if AktAmiOzn is TAmiSchema then begin
        // vlozi patu
        AmiClast := TAmiKotel.Creatf(AmiLispik, Point(-1000000, -1000000), TypSchemaPata);

        AmiLispik.Add(AmiClast);
        AmiClast.PraveVlozeny := TRUE;
        TAmiSchema(AktAmiOzn).NovaPata := AmiClast;
        DelejVlozPopisySchematu(AktAmiOzn, AmiLispik);
        TAmiSchema(AktAmiOzn).ZmenChlazeni_x_Topeni(NastaveniTopChlad.Mod_Chlazeni_x_Topeni);
      end;

      if (AktAmiOzn is TAmiVentil) then begin
        with AktAmiOzn as TAmiVentil do
          VytvorKapilaru(Kapilara, Point(0, 0));

        if TAmiVentil(AktAmiOzn).PovinnyPopis then begin
          AktAmiOzn.SpocitejORect;
          AmiClast := TAmiPopis.Creatf(AmiLispik,
                Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y+100),
                       Point(500,-250),
                Point((AktAmiOzn.HL.X+AktAmiOzn.DP.X) div 2,AktAmiOzn.HL.Y+100),
                       TypPopisVent,AktAmiOzn);
          AmiLispik.Add(AmiClast);
          AmiClast.PraveVlozeny := TRUE;
        end;
      end;

      if (AktAmiOzn is TAmiStrop1) then begin
        AmiClast := DelejVlozPopisVysky(Point(AktAmiOzn.Pocatek.X+200, AktAmiOzn.AbsKonec.Y),
           AmiLispik, 0);
      end;

      if AktAmiOzn is TAmiPneuH then begin
        with TAmiPneuH(AktAmiOzn) do
          VytvorKapilary;
      end;
    end;

    AktAmiOzq := AmiClast;

{    PracHistqryList := TList.Create;
    for i := AmiLispikCount to AmiLispik.Count-1 do
      VlozAmiclassDoKrokuHistory(PracHistqryList, AmiLispik[i], 0); }

    UsporadejList(AmiLispik);
    {  if ACisloCimJede<>0 then
      DelejInvalidu_TChl;         }
    DelejPrvniREDQ_99(histInsert, AktAmiOzn.Typ, NIL, NIL);

    if AForm_A is TForm_Rb1 then
      with TForm_Rb1(AForm_A) do begin
        if AmiLispik.Count>0 then A_Klasika_0.Enabled := FALSE
                             else A_Klasika_0.Enabled := TRUE;
      end;
  end;
end;

Function TFrForm99.DelejOknoproClipBoard_99(var ASir, AVys : integer;
                                       var AObdVyrezu : TRect) : String;
var
  VyrB1, VyrB2 : TPoint;
begin
  ASir := PaintBox1.Width;
  AVys := PaintBox1.Height;
  DelejSpocRealBodik(PocAmi, Point(0, 0), KoefZvetseni, VyrB1);
  DelejSpocRealBodik(PocAmi, Point(PaintBox1.Width, PaintBox1.Height),
                    KoefZvetseni, VyrB2);
  AObdVyrezu := Rect(0, 0, ASir, AVys);
//  AObdVyrezu := Rect(0, 0, ASir, AVysVyrB1.X, VyrB1.Y, VyrB2.X, VyrB2.Y);

//  AKopirovatOkno1.Caption := SKopirovatOkno;
  Result := SKopirovatOkno;
  if JeOblastProTisk then begin
    DelejSpocAbsBodik(PocAmi, VyrezTiskuB1, KoefZvetseni, VyrB1);
    DelejSpocAbsBodik(PocAmi, VyrezTiskuB2, KoefZvetseni, VyrB2);
    if (VyrB1.X>=0) AND (VyrB1.Y<=PaintBox1.Height) AND
       (VyrB2.X<=PaintBox1.Width) AND (VyrB1.Y>=0) then begin

      AObdVyrezu := Rect(VyrB1.X, VyrB1.Y, VyrB2.X, VyrB2.Y);
{      AObdVyrezu := Rect(VyrezTiskuB1.X, VyrezTiskuB2.Y,
                         VyrezTiskuB2.X, VyrezTiskuB1.Y); }
      ASir := VyrB2.X-VyrB1.X;
      AVys := VyrB2.Y-VyrB1.Y;
//      AKopirovatOkno1.Caption := SKopirovatOblastproTisk;
      Result := SKopirovatOblastproTisk;
    end;
  end;
end;

procedure TFrForm99.TiskProjektu1Click_99;
var
  AA : boolean;
begin
  with ATopChlad do begin
    with FormU do begin
      AJmenoProjektu := JmenoProjektu;
      AVyrezTiskuB1 := VyrezTiskuB1;
      AVyrezTiskuB2 := VyrezTiskuB2;
      AA := AmiLispik.DejRazitko<>NIL;
      if AA AND JeOblastProTisk then begin
        if RadioGroup2.ItemIndex<>0 then
          AA := FALSE;
      end;
      RadioGroup3.Enabled := AA;
      RadioGroup2.Enabled := JeOblastProTisk;
      RadioGroup1.ItemIndex := AZobrCernobile;
      CheckBox1.Enabled := (RadioGroup3.ItemIndex<2) OR NOT RadioGroup3.Enabled;
      ZobrCernobile := AZobrCernobile;

      AmiLispik.Sort(ListUspPodleTypu);

      PripravPreview(AmiLispik);
      ShowModal;
    end;
    ZobrCernoBile := 0;
  end;
end;

Function TFrForm99.DelejDelete_99 : boolean;
var
  i, Ind : integer;
  AC : TAmiClass;
  Zrusil : boolean;
begin
  with ATopChlad do begin
    Result := DelejDelete_TChl;
    if Result then begin

      DelejUmozniUpravy_99;
      JakobyPageControlChange;
      DelejTabulky_99;
      DelejInvalidu_99;

    end;

    if AForm_A is TForm_Rb1 then
      with TForm_Rb1(AForm_A) do begin
        if AmiLispik.Count>0 then A_Klasika_0.Enabled := FALSE
                             else A_Klasika_0.Enabled := TRUE;
      end;

  end;
end;

procedure TFrForm99.TimerAutoSaveTimer(Sender: TObject);
begin
  with ATopChlad do begin
    if BSamoUkladani then
      if NOT NemuzeUlozit then begin
        if ZmenaProjektu then
            if (AmiLispik<>NIL) AND (AmiLispik.Count>0) then
              UlozListdoSouboru(AmiLispik, JmenoProjektu, 0);
      end;
  end;
end;

procedure TFrForm99.SpdButClick_99(ATag : integer);
var
  V : integer;
begin
  VidPanel1_99(FALSE);
  CisloCimJede_99 := -TypAmi[ATag];

  DelejVyberKurzor_99(ATag);

  if CisloCimJede_99=0 then begin
    JakobyPageControlChange;
    PaintBox1.Cursor := crDefault;
    DelejVyberKurzor_99(0);
  end;

  Case CisloCimJede_99 of
    -TypRad1-20..-TypRad1 : begin
      PosRad1.Pocatek := PocAmi;
      V := DejVyskuRadiatoru(ATopChlad.SymbolAmi[ATag]);
      PosRad1.ZmenTyp(-CisloCimJede_99);
      PosRad1.ZadejVysku(V);
      PosRad1.AbsObd(KoefZvetseni, PocAmi);
    end;

    -TypRad2-15..-TypRad2 : begin
      PosRad2.Pocatek := PocAmi;
      PosRad2.ZmenTyp(-CisloCimJede_99);
      PosRad2.AbsObd(KoefZvetseni, PocAmi);
    end;

    -TypChladic1-5..-TypChladic1: begin
      PosChladic1.Pocatek := PocAmi;
      PosChladic1.ZmenTyp(-CisloCimJede_99);
      PosChladic1.AbsObd(KoefZvetseni, PocAmi);
    end;

    -TypOTChladic1-5..-TypOTChladic1: begin
      PosOTChladic1.Pocatek := PocAmi;
      PosOTChladic1.ZmenTyp(-CisloCimJede_99);
      PosOTChladic1.AbsObd(KoefZvetseni, PocAmi);
    end;

    -TypObecnaPataC-4..-TypKotel : begin
      PosKotel.Pocatek := PocAmi;
      PosKotel.ZmenTyp(-CisloCimJede_99);
      PosKotel.AbsObd(KoefZvetseni, PocAmi);
    end;

    -TypSchema0-15..-TypSchema0 : begin
      PosSchema := PosPoleSchemat[-CisloCimJede_99-TypSchema0];
      PosSchema.Pocatek := PocAmi;
//      PosSchema.ZmenTyp(-CisloCimJede_99);
      PosSchema.AbsObd(KoefZvetseni, PocAmi);
      PosSchema.Kresli(NIL, KoefZvetseni, 4, PocAmi);
    end;

//    -TypPneuH-79..-TypPneuH : begin
//    -TypPneuHSafetyValve+1..-TypPneuHStatico : begin
    -TypPneuH-79..-TypPneuHStatico : begin
      PosPneuH := PosPolePneuH[-CisloCimJede_99];
      PosPneuH.Pocatek := PocAmi;
//      PosSchema.ZmenTyp(-CisloCimJede_99);
      PosPneuH.AbsObd(KoefZvetseni, PocAmi);
      PosPneuH.Kresli(NIL, KoefZvetseni, 4, PocAmi);
    end;
  end;
end;

procedure TFrForm99.ToolB97Zobr7Click_99;
var
  ABod, RBod : TPoint;
begin
  ABod := Point(PaintBox1.Width div 2, PaintBox1.Height div 2);
  DelejSpocRealBodik(PocAmi, ABod, KoefZvetseni, RBod);
  DelejZoom_99(RBod, RBod, 1, 1);
end;

procedure TFrForm99.ToolB97Zobr8Click_99;
var
  ABod, RBod : TPoint;
begin
  ABod := Point(PaintBox1.Width div 2, PaintBox1.Height div 2);
  DelejSpocRealBodik(PocAmi, ABod, KoefZvetseni, RBod);
  DelejZoom_99(RBod, RBod, -1, 1);
end;

procedure TFrForm99.AZrusitVyrezproTisk1Click_99;
begin
  JeOblastProTisk := FALSE;
  Invalidate;
end;

procedure TFrForm99.AKopirovatOkno1Click_99;
var
  BM : TBitMap;
  Sir, Vys : integer;
  ObdVyrezu : TRect;
begin
  Try
    BM := TBitMap.Create;
    Try
      DelejOknoproClipBoard_99(Sir, Vys, ObdVyrezu);
      BM.Width := Sir;
      BM.Height := Vys;
      BM.Canvas.CopyRect(Rect(0, 0, Sir, Vys), BiMa.Canvas, ObdVyrezu);
//      BM.Canvas.CopyRect(Rect(0, 0, Sir, Vys), PaintBox1.Canvas, ObdVyrezu);
      {     With BM.Canvas do begin
        Pen.Mode := pmCopy;
        Brush.Color := BarvaPozadiObr;
        Brush.Style := bsSolid;
        FillRect(Rect(0, 0, BM.Width, BM.Height));
      end;
      ATopChlad.DelejKresliBiMa_TChl(BM, ObdVyrezu); }
      Clipboard.Assign(BM);
    finally
      BM.Free;
    end;
  except

  end;
end;

// ukazat oznaceni vetvi .. nahrazeni FormBV v UnPokBV1 plovoucim ToolFormBV
//**************************************************************************

procedure TFrForm99.DelejUkazatOznaceniVetvi_99(Ukazat : boolean);
const
  StdBarvyVetvi : array[0..11] of integer =
    (clRed, clGreen, clYellow, clBlue, clFuchsia,
     clTeal, clNavy, clMaroon, clLime, clOlive, clPurple, clAqua);
var
  AStoupStrList : TStringList;
  i, ind : integer;
  S : String;
  AT : TAmiClass;
  JenCisla : boolean;
begin
  ATopChlad.BUkazatStoupacky := Ukazat;
  if AForm_A is TFormA then begin
    TFormA(AForm_A).AUkazatOznaceniVetvi1.Checked := Ukazat;
    TFormA(AForm_A).UkazatOznaceniVetvi1.Checked := Ukazat;
  end;

  if ATopChlad.BUkazatStoupacky then begin
    StringGridStoup.RowCount := 0;
    AStoupStrList := TStringList.Create;
    AStoupStrList.Sorted := TRUE;
    AStoupStrList.Duplicates := dupIgnore;

    with ATopChlad do begin
      for i := 0 to AmiLispik.Count-1 do begin
        AT := AmiLispik.Items[i];
        if (AT is TAmiTrubka) AND (AT.Typ in [TypTrubka1..TypTrubka6]) then begin
          if NastaveniTopChlad.BCooling AND (AT.Typ in [TypTrubka3..TypTrubka4]) then
            AStoupStrList.Add(DejStoupTrubky(AT));
          if NOT NastaveniTopChlad.BCooling AND (AT.Typ in [TypTrubka1..TypTrubka0]) then
            AStoupStrList.Add(DejStoupTrubky(AT));
        end;
      end;
    end;

    JenCisla := TRUE;
    For i := 0 to AStoupStrList.Count-1 do begin
      Try
        ind := StrToInt(AStoupStrList[i]);
      except
        JenCisla := FALSE;
        break;
      end;
    end;
    if JenCisla then begin
      AStoupStrList.Sorted := FALSE;
      AStoupStrList.CustomSort(ListStrUspPodleCisel);
    end;

    if BarvyStoupacekList=NIL then
      BarvyStoupacekList := TList.Create;

    for i := BarvyStoupacekList.Count to AStoupStrList.Count do
      BarvyStoupacekList.Add(Pointer(StdBarvyVetvi[i mod 12]));

    with ATopChlad do begin
      for i := 0 to AmiLispik.Count-1 do begin
        AT := AmiLispik.Items[i];
        if (AT is TAmiTrubka) AND (AT.Typ in [TypTrubka1..TypTrubka6]) then begin
          AT.BarvaStoupacky := BarvaNedulezitychStoupacky;
          if (NastaveniTopChlad.BCooling AND (AT.Typ in [TypTrubka3..TypTrubka4])) OR
             (NOT NastaveniTopChlad.BCooling AND (AT.Typ in [TypTrubka1..TypTrubka0])) then begin
            Ind := AStoupStrList.IndexOf(DejStoupTrubky(AT));
            if Ind>=0 then
              AT.BarvaStoupacky := Integer(BarvyStoupacekList[Ind]);
          end;
        end;
      end;
    end;

    StoupListBarev := BarvyStoupacekList;
    StringGridStoup.RowCount := AStoupStrList.Count;

    StringGridStoup.Cols[1].Assign(AStoupStrList);
    StoupStrList.Assign(AStoupStrList);

    for i := 0 to StringGridStoup.RowCount-1 do begin
      StringGridStoup.Objects[1,i] := BarvyStoupacekList[i];
      StoupStrList.Objects[i] := BarvyStoupacekList[i];
    end;

    AStoupStrList.Free;
    ToolWindowStoup.Visible := TRUE;


  end else begin
    SchovejFormBV_99;
  end;
  DelejInvalidu_99;
end;

procedure TFrForm99.StringGridStoupDblClick(Sender: TObject);
var
  Barva : integer;
begin
  if (StoupClickCol=0) AND (StoupClickRow<StringGridStoup.RowCount) then begin
    Barva := Integer(StringGridStoup.Objects[1, StoupClickRow]);
    with DataModule1.ColorDialog1 do begin
      Color := Barva;
      if Execute then
        if Color<>Barva then begin
          StringGridStoup.Objects[1, StoupClickRow] := Pointer(Color);
          StoupStrList.Objects[StoupClickRow] := StringGridStoup.Objects[1, StoupClickRow];
          StoupListBarev[StoupClickRow] := StoupStrList.Objects[StoupClickRow];
          StoupPrekresli;
          StringGridStoup.Invalidate;
        end;
    end;
  end;
end;

procedure TFrForm99.Standardni2Click(Sender: TObject);
begin
  if AForm_A is TFormA then
    with AForm_A as TFormA do begin
      Standardni2.Checked := NOT Standardni2.Checked;
      ToolBar973.Visible := Standardni2.Checked;
    end;
end;

procedure TFrForm99.BStatusbar2Click(Sender: TObject);
begin
  BStatusbar2.Checked := NOT BStatusbar2.Checked;
  StatusBar1.Visible := BStatusbar2.Checked;
  StatusBarVisible := StatusBar1.Visible;

end;

Procedure TFrForm99.StoupPrekresli;
var
  j, ind : integer;
  AT : TAmiClass;
begin
  with ATopChlad do begin
    for j := 0 to AmiLispik.Count-1 do begin
      AT := AmiLispik.Items[j];
      if (AT is TAmiTrubka) AND (AT.Typ in [TypTrubka1..TypTrubka6]) then begin
        ind := StoupStrList.IndexOf(DejStoupTrubky(AT));
        if ind>=0 then
          AT.BarvaStoupacky := integer(StoupStrList.Objects[ind]);
      end;
    end;   // for j
    DelejInvalidu_99;
  end;
end;

procedure TFrForm99.StringGridStoupDrawCell(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TGridDrawState);
var
  ARect : TRect;
begin
  if ACol=0 then begin
    ARect := Rect;
    ARect.Left := ARect.Left+2;
    ARect.Top := ARect.Top+2;
    ARect.Right := ARect.Right-2;
    ARect.Bottom := ARect.Bottom-2;
    with StringGridStoup do begin
      Canvas.Brush.Color := Integer(Objects[1, ARow]);
      Canvas.FillRect(ARect);
    end;
  end;
end;

Function TFrForm99.ObsluzStoupStrList : integer;
var
  i, j : integer;
  S, S0, S1, S2 : String;
  Zmena : boolean;
  AT : TAmiClass;
begin
  Zmena := FALSE;
  Result := StringGridStoup.RowCount;
  DelejUmozniUNDQ_99(histInsert, histOznVetvi1, NIL, NIL);          //?????

  for i := 0 to StringGridStoup.RowCount-1 do begin
    S1 := StringGridStoup.Cells[1, i];
    if S1='' then
      S1 := SNeoznVetev;
    if S1<>SNeoznVetev then
      S1 := UpperCase(S1);

    S0 := StoupStrList[i];
    if S0<>SNeoznVetev then
      S0 := UpperCase(S0);
    if S1<>S0 then begin
      for j := 0 to StoupStrList.Count-1 do begin
        S2 := StoupStrList[j];
        if (j<>i) AND (S1=S2) then begin
          if DialogsCZ.MessageDlg(SExistujeVetev+' '+S1+'. '+SPrestoOznacit, mtWarning,
               [mbYes, mbNo], 0)<>mrYes then begin
            S1 := StoupStrList[i];
            StringGridStoup.Cells[1, i] := S1;
          end;
        end;
      end;
      if S1<>S0 then begin
        DelejUmozniUNDO_99;
        TTopChlad(ATopChlad).ZmenaProjektu := TRUE;
        DelejUmozniUpravy_99;
        DelejTabulky_99;


        S2 := S1;
        if S2=SNeoznVetev then
          S2 := '';
        with TTopChlad(ATopChlad) do begin
          for j := 0 to AmiLispik.Count-1 do begin
            AT := AmiLispik.Items[j];
            if (AT is TAmiTrubka) AND (AT.Typ in [TypTrubka1..TypTrubka6]) then begin
              S := DejStoupTrubky(AT);
              if S=S0 then
                TAmiTrubka(AT).Stoup := S2;
            end;
          end;
        end;

        Zmena := TRUE;
      end;
      StoupStrList[i] := S1;
      StringGridStoup.Cells[1, i] := S1;
    end;
  end;
  if Zmena then DelejPrvniREDQ_99(histInsert, histOznVetvi1, NIL, NIL)
           else DelejVratKrokUNDQ_99;
end;

Procedure TFrForm99.KompreseStoupStrList(Prekreslit : boolean);
var
  i, j, ind : integer;
  S : String;
  Zmena : boolean;
begin
  Zmena := FALSE;
  for i := StoupStrList.Count-1 downto 0 do begin
    S := StoupStrList[i];
    ind := StoupStrList.IndexOf(S);
    if ind<i then begin
      StoupStrList.Delete(i);
      Zmena := TRUE;
    end;
  end;

  if Zmena then begin
    StringGridStoup.RowCount := StoupStrList.Count;
    for i := 0 to StoupStrList.Count-1 do begin
      S := StoupStrList[i];
      StringGridStoup.Cells[1, i] := S;
      StringGridStoup.Objects[1, i] := StoupStrList.Objects[i];
      StoupListBarev[i] := StoupStrList.Objects[i];
    end;       // for i
    if Prekreslit then StoupPrekresli;
  end;
end;

procedure TFrForm99.StringGridStoupSelectCell(Sender: TObject; ACol,
  ARow: Integer; var CanSelect: Boolean);
begin
  StoupClickCol := ACol;
  StoupClickRow := ARow;

  CanSelect := ACol>0;
  With StringGridStoup do begin
    ObsluzStoupStrList;
    if CanSelect then begin
      Options := Options + [goEditing{,goAlwaysShowEditor}];
      EditorMode := TRUE;
    end else begin
      Options := Options - [goEditing{,goAlwaysShowEditor}];
      EditorMode := FALSE;
    end;
    KompreseStoupStrList(TRUE);
  end;

end;

procedure TFrForm99.StringGridStoupKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  if Key=13 then begin
    ObsluzStoupStrList;
    KompreseStoupStrList(TRUE);
  end;
end;

procedure TFrForm99.ToolFormBVCloseQuery(Sender: TObject;
  var CanClose: Boolean);
begin
  ObsluzStoupStrList;
end;

procedure TFrForm99.ToolFormBVClose(Sender: TObject);
begin
  DelejUkazatOznaceniVetvi_99(FALSE);
end;

Procedure TFrForm99.SchovejFormBV_99;
begin
  if ToolWindowStoup.Visible then
    ToolWindowStoup.Hide;
end;
//**************************************************************************
// ukazat oznaceni vetvi .. nahrazeni FormBV v UnPokBV1 plovoucim ToolFormBV

procedure TFrForm99.DXF1Click_99;
begin
  with DataModule1.SaveDialog1 do begin
    Title := SZadejteJmenoDXF;
    DefaultExt := ExtDXF;
    with ATopChlad do begin
      FileName := ChangeFileExt(JmenoProjektu, '.'+ExtDXF);
      Filter := FilterDXF;

      InitialDir := ExtractFileDir(FileName);
  //    if InitialDir='' then InitialDir := DXFDirectory;

      if Execute then begin
        DelejExportDXF(FileName, AmiLispik);
      end;
    end;
  end;
end;

procedure TFrForm99.AZmenitTopeniChlazeni1Click_99;
begin
  ATopChlad.Predelej_C_x_H(TRUE);
  DelejInvalidu_99;
end;

procedure TFrForm99.Vlozit2Click(Sender: TObject);
begin
  DelejVlozit1Click_99;
end;

procedure TFrForm99.VlozitBodKapilary1Click(Sender: TObject);
begin
  VlozitBodKapilary1Click_99;
end;

procedure TFrForm99.VlozitBodKapilary1Click_99;
var
  i : integer;
  BodK : TPoint;
  CBK : integer;
begin
  if CisloBoduKapilary>0 then begin
    with ATopChlad do begin
      BodK := Point(NovyBodKapilary.X-AktAmiOzn.Pocatek.X, NovyBodKapilary.Y-AktAmiOzn.Pocatek.Y);
      if (AktAmiOzn is TAmiVentil) AND (Length(TAmiVentil(AktAmiOzn).Kapilara)>0) then begin
        VlozBodKapilary(TAmiVentil(AktAmiOzn).Kapilara, CisloBoduKapilary, BodK);
//          Point(NovyBodKapilary.X-AktAmiOzn.Pocatek.X, NovyBodKapilary.Y-AktAmiOzn.Pocatek.Y);

  {      SetLength(TAmiVentil(AktAmiOzn).Kapilara, Length(TAmiVentil(AktAmiOzn).Kapilara)+1);
        for i := High(TAmiVentil(AktAmiOzn).Kapilara) downto CisloBoduKapilary do
          TAmiVentil(AktAmiOzn).Kapilara[i] := TAmiVentil(AktAmiOzn).Kapilara[i-1];
        TAmiVentil(AktAmiOzn).Kapilara[CisloBoduKapilary] :=
          Point(NovyBodKapilary.X-AktAmiOzn.Pocatek.X, NovyBodKapilary.Y-AktAmiOzn.Pocatek.Y);

        PaintBox1.Invalidate;
        DelejInvalidu_99;         }
      end;
      if (AktAmiOzn is TAmiPneuH) AND (Length(TAmiPneuH(AktAmiOzn).Kapilarb1)>0) then begin
        with AktAmiOzn as TAmiPneuH do begin
          if CisloBoduKapilary<=Length(Kapilarb1) then begin
            VlozBodKapilary(Kapilarb1, CisloBoduKapilary, BodK);
          end else begin
            CisloBoduKapilary := CisloBoduKapilary-Length(Kapilarb1);
            if CisloBoduKapilary<=Length(Kapilarb2) then
              VlozBodKapilary(Kapilarb2, CisloBoduKapilary, BodK);
          end;
        end;
      end;
    end;
    PaintBox1.Invalidate;
    DelejInvalidu_99;
    CisloBoduKapilary := 0;
  end;
end;

procedure TFrForm99.ZrusitBodKapilary1Click(Sender: TObject);
begin
  ZrusitBodKapilary1Click_99;
end;

procedure TFrForm99.ZrusitBodKapilary1Click_99;
var
  i : integer;
  AC : TAmiClass;
  B1, B2, B3 : TPoint;
  t : extended;
begin
  if CisloBoduKapilary>0 then begin
    with ATopChlad do begin
      if (AktAmiOzn is TAmiVentil) AND (Length(TAmiVentil(AktAmiOzn).Kapilara)>0) then begin
        ZrusBodKapilary(TAmiVentil(AktAmiOzn).Kapilara, CisloBoduKapilary);
        if CisloBoduKapilary>Length(TAmiVentil(AktAmiOzn).Kapilara) then begin
          AktAmiOzn.AmCm := NIL;
          DelejOpravVztahy_99;
        end;
      end;
      if (AktAmiOzn is TAmiPneuH) AND (Length(TAmiPneuH(AktAmiOzn).Kapilarb1)>0) then begin
        with AktAmiOzn as TAmiPneuH do begin
          for i := 0 to AmiLispik.Count-1 do begin
            AC := AmiLispik[i];
            if (AC is TAmiVentiPneuH) AND (AC.AmCl=AktAmiOzn) then begin
              with TAmiVentiPneuH(AC) do begin
                B1 := AC.Pocatek;
                B2 := B1;
                B3 := B1;
                if (TAmiVentiPneuH(AC).CilKapilary=CisloBoduKapilary+2) then begin
                  if ((CisloBoduKapilary<Length(Kapilarb1)) OR
                     ((CisloBoduKapilary>Length(Kapilarb1)) AND
                      (CisloBoduKapilary<Length(Kapilarb1)+Length(Kapilarb2)))) then begin
                    B1 := AktAmiOzn.BodyUch[CilKapilary];
                    B2 := AktAmiOzn.BodyUch[CilKapilary+1];
                    B3 := AktAmiOzn.BodyUch[CilKapilary+2];
                    if DistBodu(B1, B2)>0 then begin
                      t := DistBodu(AC.Pocatek, B1)/DistBodu(B2, B1);
                      AC.Pocatek := Point(B1.X+Round(t*(B3.X-B1.X)),
                                          B1.Y+Round(t*(B3.Y-B1.Y)));
                    end;
                  end;

                end;
                if (TAmiVentiPneuH(AC).CilKapilary=CisloBoduKapilary+3) then begin
                  B1 := AktAmiOzn.BodyUch[CilKapilary-1];
                  B2 := AktAmiOzn.BodyUch[CilKapilary];
                  B3 := AktAmiOzn.BodyUch[CilKapilary+1];
                  if DistBodu(B2, B3)>0 then begin
                    t := DistBodu(AC.Pocatek, B3)/DistBodu(B2, B3);
                    AC.Pocatek := Point(B3.X-Round(t*(B3.X-B1.X)),
                                        B3.Y-Round(t*(B3.Y-B1.Y)));
                  end;
                end;
              end;
            end;
          end;

          if CisloBoduKapilary<=Length(Kapilarb1) then begin
            ZrusBodKapilary(Kapilarb1, CisloBoduKapilary);
          end else begin
            CisloBoduKapilary := CisloBoduKapilary-Length(Kapilarb1);
            if CisloBoduKapilary<=Length(Kapilarb2) then
              ZrusBodKapilary(Kapilarb2, CisloBoduKapilary);
          end;
        end;


{          for i := CisloBoduKapilary to High(Kapilarb1) do
            Kapilarb1[i-1] := Kapilarb1[i];
          SetLength(Kapilarb1, Length(Kapilarb1)-1);
          if CisloBoduKapilary>Length(Kapilarb1) then begin
        //     AktAmiOzn.AmCm := NIL;
        //    DelejOpravVztahy_99;
          end;
        end;
        PaintBox1.Invalidate;
        DelejInvalidu_99; }
      end;
    end;
    PaintBox1.Invalidate;
    DelejInvalidu_99;
    CisloBoduKapilary := 0;
  end;
end;

procedure TFrForm99.Kontrolaprojektu1Click_99;
var
  DummyModul : TAmiModul;
begin
  with ATopChlad do begin
    NemuzeUlozit := TRUE;
    KontrList.Clear;
    ProtokolStrings.Clear;
    SchovejFormF_99;

    DelejOznAmi_99(NIL);
    DelejMoveAmi_99(NIL);
    JakobyPageControlChange;

    if DelejZakladniKontroluModulu(BKontrolaModulu, FALSE, FALSE, DummyModul) then begin
      DialogsCZ.ShowMessage(SZakladniKontrolaOK)
    end else begin
      PripravFormF_99;
    end;
    NemuzeUlozit := FALSE;
    SchovejFormBV_99;
  end;
end;

Function TFrForm99.DelkyTrubekT1T2_99(ATyp : integer) : boolean;
// pro kazdy koncovy bod: jde postupne a zkouma, jsou useky rovnobezne a souhlasne orientovane.
// Pokud ano, priradi delku useku trubky.
// Pokud ne, pro dany koncovy bod skonci
var
  DummyModul : TAmiModul;
  AC, AT1, AT2 : TAmiClass;
  i, j : integer;
  UdelalZmenu : boolean;
  Se1, Se2 : TAmiList;
begin
  Result := FALSE;
  with ATopChlad do begin
    NemuzeUlozit := TRUE;
    VybList.Clear;
    KontrList.Clear;
    ProtokolStrings.Clear;
    SchovejFormF_99;
    if NOT DelejZakladniKontroluModulu(FALSE, FALSE, TRUE, DummyModul) then begin
{      FreeSeznamy12(AmiLispik);
      FreeModulyDPC(AmiLispik, ProtokolStrings, TRUE);
      FreeKoralkyJT(AmiLispik);
      FreeFiktivniPatu(AmiLispik); }
      FreeABCD(AmiLispik, ProtokolStrings, TRUE);
      ProtokolStrings.Add(' ');
      ProtokolStrings.Add(NeZakladniKontrola);

      PripravFormF_99;
      NemuzeUlozit := FALSE;

      exit;
    end;

    UdelalZmenu := FALSE;
    DelejUmozniUNDQ_TChl(histInsert, histDelkyTrubek1, NIL, NIL);          //?????
    for j := 0 to AmiLispik.Count-1 do begin
      AC := AmiLispik[j];
      if AC.JeKoncovyObjekt then begin
        if ATyp in [TypTrubka1, TypTrubka3] then begin
          Se1 := AC.Seznam1;
          Se2 := AC.Seznam2;
        end else begin
          if ATyp in [TypTrubka2, TypTrubka4] then begin
            Se1 := AC.Seznam2;
            Se2 := AC.Seznam1;
          end;
        end;

        if Assigned(Se1) AND Assigned(Se2) then begin
          for i := 0 to Se1.Count-1 do begin
            AT1 := Se1[i];
            if AT1.Typ=ATyp then begin
              if i<Se2.Count then begin
                AT2 := Se2[i];
                if Abs(AT2.Typ-AT1.Typ)=1 then begin
                  if SkoroSouhlasneVekt(AT1.RelKonec, AT2.RelKonec) then begin
                    if (AT1 is TAmiTrubka) AND (AT2 is TAmiTrubka) then begin
                      if TAmiTrubka(AT1).Delka>0 then begin
                        if TAmiTrubka(AT2).Delka<>TAmiTrubka(AT1).Delka then begin
                          if NOT UdelalZmenu then
//                            DelejUmozniUNDO_TChl;
                          UdelalZmenu := TRUE;
                        end;
                        TAmiTrubka(AT2).Delka := TAmiTrubka(AT1).Delka;
                        if VybList.IndexOf(AT1)<0 then
                          VybList.Add(AT1);
                        if VybList.IndexOf(AT2)<0 then
                          VybList.Add(AT2);
                      end;
                    end;
                  end else begin
                    break;  // nejsou skoro shodne, konec pro cestu
                  end;
                end;
              end else begin
                break;
              end;
            end;
          end;   //  for i
        end;
      end;       //  AC.JeKoncovyObjekt
    end;         //  for j
    if UdelalZmenu then begin
      DelejPrvniREDQ_TChl(histInsert, histDelkyTrubek1, NIL, NIL);          //?????
      ZmenaProjektu := TRUE;
      MaVymazatVypocet := TRUE;
      DelejVymazVypocet_99;;
    end else begin
      DelejVratKrokUNDQ_99;
    end;

{    FreeSeznamy12(AmiLispik);
    FreeModulyDPC(AmiLispik, ProtokolStrings, TRUE);
    FreeKoralkyJT(AmiLispik);
    FreeFiktivniPatu(AmiLispik); }
    FreeABCD(AmiLispik, ProtokolStrings, TRUE);
    DelejTabulky_99;
    DelejInvalidu_99;
    NemuzeUlozit := FALSE;
  end;
  Result := TRUE;
end;

procedure TFrForm99.APrivodniZpatecka1Click_99;
begin
  with ATopChlad do
    if NastaveniTopChlad.BCooling then DelkyTrubekT1T2_99(TypTrubka3)
                                  else DelkyTrubekT1T2_99(TypTrubka1);
end;

procedure TFrForm99.AZpateckaPrivodni1Click_99;
begin
  with ATopChlad do
    if NastaveniTopChlad.BCooling then DelkyTrubekT1T2_99(TypTrubka4)
                                  else DelkyTrubekT1T2_99(TypTrubka2);
end;

procedure TFrForm99.PripravUkazkuFormE(AList : TAmiList);
begin
// tohle se musi predelat na
//  FormE.FrForm991.AmiList := AList;
//  FormE.FrForm991.KontrList := KontrList;
  FormE.FrForm991.ATopChlad.AmiLispik.ZnicList;
  DelejKopiidoListu(AList, FormE.FrForm991.ATopChlad.AmiLispik);
  if AForm99<>NIL then
    FormE.BoundsRect := AForm99.BoundsRect;
  FormE.FrForm991.KoefZvetseni := KoefZvetseni;
  FormE.FrForm991.BitBtn0.Caption := IntToStr(Round(100*KoefZvetseni));
  FormE.FrForm991.PocAmi := PocAmi;
  FormE.FrForm991.AbsGriq := AbsGriq;
  FormE.FrForm991.ScrollBar1.Position := ScrollBar1.Position;
  FormE.FrForm991.ScrollBar2.Position := ScrollBar2.Position;
  FormE.FrForm991.Korka := Korka;
//  FormE.FrForm991.ProtokolStrings := ProtokolStrings;
  FormE.FrForm991.Timer2.Enabled := FALSE;
  FormE.FrForm991.BitBtn0.Caption := IntToStr(Round(100*KoefZvetseni));
  FormE.FrForm991.Panel1.Visible := FALSE;
  FormE.FrForm991.ObdBiMa := ObdBiMa;
  FormE.FrForm991.OtevrenyProjekt := TRUE;
  FormE.FrForm991.DelejInvalidu_99;

end;

procedure TFrForm99.UlozJakoModul1Click_99;
var
  Listik : TAmiList;
  Modul : TAmiModul;
begin
  with ATopChlad do begin
    Listik := TAmiList.Create;
    DelejVlozdoListu(VybList, OznList, Listik);

    DelejOznAmi_99(NIL);
    DelejMoveAmi_99(NIL);
    JakobyPageControlChange;

    Modul := TAmiModul.Creatf(AmiLispik,Point(0,0),Point(100,100),TypModul);
    Modul.ModulList := Listik;
    KontrList.Clear;
    ProtokolStrings.Clear;
    if NOT Modul.KontrolaModoulu(NastaveniTopChlad.Mod_Chlazeni_x_Topeni, TRUE, TRUE, FALSE, FALSE, KontrList,
                             ProtokolStrings{, NIL}) then begin
      FormE.Caption := SNeniModul;
      PripravUkazkuFormE(Modul.ModulList);
      FormE.FrForm991.ListBoxProtokolF.Items.Assign(ProtokolStrings);
      FormE.CoZobrazuje := 0;
      FormE.FrForm991.Kontrolaprojektu1Click_99;
      FormE.ShowModal;
    end else begin
      UlozList_99(Listik, 2);

    end;

    Modul.Free;

    DelejInvalidu_99;

    Listik.ZnicList;
    Listik.Free;
  end;
end;

procedure TFrForm99.UlozJakoSablonu1Click_99;
var
  Listik : TAmiList;
begin
  with ATopChlad do begin
    Listik := TAmiList.Create;
    DelejVlozdoListu(VybList, OznList, Listik);
    UlozList_99(Listik, 1);
    Listik.ZnicList;
    Listik.Free;
  end;
end;

Function TFrForm99.VlozitSoubor1Click_99 : boolean;
var
  AmiModul : TAmiModul;
  Sukces : integer;
  StreamPosition : integer;
//  ATypOtSous,
  BTypOtSous : integer;
  ATypUlozeni : integer;
  AVerze : integer;
begin
  Result := FALSE;
  with ATopChlad do begin
    SpojitaRozdelitTrubky := FALSE;
    RozdelitTrubkyPokoji := FALSE;

    with DataModule1.OpenDialog1 do begin
      Title := SOtevrit;
      Options := Options+[ofPathMustExist, ofFileMustExist];
      DefaultExt := ExtSab;
      InitialDir := ExtractFileDir(JmenoVlozeneho);
      if InitialDir='' then
  //      InitialDir := GetCurrentDir+DataDir;
        InitialDir := DataDirectory;

      FileName := JmenoVlozeneho;
      Filter := FilterVlozit;
      if Execute then begin
        Try
          AmiModul := TAmiModul.Create(NIL);
          AmiModul.Jmeno := FileName;
          AmiModul.CtiModul(Sukces, StreamPosition, ATypUlozeni, AVerze);
          SpocitatBodySpojTr := TRUE;
          SpocitatBodyNedotahuTr := TRUE;
          if Sukces=0 then begin
  //          ATypOtSous := ZjistiJednotrubku(AmiLispik);
            BTypOtSous := ZjistiJednotrubku(AmiModul.ModulList);
            if ((NOT BJeOchlazovani) OR NastaveniTopChlad.BCooling) AND (BTypOtSous<0) then begin
  // nepovolime vlozit jednotrubku do vypoctu BEZ ochlazovani
              AmiModul.ModulList.ZnicList;
  {            Case ATypOtSous of
                -1 : ShowMessage(SNelzeVlozitDvoutrubku);
                1 : ShowMessage(SNelzeVlozitJednotrubku);
              end; }
              ShowMessage(SNelzeVlozitJednotrubku);
            end else begin
              JakobyClipboard.ZnicList;
              JakobyClipboard := AmiModul.ModulList;
              JmenoVlozeneho := FileName;
              DelejVlozit1Click_99;

              if SpojitaRozdelitTrubky OR RozdelitTrubkyPokoji then begin
                SpojTrubky;
                RozdelTrubky;
                RozdelTrubPokoji;
              end;

              DelejOpravVztahy_99;
              BZobrazitsKontrolou := FALSE;

              ZmenaProjektu := TRUE;
              MaVymazatVypocet := TRUE; { doplnit }
              DelejVymazVypocet_99;;
              Result := TRUE;
            end;
          end;
          DelejListTypuTrubek(AmiLispik, ListTypuTrubek);
        finally
          AmiModul.Free;
        end;
      end;
    end;
  end;
end;

procedure TFrForm99.DelejVlozdoClipboardu_99;
{ ulozi do Clipboardu }
{  zatim do Listu do pameti  }
var
  i : integer;
  AC : TAmiClass;
begin
  with ATopChlad do begin
    DelejVlozdoListu(VybList, OznList, JakobyClipBoard);

    // vyhodi z popisu mistnosti cisla
    for i := JakobyClipBoard.Count-1 downto 0 do begin
      AC := JakobyClipBoard.Items[i];
      if (AC is TAmiPokoj) then begin
        TAmiPokoj(AC).Symbol := '';
      end;
    end;
  end;
  DelejUmozniUpravy_99;
end;

procedure TFrForm99.DelejVlozClipboard_99(ABod : TPoint);
begin
//  ATopChlad.DelejVlozClipboard_TChl(ABod);
  if JakobyClipBoard.Count>0 then begin
    ATopChlad.DelejVlozzListu(JakobyClipBoard, ABod);
    DelejInvalidu_99;         // musi znovu zobrazit objekty AmiPopis
    DelejVlozdoClipboardu_99;    // znovu vytvori v Clipboardu vlozene objekty
  end;
end;

procedure TFrForm99.ShowDockPanel_99(APanel: TPanel; MakeVisible: Boolean; Client: TControl);
begin
  //Client - the docked client to show if we are re-showing the panel.
  //Client is ignored if hiding the panel.

  //Since docking to a non-visible docksite isn't allowed, instead of setting
  //Visible for the panels we set the width to zero. The default InfluenceRect
  //for a control extends a few pixels beyond it's boundaries, so it is possible
  //to dock to zero width controls.

  //Don't try to hide a panel which has visible dock clients.
  if not MakeVisible and (APanel.VisibleDockClientCount > 1) then
    Exit;

  HSplitter.Visible := MakeVisible;

  if MakeVisible then begin
    if (BottomDockPanelHeight<=0) OR
       (BottomDockPanelHeight>3*ClientHeight div 4) then
      BottomDockPanelHeight := ClientHeight div 4;
    APanel.Height := BottomDockPanelHeight;
    HSplitter.Top := ClientHeight - APanel.Height - HSplitter.Width;
  end else begin
    BottomDockPanelHeight := APanel.Height;
    APanel.Height := 0;
  end;

  if MakeVisible and (Client <> nil) then Client.Show;
end;

Procedure TFrForm99.UkazForm_99(AForm : TForm);
begin
  with AForm do
    //if the docked window is TabDocked, it is docked to the PageControl
    //(owned by TTabDockHost) so show the host form.
    if HostDockSite is TPageControl then
      TTabDockHost(HostDockSite.Owner).Show
    else
      //If window is conjoin-docked, host and/or form may not be visible
      //so show both.
      if (HostDockSite is TConjoinDockHost) and not HostDockSite.Visible then
      begin
        HostDockSite.Show;
        TConjoinDockHost(HostDockSite).UpdateCaption(nil);
        AForm.Show;
        HostDockSite.BringToFront;
        AForm.BringToFront;
      end else
        //If form is docked to one of the "hidden" docking panels, resize the
        //panel and re-show the docked form.
        if (HostDockSite is TPanel)
        and ((HostDockSite.Height = 0) or (HostDockSite.Width = 0)) then
          ShowDockPanel_99(HostDockSite as TPanel, True, AForm)
        else begin
          //if the window isn't docked at all, simply show it.
          AForm.Show;
          AForm.BringToFront;
        end;

  AForm.Invalidate;
end;

Procedure TFrForm99.Uloz1Click_99;
begin
  AUlozitProjekt_99;
end;

procedure TFrForm99.UlozJako1Click_99;
var
  i : integer;
begin
  if UlozList_99(ATopChlad.AmiLispik,0) then begin
    Form_Rb1.Ribbon1.AddRecentItem(ATopChlad.JmenoProjektu);
{    HistPosledniSouboru.Insert(0, ATopChlad.JmenoProjektu);
    ZrusHistSouboryPres; }
  end;
end;

Function TFrForm99.AUlozitProjekt_99 : boolean;
var
  i : integer;
begin
  Result := FALSE;
  with ATopChlad do begin
    if ZadatJmeno then begin
      Result := UlozList_99(AmiLispik, 0);
    end else begin
      JakobyPageControlChange;
      Result := UlozListdoSouboru(AmiLispik, JmenoProjektu, 0);
    end;

    if Result then begin
      Form_Rb1.Ribbon1.AddRecentItem(JmenoProjektu);
{      for i := 0 to HistPosledniSouboru.Count-1 do
        if UpperCase(JmenoProjektu)=UpperCase(HistPosledniSouboru[i]) then begin
          HistPosledniSouboru.Delete(i);
          Break;
        end;

      HistPosledniSouboru.Insert(0, JmenoProjektu);
      ZrusHistSouboryPres; }
    end;
  end;
end;

Function TFrForm99.ZavritProjekt_99 : boolean;
begin
  Result := FALSE;
  JakobyPageControlChange;
//  UlozListdoSouboru(AmiLispik, JmenoProjektu, 0);
  if AUlozitProjekt_99 then begin
    OtevrenyProjekt := FALSE;

    with ATopChlad do begin
      OznList.Clear;
      VybList.Clear;

      AmiLispik.ZnicList;
      NastavPrazdnyProjekt_99;

      AktAmiMove := NIL;
      AktAmiOzn  := NIL;
      AktAmiPom  := NIL;
      JakobyPageControlChange;
      DelejTabulky_99;
      DelejUmozniUpravy_99;
      FormStrop1.CheckBox1.Checked := TRUE;
      ZmenaProjektu := FALSE;
    end;
    Result := TRUE;
  end;
end;

Function TFrForm99.NovyProjekt_99(Jmeno : String) : boolean;
var
  i, j : integer;
  S, AJm : String;
  JmProjTepZtr : String;
  AJsouTepelneZtraty : boolean;
  Jmenp : String;
  ObsazenovListForm99 : boolean;
  AJmenoProjektu : String;
  ADataDirectory : String;
begin
  Result := FALSE;
  JmProjTepZtr := ProjektTepelnychZtrat;
  if JmProjTepZtr<>'' then begin
    JmProjTepZtr := ChangeFileExt(JmProjTepZtr, ExtensionIMI);
    JmProjTepZtr := ExtractFileName(JmProjTepZtr);
  end;

  Jmenp := Jmeno;
  if Jmenp<>'' then begin
    Jmenp := ChangeFileExt(Jmenp, ExtensionIMI);
    Jmenp := ExtractFileName(Jmenp);
  end;

  if Jmenp='' then begin
    AJsouTepelneZtraty := JmProjTepZtr<>'';
  end else begin
    AJsouTepelneZtraty := UpperCase(JmProjTepZtr)=UpperCase(Jmenp);
  end;

  AJsouTepelneZtraty := FALSE;
  AJmenoProjektu := Jmeno;
  if JmProjTepZtr<>'' then begin

    if Jmeno='' then begin
      AJsouTepelneZtraty := TRUE;
      AJmenoProjektu := JmProjTepZtr;
    end else begin
      AJsouTepelneZtraty := UpperCase(JmProjTepZtr)=UpperCase(Jmenp);
      AJmenoProjektu := Jmeno;
    end;
  end;

  if AJsouTepelneZtraty then begin
    TFormP(AFormP).AdvStringGridPokoj.ColCount := PocPevSloup+8;
  end else begin
    if AJmenoProjektu='' then begin
      if DataDirectory='' then
        DataDirectory := IncludeTrailingBackslash(GetCurrentDir)+DataDir;
      ADataDirectory := IncludeTrailingBackslash(DataDirectory);
      for i := 1 to MaxInt do begin
        AJm := ADataDirectory+'ProjTA'+IntToStr(i)+ExtensionIMI;
        ObsazenovListForm99 := FALSE;
        for j := 0 to ListForm99.Count-1 do begin
          S := TForm99(ListForm99[j]).AFrForm99.ATopChlad.JmenoProjektu;
          if UpperCase(AJm)=UpperCase(S) then begin
            ObsazenovListForm99 := TRUE;
            break;
          end;
        end;
        if NOT ObsazenovListForm99 then begin
          S := Form_RB1.FrForm991.ATopChlad.JmenoProjektu;
          if UpperCase(AJm)=UpperCase(S) then
            ObsazenovListForm99 := TRUE;
        end;
        if NOT ObsazenovListForm99 then begin
          S := FormA.FrForm991.ATopChlad.JmenoProjektu;
          if UpperCase(AJm)=UpperCase(S) then
            ObsazenovListForm99 := TRUE;
        end;

        if NOT ObsazenovListForm99 then begin
          S := AJm;
          if NOT FileExists(S) then begin
            AJmenoProjektu := AJm;
            break;
          end;
        end;
      end;
    end;
    TFormP(AFormP).AdvStringGridPokoj.ColCount := PocPevSloup+7;
  end;

  with DataModule1.SaveDialog1 do begin
    Title := SZadejteJmenoProjektu;
    DefaultExt := ExtAmi;
    FileName := AJmenoProjektu;
    Filter := FilterProjektu;

    InitialDir := ExtractFileDir(FileName);
    if InitialDir='' then
//      InitialDir := GetCurrentDir+DataDir;
      InitialDir := DataDirectory;

    if Execute then begin

      ATopChlad.JmenoProjektu := FileName;

//      AsponJedenProjekt := TRUE;

      ATopChlad.ZadatJmeno := TRUE;

      KnofZvClick(KnofZvets[3]);

      for i := 1 to PocPopisuEdit do
        ATopChlad.PopisyEdit[i] := '';
      for i := 1 to PocPopisuMemo do
        ATopChlad.PopisyMem1[i] := '';

      for I := 0 to PocSymbAmi-1 do
        ATopChlad.SymbolAmi[i] := '';
      for I := 0 to PocSymbAmi-1 do begin
        ATopChlad.SeznamySymbAmi[i].Free;
        ATopChlad.SeznamySymbAmi[i] := NIL;
      end;

      ATopChlad.DelejVlozIMIdoSeznamuTrubek;
      ATopChlad.DelejVlozTerVentdoSeznamuVentilu;


      ZobrVrazOdpory    := TRUE;
      ZobrVyplnOT := TRUE;
      ZobrPopisTrubek   := TRUE;
      ZobrPopisStoup    := TRUE;
      ZobrPrutokTrubek  := TRUE;

      ZobrPopisVentilu  := TRUE;
      ZobrPrutokVentilu := TRUE;

      ZobrCimru         := TRUE;
      ZobrPopisPokoju   := TRUE;
      ZobrPopisPoknadOT := FALSE;
      ZobrJmemoPokoju   := TRUE;
      ZobrTeplaQPokoju  := TRUE;
      ZobrCool_Heat     := FALSE;



      ZobrPopisOT1      := TRUE;
      ZobrPopisProcent  := TRUE;

      ZobrKoty          := TRUE;
      ZobrTextiky       := TRUE;
      ZobrCary          := TRUE;

      ATopChlad.SpocitatBodySpojTr := TRUE;
      ATopChlad.SpocitatBodyNedotahuTr := TRUE;
    {  KoefZvetseni := 1;
      Sitnice := SpSit(KoefZvetseni);
      PripravGrid(BitMapGrid,KoefZvetseni,clDkGray,Grid); }
{      GenerovatSmerVody1.Checked := TRUE;
      GenerovatZeslTrub1.Checked := TRUE;
      AGenerovatSmerVody1.Checked := TRUE;
      AGenerovatZeslTrub1.Checked := TRUE; }

      PosicevNastZoomu := -1;
{      DelejZrusNastZoomu;

      NastavListyKonfliky(TRUE);

      ToolB97Zobr2.Down := FALSE;
      ToolB97Zobr3.Down := FALSE; }


//      ToolB97Zobr5.Enabled := FALSE;
//      ToolB97Zobr6.Enabled := FALSE;
      NastavToolB97Zobr5_6_FormA(FALSE, FALSE);

      ATopChlad.PrycsVypoctem;

//      BJeOchlazovani := FALSE;

//      Self.Caption := DejIMIIMICaption;
      AFormP.Caption := ATopChlad.JmenoProjektu;
      SchovejFormF_99;
      ATopChlad.BUkazatStoupacky := FALSE;
{      Cooling_x_Heating(BCooling);
      UmozniSchovatListy_99; }

      DataDirectory := ExcludeTrailingBackslash(ExtractFilePath(FileName));
      DelejInvalidu_99;

      Result := TRUE;
    end;
  end;
end;

Function TFrForm99.UlozList_99(AList : TAmiList; Co : integer) : boolean;
begin
  Result := FALSE;
  JakobyPageControlChange;

  with DataModule1.SaveDialog1 do begin
    Case Co of
      0 : begin
        Title := SUlozitProjekt;
        DefaultExt := ExtAmi;
        FileName := ATopChlad.JmenoProjektu;
        Filter := FilterProjektu;
      end;
      1 : begin
        Title := SUlozitSablonu;
        DefaultExt := ExtSab;
        FileName := JmenoSablony;
        Filter := FilterSablony;
      end;
      2 : begin
        Title := SUlozitModul;
        DefaultExt := ExtMod;
        FileName := JmenoModulu;
        Filter := FilterModulu;
      end;
    end;
    InitialDir := ExtractFileDir(FileName);
    if InitialDir='' then
//      InitialDir := GetCurrentDir+DataDir;
      InitialDir := DataDirectory;

    if Execute then begin
      with ATopChlad do begin
        if UlozListdoSouboru(AList, FileName, Co) then begin
          if FileName<>'' then
            DataDirectory := ExcludeTrailingBackslash(ExtractFilePath(FileName));
          Case Co of
            0 : begin
              JmenoProjektu := FileName;
              ZadatJmeno := FALSE;
              ZmenaProjektu := FALSE;
              Self.Caption := DejIMIIMICaption;
              AFormP.Caption := JmenoProjektu;
              if AForm_A is TFormA then
                if AForm99<>NIL then
                  AForm_A.Caption := DejZakladniCaption else
                  AForm_A.Caption := DejZakladniCaption+'  '+ATopChlad.DejIMIIMICaption;

              if (AForm_A is TForm_Rb1) then begin
                AForm_A.Caption := DejZakladniCaption+'  '+ATopChlad.DejIMIIMICaption;
//                TForm_Rb1(AForm_A).Ribbon1.Caption := AForm_A.Caption;
                TForm_Rb1(AForm_A).Ribbon1.DocumentName := ATopChlad.DejIMIIMICaption;

              end;
              if (AForm_A is TForm99) then
                AForm_A.Caption := ATopChlad.DejIMIIMICaption;

  {            UlozParametryProjektu(FileName); }
            end;
            1 : JmenoSablony := FileName;
            2 : JmenoModulu := FileName;
          end;
          Result := TRUE;
        end;
      end;
    end;
  end;
end;

Procedure TFrForm99.VidPanel3_99(jak : boolean);
begin
  if AForm_A is TFormA then
    TFormA(AForm_A).VidPanel3(jak);
end;

procedure TFrForm99.PopupMenu2Popup(Sender: TObject);
begin
  if AForm_A is TFormA then begin
    Panelynastroju2.Visible := TRUE;
    BStatusBar1.Visible := TRUE;
    BStatusBar2.Visible := FALSE;

    Konstrukce2.Visible := TRUE;
    Standardni2.Visible := TRUE;
    Zobrazeni2.Visible := TRUE;
    N101.Visible := TRUE;
    N102.Visible := TRUE;
    N103.Visible := TRUE;
    N104.Visible := TRUE;
    N105.Visible := TRUE;
    N106.Visible := TRUE;
    N107.Visible := TRUE;
    N108.Visible := TRUE;
    N109.Visible := TRUE;
    N110.Visible := TRUE;
    N111.Visible := TRUE;
    N1A.Visible := TRUE;
    N112.Visible := TRUE;
    N113.Visible := TRUE;
    N1B.Visible := TRUE;

    Konstrukce2.Checked := TFormA(AForm_A).ToolBar975.Visible;
    Standardni2.Checked := TFormA(AForm_A).ToolBar973.Visible;
    Zobrazeni2.Checked := TFormA(AForm_A).ToolBar97Zobr.Visible;
    N101.Checked := TFormA(AForm_A).ToolBar9711.Visible;
    N102.Checked := TFormA(AForm_A).ToolBar9712.Visible;
    N103.Checked := TFormA(AForm_A).ToolBar9713.Visible;
    N104.Checked := TFormA(AForm_A).ToolBar9714.Visible;
    N105.Checked := TFormA(AForm_A).ToolBar9715.Visible;
    N106.Checked := TFormA(AForm_A).ToolBar9716.Visible;
    N107.Checked := TFormA(AForm_A).ToolBar9717.Visible;
    N108.Checked := TFormA(AForm_A).ToolBar9718.Visible;
    N109.Checked := TFormA(AForm_A).ToolBar9719.Visible;
    N110.Checked := TFormA(AForm_A).ToolBar9720.Visible;
    N111.Checked := TFormA(AForm_A).ToolBar9721.Visible;
    N112.Checked := TFormA(AForm_A).ToolBar9722.Visible;
    N113.Checked := TFormA(AForm_A).ToolBar9723.Visible;
  end else begin
    Panelynastroju2.Visible := FALSE;
    BStatusBar1.Visible := FALSE;
    BStatusBar2.Visible := TRUE;

    Konstrukce2.Visible := FALSE;
    Standardni2.Visible := FALSE;
    Zobrazeni2.Visible := FALSE;
    N101.Visible := FALSE;
    N102.Visible := FALSE;
    N103.Visible := FALSE;
    N104.Visible := FALSE;
    N105.Visible := FALSE;
    N106.Visible := FALSE;
    N107.Visible := FALSE;
    N108.Visible := FALSE;
    N109.Visible := FALSE;
    N110.Visible := FALSE;
    N111.Visible := FALSE;
    N1A.Visible := FALSE;
    N112.Visible := FALSE;
    N113.Visible := FALSE;
    N1B.Visible := FALSE;
  end;

{  if AFrForm_99<>NIL then begin
    BStatusBar.Checked := AFrForm_99.StatusBar1.Visible;
  end else begin
    BStatusBar.Checked := FALSE;
  end; }
  BStatusBar1.Checked := StatusBar1.Visible;
  BStatusBar2.Checked := StatusBar1.Visible;
end;

procedure TFrForm99.PosunSmer_99(Cislo : integer);
begin
  ATopChlad.PosunSmer_TChl(Cislo);
  DelejInvalidu_99;
end;

procedure TFrForm99.NastavToolB97Zobr5_6_FormA(ZoomZpet, ZoomVpred : boolean);
begin
  if AForm_A is TFormA then
    TFormA(AForm_A).NastavToolB97Zobr5_6(ZoomZpet, ZoomVpred);
end;

procedure TFrForm99.Novy1Click_99;
begin
  if AForm_A is TFormA then
    TFormA(AForm_A).Novy1Click(Self);
end;

procedure TFrForm99.Precti1Click_99;
begin
  if AForm_A is TFormA then
    TFormA(AForm_A).Precti1Click(Self);
end;

function TFrForm99.DelejPrecti1Click_99(AJmeno : String) : integer;
begin
  Result := CtiProjekt_99(AJmeno);
  if Result>=0 then begin
//  DelejSeznamTrubek;
    DelejTabulky_99;
  { nastavi tak, aby se projekt zobrazil cely }
    KnofZvClick(KnofZvets[9]);
  end;
end;

function TFrForm99.CtiProjekt_99(AJmeno : String) : integer;
var
  R : integer;
  i : integer;
begin
  Result := -1;
  with ATopChlad do begin
    KontrList.Clear;
    ProtokolStrings.Clear;
    if DelejCtiProjekt_99(AJmeno, TRUE) then begin
      Caption := AJmeno;
{      for i := 0 to HistPosledniSouboru.Count-1 do
        if UpperCase(AJmeno)=UpperCase(HistPosledniSouboru[i]) then begin
          HistPosledniSouboru.Delete(i);
          Break;
        end;

      HistPosledniSouboru.Insert(0, AJmeno);
      ZrusHistSouboryPres; }

      Form_Rb1.Ribbon1.AddRecentItem(AJmeno);
      Result := 0;
    end;
  end;
end;

Function TFrForm99.DelejPrectiProjekt_99(JmenoSouboru : String) : integer;
var
  AmiModul : TAmiModul;
  Sukces : integer;
  StreamPosition : integer;
  ATypUlozeni : integer;
  CCooling : boolean;
  AVerze : integer;
begin
  Result := -1;
//  CCooling := BCooling;
  Try
    AmiModul := TAmiModul.Create(NIL);
    AmiModul.Jmeno := JmenoSouboru;
    AmiModul.CtiModul(Sukces, StreamPosition, ATypUlozeni, AVerze);
//      UklidpoVypoctu;
//      AFormI.Close;
//      AFormI.PageControl1.ActivePage := FormI.TabSheet0;
    with ATopChlad do begin
      if Sukces=0 then begin
        AmiLispik.Free;
        AmiLispik := AmiModul.ModulList;


        Result := 0;
        SpocitatBodySpojTr := TRUE;
        SpocitatBodyNedotahuTr := TRUE;
        DoctiNastaveniTopChlad(JmenoSouboru, StreamPosition, ATypUlozeni, AVerze);

        H_Vyprazdni_Historii(TRUE);
        H_List_do_Historie(TRUE, histPrectiSoubor);
        H_Razitko_do_Historie(TRUE, histPrectiSoubor);
        H_Parametry_do_Historie(TRUE, histPrectiSoubor);
        MinStoryCoUndo := 3;
        Case HesCos of
          -1 : if NastaveniTopChlad.BCoolingProj then begin
            DialogsCZ.ShowMessage(SProjektChlazeni);
            NastaveniTopChlad.BCooling := FALSE;
          end;
          1 : if NOT NastaveniTopChlad.BCoolingProj then begin
            DialogsCZ.ShowMessage(SProjektTopeni);
            NastaveniTopChlad.BCooling := TRUE;
          end;
        end;

        DelejListTypuTrubek(AmiLispik, ListTypuTrubek);
  {      case ZjistiJednotrubku(AmiLispik) of
          -1 : Jednotrubka := TRUE;
          1 : Jednotrubka := FALSE;
        end;                  }

        if ZjistiJednotrubku(AmiLispik)<0 then begin
  // Pojistka - nemuze byt neochlazovana jednotrubka
          if NOT BJeOchlazovani then begin
            RozdelTrubPokoji;
            BJeOchlazovani := TRUE;
          end;
        end;
        TlacitkaPriJednotrubce_99;

  //      if CCooling<>BCooling then
          Cooling_x_Heating_99(NastaveniTopChlad.BCooling);

        UmozniSchovatListy_99;


        DelejInvalidu_TChl;
        if UpperCase(ExtractFileExt(JmenoSouboru))=ExtensionIMI then begin
          JmenoProjektu := JmenoSouboru;
          ZadatJmeno := FALSE;
        end else begin
          JmenoProjektu := ChangeFileExt(JmenoSouboru, ExtensionIMI);
          ZadatJmeno := TRUE;
        end;
      end else begin
        JmenoProjektu := ChangeFileExt(JmenoSouboru, ExtensionIMI);
        ZadatJmeno := TRUE;
        Result := -1;
        DialogsCZ.MessageDlg(SChybaPriCteniProjektu+JmenoSouboru, mtWarning, [mbOk], 0);
      end;
    end;
  finally
    AmiModul.Free;
//    VybList.Clear;
//    OznList.Clear;
//    DelejOznAmi(NIL);
  end;
//  Caption := DejIMIIMICaption;
//  FormularGridu.Caption := Caption;
  AFormP.Caption := ATopChlad.JmenoProjektu;
  ATopChlad.ZmenaProjektu := FALSE;
  JeOblastProTisk := FALSE;
end;

Function TFrForm99.DelejCtiProjekt_99(JmenoSouboru : String;
                                 ZobrazitHlasku : boolean) : boolean;
var
  JmProjTepZtr : String;
  R : integer;
begin
  Result := FALSE;

//  MuzeNovyProjekt := TRUE;

  PosicevNastZoomu := -1;
  DelejZrusNastZoomu_99;

  if AForm_A is TFormA then
    with TFormA(AForm_A) do begin
//      NastavListyKnofliky(TRUE);

      ToolB97Zobr1.Down := FALSE;
      ToolB97Zobr2.Down := FALSE;
      ToolB97Zobr3.Down := FALSE;

      ToolB97Zobr5.Enabled := FALSE;
      ToolB97Zobr6.Enabled := FALSE;

    end;

//    if AForm_A is TForm_Rb1 then
//    with TForm_Rb1(AForm_A) do begin
//      NastavRibbonKnofliky(TRUE);

//    end;
    //  PrycsVypoctem;

  JeOblastProTisk := FALSE;
  with ATopChlad do begin
    OznList.Clear;
    VybList.Clear;

    AmiLispik.ZnicList;
    AktAmiMove := NIL;
    AktAmiOzn  := NIL;
    AktAmiPom  := NIL;
    JakobyPageControlChange;
    DelejTabulky_99;

//    if AForm_A is TFormA then
//      TFormA(AForm_A).NastavListyKnofliky(TRUE);

    DelejUmozniUpravy_99;
    FormStrop1.CheckBox1.Checked := TRUE;
    ZmenaProjektu := FALSE;

  //      Novy1Click(Self);
//    if MuzeNovyProjekt then
    begin

//      AsponJedenProjekt := TRUE;


      R := DelejPrectiProjekt_99(JmenoSouboru);
      if R=0 then begin
        Caption := JmenoSouboru;
        if AForm99<>NIL then
          AForm99.Caption := Caption;
        Result := TRUE;
        JmProjTepZtr := ProjektTepelnychZtrat;
        if JmProjTepZtr<>'' then begin
          if Pos(UpperCase(JmProjTepZtr), UpperCase(JmenoProjektu))>0 then begin
            TFormP(AFormP).AdvStringGridPokoj.ColCount := PocPevSloup+8;
          end else begin
            TFormP(AFormP).AdvStringGridPokoj.ColCount := PocPevSloup+7;

            if ZobrazitHlasku then
              DialogsCZ.MessageDlg(RuznaJmenoProjektu+#10+#13+
                       JmProjTepZtr, mtWarning, [mbOk], 0);
          end;
        end else begin
          TFormP(AFormP).AdvStringGridPokoj.ColCount := PocPevSloup+7;
        end;

        SchovejFormF_99;
        SchovejFormBV_99;

        BUkazatStoupacky := FALSE;
      end;
    end;

    DelejZakazUNDO_99;
    DelejZakazREDO_99;
  end;
end;

procedure TFrForm99.AUkazFixDiamTr1Click_99;
var
  AC : TAmiClass;
  i : integer;
begin
  with ATopChlad do begin
    VybList.Clear;

    for i := 0 to AmiLispik.Count-1 do begin
      AC := AmiLispik[i];
      if (AC is TAmiTrubka) AND (AC.Typ in [TypTrubka1..TypTrubka6]) then
        if TAmiTrubka(AC).Prumer>0 then
          VybList.Add(AC);
    end;

    DelejTabulky_99;
    DelejInvalidu_99;
  end;
end;

procedure TFrForm99.ZobrazAbsList(AList : TAmiList; ABod : TPoint);
var
  i : integer;
  AC : TAmiClass;
  APoc, AbsPoc : TPoint;
begin
  if AList.Count>0 then begin
    APoc := Point(MaxInt,MaxInt);
    for i := 0 to AList.Count-1 do begin
      AC := AList.Items[i];
      if NOT (AC is TAmiPopis) then begin
        APoc.X := Min(APoc.X, AC.Pocatek.X);
        APoc.Y := Min(APoc.Y, AC.Pocatek.Y);
        APoc.X := Min(APoc.X, AC.AbsKonec.X);
        APoc.Y := Min(APoc.Y, AC.AbsKonec.Y);
      end;
    end;
    if APoc.X=MaxInt then begin
      for i := 0 to AList.Count-1 do begin
        AC := AList.Items[i];
        APoc.X := Min(APoc.X, AC.Pocatek.X);
        APoc.Y := Min(APoc.Y, AC.Pocatek.Y);
      end;
    end;
    
    DelejSpocAbsBodik(PocAmi, APoc, KoefZvetseni, AbsPoc);


    for i := 0 to AList.Count-1 do begin
      AC := AList.Items[i];
      AC.AbsObd(KoefZvetseni, PocAmi);

      if AC is TAmiSchema then  // kvuli dopocitani AbsPoc pro KreslAbs
        AC.Kresli(NIL, KoefZvetseni, 4, PocAmi);

      AC.KreslAbs(PaintBox1.Canvas,
                  Point(ABod.X-AbsPoc.X, ABod.Y-AbsPoc.Y));
    end;
  end;
end;

procedure TFrForm99.Zobrazeni2Click(Sender: TObject);
begin
  if AForm_A is TFormA then
    with AForm_A as TFormA do begin
      Zobrazeni2.Checked := NOT Zobrazeni2.Checked;
      ToolBar97Zobr.Visible := Zobrazeni2.Checked;
    end;
end;

procedure TFrForm99.Undo1Click_99;
var
  AC : TAmiClass;
  AX : TAmiClass;

  APosice : integer;
  AFlag : integer;
  AWhat : integer;
  AInd : integer;

  ANastaveniTopChlad : RNastaveniTopChlad;

begin

//  ObnovzDelList;
  with ATopChlad do begin
    if HistoryCoUndo>MinStoryCoUndo then begin
      HistoryCoUndo := HistoryCoUndo-1;
      if HistoryCoUndo=0 then begin
        AmiLispik.ZnicList;
      end else begin
        APosice := integer(HistoryLiUndo[HistoryCoUndo-1]);
        AFlag := integer(HistoryFlUndo[HistoryCoUndo-1]);
        HistoryStUndo.Position := APosice;
        HistoryStUndo.Read(AWhat, SizeOf(integer));
        case AWhat of
          histList : begin
            H_List_do_Historie(FALSE, AFlag);
            H_List_z_historie(TRUE, AFlag);
          end;

          histParametry : begin
            H_Parametry_do_Historie(FALSE, AFlag);
            H_Parametry_z_Historie(ANastaveniTopChlad, TRUE, AFlag);
            NastaveniTopChlad := ANastaveniTopChlad;
          end;

          histRazitko : begin

//            H_Razitko_do_Historie(HistoryStRedo, AFlag);
//            H_Razitko_z_Historie(HistoryStUndo, AFlag);
          end;

          histAC : begin
            AC := H_AmiClass_z_Historie(TRUE, AInd, AFlag);
            AX := AmiLispik[AInd];
            H_AmiClass_do_Historie(FALSE, AFlag, AX);
            AX.Assign(AC);
            AC.Free;
          end;
        end;
      end;
    end;
  end;

  if AForm_A is TFormA then
//    TFormA(AForm_A).UndoRedoKnofliky(FALSE, ZpetList.Count>0);
    TFormA(AForm_A).UndoRedoKnofliky(ATopChlad.HistoryCoUndo>ATopChlad.MinStoryCoUndo,
      ATopChlad.HistoryCoUndo>ATopChlad.MinStoryCoUndo);

{    Undo1.Enabled := FALSE;
    AUndo1.Enabled := Undo1.Enabled;
    Undo2.Enabled := Undo1.Enabled;
    ToolB97Std5.Enabled := Undo1.Enabled;

    Redo1.Enabled := ZpetList.Count>0;
    ARedo1.Enabled := Redo1.Enabled ;
    Redo2.Enabled := Redo1.Enabled ;
    ToolB97Std6.Enabled := Redo1.Enabled; }

//end;

{    AList := AmiLispik;
    AmiLispik := ZpetList;
    ZpetList := AList;
    AJeOchlazovani := BJeOchlazovani;
    BJeOchlazovani := BJeOchlazovaniOLD;
    BJeOchlazovaniOLD := AJeOchlazovani;

    AJeOhrev := BJeOhrev;
    BJeOhrev := BJeOhrevOLD;
    BJeOhrevOLD := AJeOhrev;

    Caption := DejIMIIMICaption;
    VybList.Clear;
    OznList.Clear;
    DelejOznAmi_99(NIL);
    AktAmiMove := NIL;

    SpocitatBodySpojTr := TRUE;
    SpocitatBodyNedotahuTr := TRUE;

    DelejTabulky_99;
    DelejUmozniUpravy_99;
    BZobrazitsKontrolou := FALSE;
    ZobrazitKontrolu_99(FALSE, FALSE);
    ZmenaProjektu := TRUE;

    if BUkazatStoupacky then DelejUkazatOznaceniVetvi_99(TRUE)
                        else DelejInvalidu_99;


    if AForm_A is TFormA then
      TFormA(AForm_A).UndoRedoKnofliky(FALSE, ZpetList.Count>0); }

{    Undo1.Enabled := FALSE;
    AUndo1.Enabled := Undo1.Enabled;
    Undo2.Enabled := Undo1.Enabled;
    ToolB97Std5.Enabled := Undo1.Enabled;

    Redo1.Enabled := ZpetList.Count>0;
    ARedo1.Enabled := Redo1.Enabled ;
    Redo2.Enabled := Redo1.Enabled ;
    ToolB97Std6.Enabled := Redo1.Enabled; }

    SchovejFormF_99;
    DelejVymazVypocet_99;
    ATopChlad.VypocetHotov := FALSE;
//  end;
end;

procedure TFrForm99.Undo2Click(Sender: TObject);
begin
  Undo1Click_99;
end;

procedure TFrForm99.Redo1Click_99;
var
  AC : TAmiClass;
  AX : TAmiClass;

  APosice : integer;
  AFlag : integer;
  AWhat : integer;
  AInd : integer;

  ANastaveniTopChlad : RNastaveniTopChlad;

begin
  with ATopChlad do begin
    if HistoryCoRedo>MinStoryCoRedo then begin
      HistoryCoRedo := HistoryCoRedo-1;
      HistoryCoUndo := HistoryCoUndo+1;
      if HistoryCoRedo=0 then begin
        AmiLispik.ZnicList;
      end else begin
        APosice := integer(HistoryLiRedo[HistoryCoRedo-1]);
        AFlag := integer(HistoryFlRedo[HistoryCoRedo-1]);
        HistoryStRedo.Position := APosice;
        HistoryStRedo.Read(AWhat, SizeOf(integer));
        case AWhat of
          histList : begin
            H_List_z_historie(FALSE, AFlag);
          end;

          histParametry : begin
            H_Parametry_z_Historie(ANastaveniTopChlad, FALSE, AFlag);
            NastaveniTopChlad := ANastaveniTopChlad;
          end;

          histRazitko : begin

//            H_Razitko_do_Historie(HistoryStRedo, AFlag);
//            H_Razitko_z_Historie(HistoryStUndo, AFlag);
          end;

          histAC : begin
            AC := H_AmiClass_z_Historie(FALSE, AInd, AFlag);
            AX := AmiLispik[AInd];
            AX.Assign(AC);
            AC.Free;
          end;
        end;
      end;
    end;
  end;
{  with ATopChlad do begin
    if HistoryCoUndo<MaxStoryCount then begin
      HistoryCoUndo := HistoryCoUndo-1;
      if HistoryCoUndo=0 then begin
        AmiLispik.ZnicList;
      end else begin
        AHistoryCount := HistoryCount;
        APosice := integer(HistoryList[HistoryCount-1]);
        AFlag := integer(HistoryFlags[HistoryCount-1]);
        HistoryStream.Position := APosice;
        HistoryStream.Read(AWhat, SizeOf(integer));
        case AWhat of
          histList : H_List_z_historie(HistoryStream, AFlag);
          histParametry : H_Parametry_z_Historie(HistoryStream, AFlag);
          histRazitko : H_Razitko_z_Historie(HistoryStream, AFlag);
        else
          begin
            SetLength(ArrAmi, HistoryCount);
            SetLength(ArrInt, HistoryCount);
            Try
              AC := H_AmiClass_z_Historie(HistoryStream, AInd, AFlax);
              ArrAmi[HistoryCount-1] := AC;
              ArrInt[HistoryCount-1] := AInd;
              while AHistoryCount>0 do begin
                AHistoryCount := AHistoryCount-1;
                APosicx := integer(HistoryList[AHistoryCount-1]);
                AFlax := integer(HistoryFlags[AHistoryCount-1]);
                HistoryStream.Position := APosicx;
                HistoryStream.Read(AWhax, SizeOf(integer));
                case AWhax of
                  histList : begin
                    H_List_z_historie(HistoryStream, AFlag);
                    break;
                  end;
                  histParametry, histRazitko : begin
                    ArrAmi[AHistoryCount-1] := NIL;
                    ArrInt[AHistoryCount-1] := -1;
                  end;
                else
                  begin
                    AX := H_AmiClass_z_Historie(HistoryStream, AInx, AFlax);
                    ArrAmi[AHistoryCount-1] := AX;
                    ArrInt[AHistoryCount-1] := AInx;

                  end;
                end;
              end;
              for i := AHistoryCount to HistoryCount-1 do begin
                AX := ArrAmi[i];
                if AX<>NIL then begin
                  AInx := ArrInt[i];
                  AC := AmiLispik[AInx];
                  AC.Assign(AX);
                  AX.Free;
                end;
              end;
            finally
              SetLength(ArrAmi, 0);
              SetLength(ArrInt, 0);
            end;
          end;
        end;
      end;
    end;
  end; }

{  Undo1Click_99;
  if AForm_A is TFormA then
    TFormA(AForm_A).UndoRedoKnofliky(TRUE, FALSE); }
end;

procedure TFrForm99.Redo2Click(Sender: TObject);
begin
  Redo1Click_99;
end;

procedure TFrForm99.Konstrukce2Click(Sender: TObject);
begin
  if AForm_A is TFormA then
    with AForm_A as TFormA do begin
      Konstrukce2.Checked := NOT Konstrukce2.Checked;
      ToolBar975.Visible := Konstrukce2.Checked;
    end;
end;

procedure TFrForm99.KontrolaDatproVypocet1Click_99;
var
  Pata : TAmiClass;
  Dale : boolean;
begin
  with ATopChlad do begin
    NemuzeUlozit := TRUE;
    KontrList.Clear;
    ProtokolStrings.Clear;
    SchovejFormF_99;
    Dale := TRUE;
    Case HesCos of
      -1 : if NastaveniTopChlad.BCoolingProj then begin
        Dale := FALSE;
        DialogsCZ.ShowMessage(SProjektChlazeni);
      end;
      1 : if NOT NastaveniTopChlad.BCoolingProj then begin
        Dale := FALSE;
        DialogsCZ.ShowMessage(SProjektTopeni);
      end;
    end;

    if Dale then begin
      if DelejKontroluDatproVypocet(Pata)=0 then begin
    {    ProtokolStrings.Add('OK.'); }
        DelejInvalidu_99;
        Repaint;
        DialogsCZ.ShowMessage(SKontrolaproVypocetOK);
      end else begin
        PripravFormF_99;
      end;
    end;
    NemuzeUlozit := FALSE;
    SchovejFormBV_99;
  end;
end;

procedure TFrForm99.TiskProtokolF1Click(Sender: TObject);
const
  PocRadku = 50;
var
  I,j,r : Integer;
  Y : integer;
  PocStran : integer;
begin
  PocStran := 1+(ListBoxProtokolF.Items.Count-1) div PocRadku;
{  PrintDialog1.Options := [poPageNums, poSelection];
  PrintDialog1.FromPage := 1;
  PrintDialog1.MinPage := 1;
  PrintDialog1.ToPage := PageControl1.PageCount;
  PrintDialog1.MaxPage := PageControl1.PageCount; }
  if DataModule1.PrintDialog1.Execute then begin
    { determine the range the user wants to print }
    with DataModule1.PrintDialog1 do begin
      with Printer do begin
        Y := PageHeight div (PocRadku+5);
        BeginDoc;
        for I := 1 to PocStran do begin
          for j := 1 to PocRadku do begin
            r := (i-1)*PocRadku+j-1;
            if r<ListBoxProtokolF.Items.Count then
              Printer.Canvas.TextOut(50, (j+3)*Y, ListBoxProtokolF.Items[r]);
          end;
          if I<>PocStran then
            NewPage;
        end;
        EndDoc;
      end;
    end;
  end;
end;

procedure TFrForm99.ListBoxProtokolFClick(Sender: TObject);
var
  Objekt, Pbjekt : TObject;
  IntObjekt : integer absolute Objekt;
  i, P : integer;
  AC, AOzn, ASch : TAmiClass;
  S, StrP : String;
  AHoLe, ADoPr : TPoint;
  AItemIndex : integer;
begin
//  AForm.ListVybObSchemat.Clear;
  with ATopChlad do begin
    AktAmiSchemaF := NIL;
    AItemIndex := ListBoxProtokolF.ItemIndex;
    StrP := ListBoxProtokolF.Items.Strings[AItemIndex];
    Try
      Objekt := ListBoxProtokolF.Items.Objects[AItemIndex];
    except
      ListBoxProtokolF.Items.Add(' ');
      Objekt := NIL;
      Try
        Objekt := ListBoxProtokolF.Items.Objects[AItemIndex];
      except
        Objekt := NIL;
      end;
    end;
    if Objekt<>NIL then begin
      VybList.Clear;
      AOzn := NIL;
      if NOT Odd(IntObjekt) then begin
        if AmiLispik.IndexOf(Objekt)>=0 then begin
          if (Objekt is TAmiPokoj) AND (System.Pos(SPrekryvajicisePokoje, StrP)>0) then begin
            VybList.Add(Objekt);
            if ListBoxProtokolF.Items.Count>AItemIndex+1 then begin
              Pbjekt := ListBoxProtokolF.Items.Objects[AItemIndex+1];
              if AmiLispik.IndexOf(Pbjekt)>=0 then
                VybList.Add(Pbjekt);
            end;
          end else begin
            if Pos(Cyklus_v_Potrubi, StrP)=1 then begin
              // cyklus v potrubi
              for i := 0 to ProtokolListFormF.Count-1 do begin
                S := ProtokolListFormF[i];
                if S=StrP then begin
                  Pbjekt := ProtokolListFormF.Objects[i];
                  if (AmiLispik.IndexOf(Pbjekt)>=0) AND (VybList.IndexOf(Pbjekt)<0) then
                    VybList.Add(Pbjekt);
                end;
              end;
            end else begin
              if Objekt is TAmiSchema then begin


              end;

              AOzn := TAmiClass(Objekt);
              DelejOznAmi_99(AOzn);
              DelejUkazveVypoctu_99;
              VybList.Add(AOzn);
            end;
          end;
        end else begin
          if ((Objekt is TAmiTrubka) OR (Objekt is TAmiVentil)) AND
              (TAmiClass(Objekt).AnCm is TAmiSchema) AND
              (AmiLispik.IndexOf(TAmiClass(Objekt).AnCm)>=0) then begin
            ASch := TAmiClass(Objekt).AnCm;
            AOzn := ASch;
            DelejOznAmi_99(AOzn);
            DelejUkazveVypoctu_99;
            VybList.Add(AOzn);
            AktAmiSchemaF := TAmiClass(Objekt);
          end;
        end;
      end else begin
        DelejOznAmi_99(NIL);
        Case IntObjekt of
          1 : begin
          // Nepoužity všechny trubky - KontrolaModoulu
            for i := 0 to AmiLispik.Count-1 do begin
              AC := AmiLispik[i];
              if AC.IntCislo=-MaxInt then
                VybList.Add(AC);
            end;
          end;

          3 : begin
            for i := 0 to AmiLispik.Count-1 do begin
              AC := AmiLispik[i];
              if (AC is TAmiTrubka) AND (AC.Typ in [TypTrubka1..TypTrubka6]) then begin
                S := TAmiTrubka(AC).Stoup;
                if S='' then S := SNeoznVetev;
                if S=StrP then
                  VybList.Add(AC);
              end;
            end;
          end;

          5 : begin
          // Nepoužity všechny trubky pro jednotrubku
            for i := 0 to AmiLispik.Count-1 do begin
              AC := AmiLispik[i];
              if AC.IntCislo=-MaxInt+1 then
                VybList.Add(AC);
            end;
          end;

          7 : begin
          // Společný název modulu jednotrubky a dvoutrubky - TFormA.NajdiStoupacky
            P := Pos(' -- ', StrP);
            if P>0 then begin
              S := Copy(StrP, 1, P-1);
              for i := 0 to AmiLispik.Count-1 do begin
                AC := AmiLispik[i];
                if (AC is TAmiTrubka) AND (AC.Typ in [TypTrubka1..TypTrubka6]) AND
                  (S=TAmiTrubka(AC).Stoup) then
                  VybList.Add(AC);
              end;
            end;
          end;
        else
          if (IntObjekt<0) AND Odd(IntObjekt) then begin
            // Chybné označení v názvu stoupačky modulu jednotrubky
            for i := 0 to AmiLispik.Count-1 do begin
              AC := AmiLispik[i];
              if AC.IntCislo=IntObjekt then
                VybList.Add(AC);
            end;
          end;
        end;
      end;


      if VybList.Count>0 then begin
        MuzeScroll := FALSE;
        if SpocitejRozsahList(VybList, PaintBox1.Width, PaintBox1.Height,
               AHoLe, ADoPr, KoefZvetseni) then begin
          KoefZvetseni := Min(1, KoefZvetseni);


          ScrollBar1.Position := (AHoLe.X+ADoPr.X-
               Round(PaintBox1.Width/(KoefZvetseni*JMetrMM))) div 2;
          ScrollBar2.Position := -(AHoLe.Y+ADoPr.Y-
               Round(PaintBox1.Height/(KoefZvetseni*JMetrMM))) div 2 -
            Round(PaintBox1.Height/(KoefZvetseni*JMetrMM));
        end;
        DokonciNastaveniZoom_99;
        VlozNovyZoom_99(ScrollBar1.Position, ScrollBar2.Position, KoefZvetseni);

        if Assigned(AOzn) then
          VybList.Clear;
      end;

      DelejTabulky_99;
      DelejInvalidu_99;

  {    if FormE.AmiLispik.IndexOf(Objekt)>=0 then begin
        FormE.KlikAmi := TAmiClass(Objekt);
        FormE.Repaint ;
        BringToFront;
      end; }

    end;

    DelejUmozniUpravy_99;
  end;
end;

Procedure TFrForm99.SchovejFormF_99;
begin
  ToolWindowFormF.Visible := FALSE;
  ATopChlad.BZobrazitsKontrolou := FALSE;
  ZobrazitKontrolu_99(FALSE, FALSE);
end;

procedure TFrForm99.UdelejAktControl_99(WinControl : TWinControl);
var
  FG : TCustomForm;
begin
  Try
    with AFormP do
      //if the docked window is TabDocked, it is docked to the PageControl
      //(owned by TTabDockHost) so show the host form.
      if HostDockSite is TPageControl then
        TTabDockHost(HostDockSite.Owner).Show
      else
        //If window is conjoin-docked, host and/or form may not be visible
        //so show both.
        if (HostDockSite is TConjoinDockHost) and not HostDockSite.Visible then
        begin
          HostDockSite.Show;
          TConjoinDockHost(HostDockSite).UpdateCaption(nil);
          AFormP.Show;
        end else
          //If form is docked to one of the "hidden" docking panels, resize the
          //panel and re-show the docked form.
          if (HostDockSite is TPanel)
          and ((HostDockSite.Height = 0) or (HostDockSite.Width = 0)) then
            ShowDockPanel_99(HostDockSite as TPanel, True, AFormP)
          else
            //if the window isn't docked at all, simply show it.
            AFormP.Show;

    FG := GetParentForm(WinControl);
    if Assigned(FG) then begin
      FG.Show;
      FG.SetFocus;
      FG.ActiveControl := WinControl;
    end;
  except

  end;
end;

Function TFrForm99.ProjektTepelnychZtrat : String;
var
  AJm : String;
begin
  AJm := '';
  if DataModule1<>NIL then begin
{$IFDEF DATABASE_PARADOX}
    with DataModule1.TableTepZtr do begin
{$ENDIF}

{$IFDEF DATABASE_ACCESS}
    with DataModule1.DTableTepZtr do begin
{$ENDIF}
      Try
        Try
          Active := TRUE;
          AJm := FielDByName(StrBudova).AsString;
          if AJm<>'' then
            AJm := AJm+ExtensionIMI;
        except
        end;
      finally
        Active := FALSE;
      end;
    end;
  end;
  Result := AJm;
end;

Procedure TFrForm99.DelejUmozniUpravy_99;
begin
  if AForm_A is TFormA then
    TFormA(AForm_A).DelejUmozniUpravy;
end;

procedure TFrForm99.PripravFormF_99;
var
  i, N : integer;
  S1, S2 : String;
begin
{  FormF.Caption := SFCaptionVysledkyKontroly;
  FormF.ListBoxProtokol.Items.Assign(ProtokolStrings);
  FormF.AProtokolList := ProtokolStrings;
  FormF.AForm := Self; }
  ToolWindowFormF.Caption := SFCaptionVysledkyKontroly;
  ListBoxProtokolF.Items.Assign(ATopChlad.ProtokolStrings);
//  AProtokolListF := ProtokolStrings;
  N := ListBoxProtokolF.Items.Count-1;
  S1 := ListBoxProtokolF.Items[N];
  For i := N-1 downto 0 do begin
    S2 := ListBoxProtokolF.Items[i];
    if (S1=S2) AND (Pos(Cyklus_v_Potrubi, S1)=1) then
      ListBoxProtokolF.Items.Delete(i);
    S1 := S2;
  end;

  ATopChlad.BZobrazitsKontrolou := TRUE;
  ZobrazitKontrolu_99(TRUE, TRUE);

  with ATopChlad do begin
    DelejOznAmi_99(NIL);
    OznList.Clear;
    VybList.Clear;
  end;
  DelejInvalidu_99;
  DelejTabulky_99;
{    Repaint; }
  ToolWindowFormF.Visible := TRUE;
  Screen.Cursor := crDefault;
end;

procedure TFrForm99.DelejZakazUNDO_99;
begin
  with ATopChlad do
    if ZpetList<>NIL then
      ZpetList.ZnicList;
  if AForm_A is TFormA then
    TFormA(AForm_A).DelejZakazUNDO;
end;

procedure TFrForm99.DelejZakazREDO_99;
begin
  if AForm_A is TFormA then
    TFormA(AForm_A).DelejZakazREDO;
end;

procedure TFrForm99.DelejUpravStropy_99(Bod1, Bod2 : TPoint);
var
  i : integer;
  AC : TAmiClass;
  RV, RS, R0 : TRect;
  Str1, Str2 : TAmiStrop1;
  Y : integer;
  UdelalUndo : boolean;

Procedure UdelejUmozniUndp;
begin
  if NOT UdelalUndo then begin
    DelejUmozniUNDO_99;
    DelejUmozniUNDQ_99(histInsert, histUpravStropy, NIL, NIL);          //?????
    UdelalUndo := TRUE;
  end;
end;

begin
  UdelalUndo := FALSE;
  RV := SpravnyRect2( Rect(Bod1.X, Bod1.Y, Bod2.X, Bod2.Y));
  with ATopChlad do begin
    for i := AmiLispik.Count-1 downto 0 do begin
      AC := AmiLispik.Items[i];
      if (AC is TAmiStrop1) then begin
        AC.SpocitejORect;
        RS := SpravnyRect2( Rect(AC.HL.X, AC.HL.Y, AC.DP.X, AC.DP.Y));
        if IntersectRect(R0, RS, RV) then begin
          UdelejUmozniUndp;
          if RS.Left<RV.Left then begin
            Str1 := TAmiStrop1.Create(NIL);
            Str1.Assign(AC);
            Str1.AbsKonec := Point(RV.Left,AC.AbsKonec.Y);
            Str1.PraveVlozeny := TRUE;
            AmiLispik.Add(Str1);
          end;
          if RS.Right>RV.Right then begin
            Str2 := TAmiStrop1.Create(NIL);
            Str2.Assign(AC);
            Str2.Pocatek := Point(RV.Right,AC.Pocatek.Y);
            Str2.AbsKonec := AC.AbsKonec;
            Str2.PraveVlozeny := TRUE;
            AmiLispik.Add(Str2);
          end;
          AC.Free;
          AmiLispik.Delete(i);
          ZmenaProjektu := TRUE;
        end;
      end;
    end;
    if UdelalUndo then
      DelejPrvniREDQ_99(histInsert, histUpravStropy, NIL, NIL);          //?????
  end;
end;

Procedure TFrForm99.DelejVymazVypocet_99;
begin
  ATopChlad.DelejVymazVypocet_TChl;
end;

Procedure TFrForm99.CarkaNaPravitkuY; // nakresli odpovidajici carky na pravitkuY
var
  RB, AB : TPoint;
begin
  DelejSpocitejBodGrid(PocAmi, Myska, Griq, KoefZvetseni, RB);
  DelejSpocAbsBodik(PocAmi, RB, KoefZvetseni, AB);
  with PaintBoxMeritkoY.Canvas do begin
    Pen.Mode := pmXOR;
    Pen.Color := clWhite;
    MoveTo(0, AB.Y);
    LineTo(SirMer, AB.Y);
  end;
end;

Procedure TFrForm99.CarkaNaPravitkuX; // nakresli odpovidajici carku na pravitkuX
var
  RB, AB : TPoint;
begin
  DelejSpocitejBodGrid(PocAmi, Myska, Griq, KoefZvetseni, RB);
  DelejSpocAbsBodik(PocAmi, RB, KoefZvetseni, AB);
  with PaintBoxMeritkoX.Canvas do begin
    Pen.Mode := pmXOR;
    Pen.Color := clWhite;
    MoveTo(AB.X, 0);
    LineTo(AB.X, VysMer);
  end;
end;

Procedure TFrForm99.CarkyNaPravitkach; // nakresli odpovidajici carky na pravitkach
var
  RB, AB : TPoint;
begin
  DelejSpocitejBodGrid(PocAmi, Myska, Griq, KoefZvetseni, RB);
  DelejSpocAbsBodik(PocAmi, RB, KoefZvetseni, AB);
  with PaintBoxMeritkoY.Canvas do begin
    Pen.Mode := pmXOR;
    Pen.Color := clWhite;
    MoveTo(0, AB.Y);
    LineTo(SirMer, AB.Y);
  end;

  with PaintBoxMeritkoX.Canvas do begin
    Pen.Mode := pmXOR;
    Pen.Color := clWhite;
    MoveTo(AB.X, 0);
    LineTo(AB.X, VysMer);
  end;
end;

Function TFrForm99.ZadejBarvaTypStylCary_99(AmiClass : TAmiClass; prevzit : boolean) :
  integer;
var
  i : integer;
begin
  Result := 0;
  with FormQ do begin
    if AmiClass is TAmiCara then
      with AmiClass as TAmiCara do begin
        ACarySila := Sila;
        ACaryBarva := Barva;
        ACaryStyl := Styl;
        ComboBox1.ItemIndex := ACaryStyl;

        GroupBox2.Enabled := FALSE;
        ComboBox1.Enabled := TRUE;

{        ComboBox2.Enabled := FALSE;
        SpeedButton2.Enabled := FALSE; }
      end;

    if (AmiClass is TAmiTrubka) AND (AmiClass.Typ=TypTrubkaCara5) then
      with AmiClass as TAmiTrubka do begin
        ACarySila := Round(Prumer);
        ACaryBarva := Delka;
//        ACaryStyl := Izol;
        ACaryStyl := TypTr;
        ComboBox1.ItemIndex := ACaryStyl;

        GroupBox2.Enabled := FALSE;
        ComboBox1.Enabled := TRUE;

{        ComboBox2.Enabled := FALSE;
        SpeedButton2.Enabled := FALSE; }
      end;

    if AmiClass is TAmiObdelnik then
      with AmiClass as TAmiObdelnik do begin
        ACarySila := SilaCary;
        ACaryBarva := BarvaCary;
        AVyplneBarva := BarvaVzorku;
        AVyplneStyl := Vzorek;
        ComboBox2.ItemIndex := Ord(Vzorek);

        GroupBox2.Enabled := TRUE;
        ComboBox2.Enabled := TRUE;
        SpeedButton2.Enabled := TRUE;

        ComboBox1.Enabled := FALSE;
      end;


    if AmiClass is TAmiOblouk then
      with AmiClass as TAmiOblouk do begin
        ACarySila := SilaCary;
        ACaryBarva := BarvaCary;
        AVyplneBarva := BarvaVzorku;
        AVyplneStyl := Vzorek;
        ComboBox2.ItemIndex := Ord(Vzorek);

        GroupBox2.Enabled := TRUE;
        ComboBox2.Enabled := TRUE;
        SpeedButton2.Enabled := TRUE;

        ComboBox1.Enabled := FALSE;
      end;


    Edit1.Text := IntToStr(ACarySila);
    UpDown1.Position := ACarySila;

    if ShowModal=mrYes then begin
      Try
        ACarySila := StrToInt(Edit1.Text);
      except
      end;

      if AmiClass is TAmiCara then
        with AmiClass as TAmiCara do begin
          if NOT Prevzit AND
          ((Sila<>ACarySila) OR (Barva<>ACaryBarva) OR (Styl<>ACaryStyl)) then begin
            ATopChlad.ZmenaProjektu := TRUE;
            DelejUmozniUndo_99;
            DelejUmozniUNDQ_99(histZmen, histParCara, AmiClass, NIL);          //?????

            Sila := ACarySila;
            Barva := ACaryBarva;
            Styl := ACaryStyl;
            CaraSila     := ACarySila;
            CaraBarva    := ACaryBarva;
            CaraStyl     := ACaryStyl;
            DelejPrvniREDQ_99(histZmen, histParCara, AmiClass, NIL);          //?????
          end;
        end;

      if AmiClass is TAmiTrubka then
        with AmiClass as TAmiTrubka do begin
          if NOT Prevzit AND
          ((Prumer<>ACarySila) OR (Delka<>ACaryBarva) OR (TypTr {Izol}<>ACaryStyl)) then begin
            ATopChlad.ZmenaProjektu := TRUE;
            DelejUmozniUndo_99;
            DelejUmozniUNDQ_99(histZmen, histParTrub5, AmiClass, NIL);          //?????

            Prumer := ACarySila;
            Delka := ACaryBarva;
  //          Izol := ACaryStyl;
            TypTr := ACaryStyl;
            Trub5Sila     := ACarySila;
            Trub5Barva    := ACaryBarva;
            Trub5Styl     := ACaryStyl;
            DelejPrvniREDQ_99(histZmen, histParTrub5, AmiClass, NIL);
          end;
        end;

      if AmiClass is TAmiObdelnik then
        with AmiClass as TAmiObdelnik do begin
          if NOT Prevzit AND
            ((SilaCary<>ACarySila) OR (BarvaCary<>ACaryBarva) OR
             (BarvaVzorku<>AVyplneBarva) OR (Vzorek<>AVyplneStyl)) then begin
            ATopChlad.ZmenaProjektu := TRUE;
            DelejUmozniUndo_99;
            DelejUmozniUNDQ_99(histZmen, histParObdelnik, AmiClass, NIL);          //?????

            SilaCary := ACarySila;
            BarvaCary := ACaryBarva;
            BarvaVzorku := AVyplneBarva;
            Vzorek := AVyplneStyl;
            ObdCaraSila  := ACarySila;
            ObdCaraBarva := ACaryBarva;
            ObdVzorStyl  := AVyplneStyl;
            ObdVzorBarva := AVyplneBarva;
            DelejPrvniREDQ_99(histZmen, histParObdelnik, AmiClass, NIL);
          end;
        end;

      if AmiClass is TAmiOblouk then
        with AmiClass as TAmiOblouk do begin
          if NOT Prevzit AND
            ((SilaCary<>ACarySila) OR (BarvaCary<>ACaryBarva) OR
             (BarvaVzorku<>AVyplneBarva) OR (Vzorek<>AVyplneStyl)) then begin
            ATopChlad.ZmenaProjektu := TRUE;
            DelejUmozniUndo_99;
            DelejUmozniUNDQ_99(histZmen, histParOblouk, AmiClass, NIL);          //?????

            SilaCary := ACarySila;
            BarvaCary := ACaryBarva;
            BarvaVzorku := AVyplneBarva;
            Vzorek := AVyplneStyl;
            EliCaraSila  := ACarySila;
            EliCaraBarva := ACaryBarva;
            EliVzorStyl  := AVyplneStyl;
            EliVzorBarva := AVyplneBarva;
            DelejPrvniREDQ_99(histZmen, histParOblouk, AmiClass, NIL);
          end;
        end;

      if AZmena then Result := 1;
    end else begin
      Result := -1;

    end;
  end;
end;

Function TFrForm99.ZadejBarvaTypStylElipsy_99(AmiClass : TAmiClass; prevzit : boolean) :
  integer;
var
  i : integer;
  B1, B2 : TPoint;
begin
  Result := 0;
  with FormQel do begin
    if AmiClass is TAmiOblouk then
      with AmiClass as TAmiOblouk do begin
        ACarySila := SilaCary;
        ACaryBarva := BarvaCary;
        AVyplneBarva := BarvaVzorku;
        AVyplneStyl := Vzorek;
        ComboBox2.ItemIndex := Ord(Vzorek);

        GroupBox2.Enabled := TRUE;
        ComboBox2.Enabled := TRUE;
        SpeedButton2.Enabled := TRUE;

        B1 := Pocatek;
        B2 := AbsKonec;
        AR1.X := Min(B1.X, B2.X);
        AR1.Y := Min(B1.Y, B2.Y);
        AR2.X := Max(B1.X, B2.X);
        AR2.Y := Max(B1.Y, B2.Y);
      end;


    Edit1.Text := IntToStr(ACarySila);
    UpDown1.Position := ACarySila;

    Edit2.Text := IntToStr(Round((AR1.X+AR2.X)/2));
    Edit3.Text := IntToStr(Round((AR1.Y+AR2.Y)/2));
    Edit4.Text := IntToStr(Round((AR2.X-AR1.X)/2));
    Edit5.Text := IntToStr(Round((AR2.Y-AR1.Y)/2));

    Edit6.Text := IntToStr(AR1.X);
    Edit7.Text := IntToStr(AR1.Y);
    Edit8.Text := IntToStr(AR2.X);
    Edit9.Text := IntToStr(AR2.Y);

    if ShowModal=mrYes then begin
      Try
        ACarySila := StrToInt(Edit1.Text);
      except
      end;

      if AmiClass is TAmiOblouk then
        with AmiClass as TAmiOblouk do begin
          if NOT Prevzit AND
            ((SilaCary<>ACarySila) OR (BarvaCary<>ACaryBarva) OR
             (BarvaVzorku<>AVyplneBarva) OR (Vzorek<>AVyplneStyl)) then begin
            ATopChlad.ZmenaProjektu := TRUE;
            DelejUmozniUndo_99;
          end;
          SilaCary := ACarySila;
          BarvaCary := ACaryBarva;
          BarvaVzorku := AVyplneBarva;
          Vzorek := AVyplneStyl;
          Pocatek := AR1;
          AbsKonec := AR2;
          EliCaraSila  := ACarySila;
          EliCaraBarva := ACaryBarva;
          EliVzorStyl  := AVyplneStyl;
          EliVzorBarva := AVyplneBarva;
        end;

      if AZmena then Result := 1;
    end else begin
      Result := -1;

    end;
  end;
end;

Function TFrForm99.ZadejBarvaTypStylOblouku_99(AmiClass : TAmiClass; prevzit : boolean) :
  integer;
var
  i : integer;
  B1, B2 : TPoint;
  AR1, AR2 : TPoint;
  Alf1, Alf2, Alfs : integer;
begin
  Result := 0;
  with FormObl do begin
    if AmiClass is TAmiOblouk then
      with AmiClass as TAmiOblouk do begin
        ACarySila := SilaCary;
        ACaryBarva := BarvaCary;

        B1 := Pocatek;
        B2 := AbsKonec;
        AR1.X := Min(B1.X, B2.X);
        AR1.Y := Min(B1.Y, B2.Y);
        AR2.X := Max(B1.X, B2.X);
        AR2.Y := Max(B1.Y, B2.Y);
        AStred.X := Round((AR1.X+AR2.X)/2);
        AStred.Y := Round((AR1.Y+AR2.Y)/2);
        AR := Round((AR2.X-AR1.X)/2);

        Alf1 := (Alfa1 + 3*360000) mod 360000;
        Alf2 := (Alfa2 + 3*360000) mod 360000;
        Alfs := (Alf2 - Alf1 + 3*360000) mod 360000;
      end;


    Edit1.Text := IntToStr(ACarySila);
    UpDown1.Position := ACarySila;

    Edit2.Text := IntToStr(AStred.X);
    Edit3.Text := IntToStr(AStred.Y);
    Edit4.Text := IntToStr(AR);

    Edit5.Text := FloatToStrF(Alf1/1000, ffFixed, 4, 3);
    Edit6.Text := FloatToStrF(AlfS/1000, ffFixed, 4, 3);

    if ShowModal=mrYes then begin
      Try
        ACarySila := StrToInt(Edit1.Text);
      except
      end;

      if AmiClass is TAmiOblouk then
        with AmiClass as TAmiOblouk do begin
          if NOT Prevzit AND
            ((SilaCary<>ACarySila) OR (BarvaCary<>ACaryBarva)) then begin
            ATopChlad.ZmenaProjektu := TRUE;
            DelejUmozniUndo_99;
            DelejUmozniUNDQ_99(histZmen, histParOblouk, AmiClass, NIL);          //?????

            SilaCary := ACarySila;
            BarvaCary := ACaryBarva;
            Pocatek := Point(AStred.X-AR, AStred.Y-AR);
            AbsKonec := Point(AStred.X+AR, AStred.Y+AR);
            Alfa1 := AAlfa1Obl;
            Alfa2 := AAlfa1Obl + AAlfaSObl;
            EliCaraSila  := ACarySila;
            EliCaraBarva := ACaryBarva;
            DelejPrvniREDQ_99(histZmen, histParOblouk, AmiClass, NIL);
          end;
        end;

      if AZmena then Result := 1;
    end else begin
      Result := -1;

    end;
  end;
end;

Procedure TFrForm99.ZadejPopisVyska_99(AmiClass : TAmiClass);
var
  S : String;
begin
  if (AmiClass<>NIL) AND (AmiClass is TAmiVyska) then
    with AmiClass as TAmiVyska do begin
      S := DialogsCZ.InputBox(SPopisVyskoveKoty, SZapisteText, Popis);
      if S<>Popis then begin
        ATopChlad.ZmenaProjektu := TRUE;
        DelejUmozniUndo_99;
        DelejUmozniUNDQ_99(histZmen, histParVyska, AmiClass, NIL);          //?????
        Popis := S;
        DelejPrvniREDQ_99(histZmen, histParVyska, AmiClass, NIL);          //?????
      end;
    end;
end;

Function SortSourLexikograficky(Item1, Item2: Pointer): Integer;
begin
  if PPoint(Item1)^.X<PPoint(Item2)^.X then Result := -1
  else if PPoint(Item1)^.X>PPoint(Item2)^.X then Result := 1
  else if PPoint(Item1)^.Y<PPoint(Item2)^.Y then Result := -1
  else if PPoint(Item1)^.Y>PPoint(Item2)^.Y then Result := 1
  else Result := 0;
end;

Procedure KresliSpoje(AList : TAmiList; Canvas : TCanvas;
   AKoef : extended; PocSour : TPoint;
   KonceTrubekSpojX, KonceTrubekSpojY : TList;
   KonceTrubekVolX, KonceTrubekVolY : TList;
   var DelatSpojeTr : boolean;
   co : integer);
var
  AVelSpoj : integer;
  AVelVol : integer;
  PoiIntX : Pointer;
  IntPoiX : integer absolute PoiIntX;
  PoiIntY : Pointer;
  IntPoiY : integer absolute PoiIntY;
  BodySpojA : TList;
  BodySpoj : TList;
  BodyVol : TList;

function FindBod(AList : TList; const PB : PPoint; var Index: Integer): Boolean;
var
  L, H, I, C: Integer;
begin
  Result := False;
  L := 0;
  H := AList.Count - 1;
  while L <= H do begin
    I := (L + H) shr 1;
    C := SortSourLexikograficky(PPoint(AList[I]), PB);
    if C < 0 then L := I + 1 else
    begin
      H := I - 1;
      if C = 0 then
      begin
        Result := True;
        L := I;
      end;
    end;
  end;
  Index := L;
end;


Procedure KresliSpoj(Bod : TPoint);
var
  ABod : TPoint;
begin
  DelejSpocAbsBodik(PocSour, Bod, AKoef, ABod);
  Canvas.Rectangle(ABod.X-AVelSpoj, ABod.Y-AVelSpoj,
                   ABod.X+AVelSpoj, ABod.Y+AVelSpoj);
end;

Procedure DelejSpojA(var Bod : TPoint);
var
  ind : integer;
  PBod : PPoint;
begin
  if NOT FindBod(BodySpojA, PPoint(Addr(Bod)), ind) then begin
    New(PBod);
    PBod^ := Bod;
    BodySpojA.Add(PBod);
    BodySpojA.Sort(SortSourLexikograficky);
  end;
end;

Procedure DelejSpoj(var Bod : TPoint);
var
  ind : integer;
  PBod : PPoint;
begin
  if NOT FindBod(BodySpoj, PPoint(Addr(Bod)), ind) then begin
    New(PBod);
    PBod^ := Bod;
    BodySpoj.Add(PBod);
    BodySpoj.Sort(SortSourLexikograficky);
  end;
end;

Procedure KresliVol(Bod : TPoint);
var
  ABod : TPoint;
begin
  DelejSpocAbsBodik(PocSour, Bod, AKoef, ABod);
  Canvas.Ellipse(ABod.X-AVelVol, ABod.Y-AVelVol,
                 ABod.X+AVelVol, ABod.Y+AVelVol);
end;

Procedure DelejVol(Bod : TPoint);
var
  ind : integer;
  PBod : PPoint;
begin
  if NOT FindBod(BodySpojA, PPoint(Addr(Bod)), ind) then begin
    if NOT FindBod(BodyVol, PPoint(Addr(Bod)), ind) then begin
      New(PBod);
      PBod^ := Bod;
      BodyVol.Add(PBod);
      BodyVol.Sort(SortSourLexikograficky);
    end;
  end;
end;

Procedure DelejListBodu(AListB, AListX, AListY : TList);
var
  i : integer;
  Bod : TPoint;
begin
  for i := 0 to AListB.Count-1 do begin
    Bod := PPoint(AListB[i])^;
    IntPoiX := Bod.X;
    IntPoiY := Bod.Y;
    Try
      AListX.Add(PoiIntX);
      AListY.Add(PoiIntY);
    except
    end;
  end;
end;

Procedure UvolniListBodu(AListB : TList);
var
  i : integer;
begin
  for i := AListB.Count-1 downto 0 do
    Dispose(PPoint(AListB[i]));
  AListB.Free;
end;

Procedure VlozPocKonTrubky(AAC : TAmiClass; ABT : TPoint);
var
  i, CisChl : integer;
  AT : TAmiClass;
  nasel : boolean;
begin
  CisChl := CisloChlivku(ABT);
  Nasel := FALSE;
  if CisChl>=0 then begin
    for i := 0 to ChlivkyTrubek[CisChl].Count-1 do begin
      AT := ChlivkyTrubek[CisChl][i];
      if (AAC<>AT) AND
        ((AAC.Typ=AT.Typ) OR (AAC.Typ in [TypTrubka0, TypTrubkaOV]) OR
                              (AT.Typ in [TypTrubka0, TypTrubkaOV])) then begin
        if PorovnejBody(ABT, AT.Pocatek) OR
           PorovnejBody(ABT, AT.AbsKonec) then begin
          Nasel := TRUE;
          DelejSpoj(ABT);
          break;
        end;
      end;
    end;
  end;
  if NOT Nasel then begin
    DelejVol(ABT);
  end;
end;

var
  i, j, k, ind : integer;
  AC, AT, AL, AM, ARad1 : TAmiClass;
  BT : TPoint;
  CisChl : integer;

  TrubkykVentilu3 : array of TAmiClass;
  TypTrubekVentilu3 : integer;
Const
  CislaTypuTrubky : array[1..4] of integer =
    (TypTrubka1, TypTrubka2, TypTrubka3, TypTrubka4);
begin
  AVelSpoj := Round(VelikostSpoj*AKoef*JMetrMM);
  AVelVol := Round(VelikostVol*AKoef*JMetrMM);
  with Canvas do begin
    Brush.Style := bsSolid;
    Brush.Color := BarvaSpoj;
    Pen.Width := PenWidth2(AKoef);
    Pen.Mode := pmCopy;
    Pen.Style := psSolid;
    Pen.Color := BarvaNormAmi;
  end;

  if DelatSpojeTr then begin
    BodySpojA := TList.Create;
    BodySpoj := TList.Create;
    BodyVol := TList.Create;
    Try

      KonceTrubekSpojX.Clear;
      KonceTrubekSpojY.Clear;
      KonceTrubekVolX.Clear;
      KonceTrubekVolY.Clear;
      TrubkydoChlivku(AList, 0);
      For j := AList.Count-1 downto 0 do begin
        AC := AList.Items[j];
        if AC.JeRadKot then begin
          if AC is TAmiOTChladic1 then begin
            for i := 1 to 4 do begin
              BT := (AC as TAmiOTChladic1).DejBodTrubCislo(CislaTypuTrubky[i], ind);
              if ind>0 then
                DelejSpojA(BT);
            end;
          end else begin
            AL := AC.AmCl;
            AM := AC.AmCm;
            if (AL is TAmiTrubka) AND (AL.Typ<=TypTrubkaOV) then begin
              BT := AC.DejBodTrubTam(ind);
              if ind>0 then
                DelejSpojA(BT);
            end;
            if (AM is TAmiTrubka) AND (AM.Typ<=TypTrubkaOV) then begin
              BT := AC.DejBodTrubZpet(ind);
              if ind>0 then
                DelejSpojA(BT);
            end;
            if (AM is TAmiVenti2) AND (AC is TAmiRad1) then begin
              BT := AM.Pocatek;
              DelejSpojA(BT);
              BT := AM.AbsKonec;
              DelejSpojA(BT);
            end;
          end;
        end;

        if AC is TAmiVenti3 then begin
          TypTrubekVentilu3 := 0;
          SetLength(TrubkykVentilu3, AC.NPrip);
          Try
            for k := 1 to AC.NPrip do begin
              TrubkykVentilu3[k-1] := NIL;
              BT := AC.BodyPrip[k];
              CisChl := CisloChlivku(BT);
              if CisChl>=0 then begin
                for i := 0 to ChlivkyTrubek[CisChl].Count-1 do begin
                  AT := ChlivkyTrubek[CisChl][i];
                  if PorovnejBody(BT, AT.Pocatek) OR
                     PorovnejBody(BT, AT.AbsKonec) then begin
                    TrubkykVentilu3[k-1] := AT;
                    if TypTrubekVentilu3=0 then begin
                      if AT.Typ<>TypTrubkaOV then begin
                        TypTrubekVentilu3 := AT.Typ;
  //                  if TypTrubekVentilu3=TypTrubka0 then
  //                    if AT.Typ in [TypTrubka1, TypTrubka2] then
  //                      TypTrubekVentilu3 := AT.Typ;
                        break;
                      end;
                    end;
                  end;
                end;
              end;
            end;

            if TypTrubekVentilu3 in [TypTrubka1..TypTrubka6] then begin
              for k := 1 to AC.NPrip do begin
                BT := AC.BodyPrip[k];
                if Assigned(TrubkykVentilu3[k-1]) then begin
                  if (TrubkykVentilu3[k-1].Typ=TypTrubekVentilu3) OR
                     (TrubkykVentilu3[k-1].Typ=TypTrubkaOV) then
                    DelejSpojA(BT);
                end;
              end;
            end;
          finally
            SetLength(TrubkykVentilu3, 0);
          end;
        end;

        if (AC is TAmiTrubka) AND (AC.Typ<=TypTrubkaOV) then begin
          VlozPocKonTrubky(AC, AC.Pocatek);
          VlozPocKonTrubky(AC, AC.AbsKonec);
        end;
      end;        // for j
      DelejListBodu(BodySpojA, KonceTrubekSpojX, KonceTrubekSpojY);
      DelejListBodu(BodySpoj, KonceTrubekSpojX, KonceTrubekSpojY);
      DelejListBodu(BodyVol, KonceTrubekVolX, KonceTrubekVolY);
    finally
      UvolniListBodu(BodySpojA);
      UvolniListBodu(BodySpoj);
      UvolniListBodu(BodyVol);

      ZrusChlivkyTrubek;
    end;
    DelatSpojeTr := FALSE;
  end;

  case co of
    0 : begin
      For i := 0 to KonceTrubekSpojX.Count-1 do begin
        Try
          PoiIntX := KonceTrubekSpojX[i];
          PoiIntY := KonceTrubekSpojY[i];
          KresliSpoj(Point(IntPoiX, IntPoiY));
        except
        end;
      end;
    end;
    1 : begin
      with Canvas do begin
        Brush.Style := bsSolid;
        Brush.Color := BarvaNedotah1;
        Pen.Width := PenWidth2(AKoef);
        Pen.Mode := pmCopy;
        Pen.Style := psSolid;
        Pen.Color := BarvaNedotah2;
      end;
      For i := 0 to KonceTrubekVolX.Count-1 do begin
        Try
          PoiIntX := KonceTrubekVolX[i];
          PoiIntY := KonceTrubekVolY[i];
          KresliVol(Point(IntPoiX, IntPoiY));
        except
        end;
      end;
    end;
  end;
end;

Procedure KresliSpojeOld(AList : TAmiList; Canvas : TCanvas;
   AKoef : extended; PocSour : TPoint;
   KonceTrubekSpojX,KonceTrubekSpojY : TList;
   KonceTrubekVolX,KonceTrubekVolY : TList;
   var DelatSpojeTr : boolean;
   co : integer);
var
  AVelSpoj : integer;
  AVelVol : integer;
  PoiIntX : Pointer;
  IntPoiX : integer absolute PoiIntX;
  PoiIntY : Pointer;
  IntPoiY : integer absolute PoiIntY;


Procedure KresliSpoj(Bod : TPoint);
var
  ABod : TPoint;
begin
  DelejSpocAbsBodik(PocSour, Bod, AKoef, ABod);
  Canvas.Rectangle(ABod.X-AVelSpoj, ABod.Y-AVelSpoj,
                   ABod.X+AVelSpoj, ABod.Y+AVelSpoj);
end;

Procedure DelejSpoj(Bod : TPoint);
begin
  IntPoiX := Bod.X;
  IntPoiY := Bod.Y;
  Try
    KonceTrubekSpojX.Add(PoiIntX);
    KonceTrubekSpojY.Add(PoiIntY);
  except
  end;
end;

Procedure KresliVol(Bod : TPoint);
var
  ABod : TPoint;
begin
  DelejSpocAbsBodik(PocSour, Bod, AKoef, ABod);
  Canvas.Ellipse(ABod.X-AVelVol, ABod.Y-AVelVol,
                 ABod.X+AVelVol, ABod.Y+AVelVol);
end;

Procedure DelejVol(Bod : TPoint);
begin
  IntPoiX := Bod.X;
  IntPoiY := Bod.Y;
  Try
    KonceTrubekVolX.Add(PoiIntX);
    KonceTrubekVolY.Add(PoiIntY);
  except
  end;
end;

var
  i, j : integer;
  AC, ARad1 : TAmiClass;
begin
  AVelSpoj := Round(VelikostSpoj*AKoef*JMetrMM);
  AVelVol := Round(VelikostVol*AKoef*JMetrMM);
  with Canvas do begin
    Brush.Style := bsSolid;
    Brush.Color := BarvaSpoj;
    Pen.Width := PenWidth2(AKoef);
    Pen.Mode := pmCopy;
    Pen.Style := psSolid;
    Pen.Color := BarvaNormAmi;
  end;

  if DelatSpojeTr then begin
    KonceTrubekSpojX.Clear;
    KonceTrubekSpojY.Clear;
    KonceTrubekVolX.Clear;
    KonceTrubekVolY.Clear;
    For i := 0 to AList.Count-1 do begin
      AC := AList.Items[i];
      if AC is TAmiTrubka then begin
        with TAmiTrubka(AC) do begin
          if VolnyKonec(Pocatek) then DelejVol(Pocatek)
                                 else DelejSpoj(Pocatek);
          if VolnyKonec(AbsKonec) then DelejVol(AbsKonec)
                                  else DelejSpoj(AbsKonec);
        end;
      end;
      if AC is TAmiVenti2 then begin
        For j := 0 to AList.Count-1 do begin
          ARad1 := AList.Items[j];
          if (ARad1 is TAmiRad1) AND (ARad1.AmCl=AC)then begin

            DelejSpoj(AC.Pocatek);
            DelejSpoj(AC.AbsKonec);
          end;
        end;
      end;



    end;
    DelatSpojeTr := FALSE;
  end;

  case co of
    0 : begin
      For i := 0 to KonceTrubekSpojX.Count-1 do begin
        Try
          PoiIntX := KonceTrubekSpojX[i];
          PoiIntY := KonceTrubekSpojY[i];
          KresliSpoj(Point(IntPoiX, IntPoiY));
        except
        end;
      end;
    end;
    1 : begin
      with Canvas do begin
        Brush.Style := bsSolid;
        Brush.Color := BarvaNedotah1;
        Pen.Width := PenWidth2(AKoef);
        Pen.Mode := pmCopy;
        Pen.Style := psSolid;
        Pen.Color := BarvaNedotah2;
      end;
      For i := 0 to KonceTrubekVolX.Count-1 do begin
        Try
          PoiIntX := KonceTrubekVolX[i];
          PoiIntY := KonceTrubekVolY[i];
          KresliVol(Point(IntPoiX, IntPoiY));
        except
        end;
      end;
    end;
  end;
end;

Procedure KresliNespoje(AList : TAmiList; Canvas : TCanvas;
   AKoef : extended; PocSour : TPoint;
   NedotahyTrubekX, NedotahyTrubekY : TList;
   var DelatNedotahyTr : boolean);
var
  AVel : integer;
  PoiIntX : Pointer;
  IntPoiX : integer absolute PoiIntX;
  PoiIntY : Pointer;
  IntPoiY : integer absolute PoiIntY;


Procedure KresliNedotah(Bod : TPoint);
var
  ABod : TPoint;
begin
  DelejSpocAbsBodik(PocSour, Bod, AKoef, ABod);
  Canvas.Ellipse(ABod.X-AVel, ABod.Y-AVel, ABod.X+AVel, ABod.Y+AVel);
end;

Procedure DelejNedotah(Bod : TPoint);
begin
  IntPoiX := Bod.X;
  IntPoiY := Bod.Y;
  Try
    NedotahyTrubekX.Add(PoiIntX);
    NedotahyTrubekY.Add(PoiIntY);
  except
  end;
end;

var
  i, j : integer;
  AC, ARad1 : TAmiClass;
begin
//  AVel := Round(VelikostNedotah*AKoef*JMetrMM);
  with Canvas do begin
    Brush.Style := bsSolid;
    Brush.Color := BarvaNedotah1;
    Pen.Width := PenWidth2(AKoef);
    Pen.Mode := pmCopy;
    Pen.Style := psSolid;
    Pen.Color := BarvaNedotah2;
  end;

  if DelatNedotahyTr then begin
    NedotahyTrubekX.Clear;
    NedotahyTrubekY.Clear;
    For i := 0 to AList.Count-1 do begin
      AC := AList.Items[i];
      if AC is TAmiTrubka then begin
        with TAmiTrubka(AC) do begin
          if NOT VolnyKonec(Pocatek) then
            DelejNedotah(Pocatek);
          if NOT VolnyKonec(AbsKonec) then
            DelejNedotah(AbsKonec);
        end;
      end;
      if AC is TAmiVenti2 then begin
        For j := 0 to AList.Count-1 do begin
          ARad1 := AList.Items[j];
          if (ARad1 is TAmiRad1) AND (ARad1.AmCl=AC)then begin

            DelejNedotah(AC.Pocatek);
            DelejNedotah(AC.AbsKonec);
          end;
        end;
      end;



    end;
    DelatNedotahyTr := FALSE;
  end;

  For i := 0 to NedotahyTrubekX.Count-1 do begin
    Try
      PoiIntX := NedotahyTrubekX[i];
      PoiIntY := NedotahyTrubekY[i];
      KresliNedotah(Point(IntPoiX, IntPoiY));
    except
    end;
  end;
end;

Function TFrForm99.UlozitProjekt_99 : boolean;
var
  DlgType : TMsgDlgButtons;
  DlgString : String;
  i : integer;
begin
  with ATopChlad do begin
    if ZmenaProjektu then begin
      DlgType := [mbNo, mbCancel,mbYes];
      DlgString := SProjektZmenen;
    end else begin
      DlgType := [mbCancel,mbYes,mbNo];
      DlgString := SProjektNezmenen;
    end;

    if (AmiLispik.Count>0) OR ZmenaProjektu then begin
      Result := FALSE;
      if BPtatseUlozit OR ((AmiLispik.Count>0) AND ZmenaProjektu) then begin
        case DialogsCZ.MessageDlg(DlgString+' '+JmenoProjektu+'?', mtConfirmation, DlgType, 0) of
          mrYes : begin
            if ZadatJmeno then begin
              if NOT UlozList_99(AmiLispik,0) then
                exit;
            end else begin
              JakobyPageControlChange;
              UlozListdoSouboru(AmiLispik, JmenoProjektu,0);
            end;

{            for i := 0 to HistPosledniSouboru.Count-1 do
              if UpperCase(JmenoProjektu)=UpperCase(HistPosledniSouboru[i]) then begin
                HistPosledniSouboru.Delete(i);
                Break;
              end;

            HistPosledniSouboru.Insert(0, JmenoProjektu); }
            Form_Rb1.Ribbon1.AddRecentItem(JmenoProjektu);
//            ZrusHistSouboryPres;

            Result := TRUE;
          end;
          mrNo : Result := TRUE;

          mrCancel : exit;
        end;
      end else begin
        Result := TRUE;
      end;
    end else begin
      Result := TRUE;
    end;
  end;
end;

procedure TFrForm99.DelejUkazveVypoctu_99;
var
  AKlikA, ObVysl, BktAmiOzn : TAmiClass;
  APata : TAmiClass;
  i : integer;
  FormIPage : integer;
  TabSheet : TTabSheet;
  AControl : TControl;
begin
  with ATopChlad do begin
    if AFormP.Visible OR SkrytFormP OR (AktAmiOzn is TAmiKotel) then begin
      AKlikA := AktAmiOzn;
      BktAmiOzn := AktAmiOzn;
      if assigned(AKlikA) then begin
        if (AKlikA is TAmiPopis) OR
           ((AKlikA is TAmiAAA) AND
            ((AKlikA.Typ=TypZeslTrub) OR (AKlikA.Typ=TypSmerVody))) then begin
          if (AKlikA is TAmiPopis) AND (AKlikA.Typ>=TypPopisSchemaVent) then begin
            AKlikA := AKlikA.AnCm
          end else begin
            if AKlikA.AmCl<>NIL then
              AKlikA := AKlikA.Amcl;
          end;
        end;
      end;

      FormIPage := -1;

      ObVysl := NajdivAmiList_99(AmiVysledky, AKlikA);
      if Assigned(AktAmiSchemaF) then
        ObVysl := AktAmiSchemaF;
      if AFormI.Visible then begin
        with AFormI do begin
          if Assigned(ObVysl) then begin
            JakUkazatSipku := 0;
            if AFormI.PageControl1.ActivePage=AFormI.TabSheet5 then begin
              for i := 1 to StringGrid5.RowCount-1 do begin
                if (StringGrid5.Objects[0,i]=ObVysl) then begin
                  if StringGrid5.Row>0 then
                    StringGrid5.Cells[0,StringGrid5.Row] :=
                      '  '+IntToStr(StringGrid5.Row);
                  StringGrid5.Row := i;
    {              StringGrid2.Cells[0,StringGrid2.Row] :=
                    '=>'+IntToStr(StringGrid2.Row); }
                  FormIPage := 5;
                  break;
                end;
              end;
              FormIPage := 5;
            end else begin
              if AFormI.PageControl1.ActivePage=AFormI.TabSheet7 then begin
                for i := 1 to StringGrid7.RowCount-1 do begin
                  if (StringGrid7.Objects[0,i]=ObVysl) then begin
                    if StringGrid7.Row>0 then
                      StringGrid7.Cells[0,StringGrid7.Row] :=
                        '  '+IntToStr(StringGrid7.Row);
                    StringGrid7.Row := i;
      {              StringGrid2.Cells[0,StringGrid2.Row] :=
                      '=>'+IntToStr(StringGrid2.Row); }
                    FormIPage := 7;
                    break;
                  end;
                end;
                FormIPage := 7;
              end else begin
                if ObVysl is TAmiTrubka then begin
                  if AFormI.TabSheet1A.TabVisible then begin
                    for i := 1 to AFormI.StringGrid1A.RowCount-1 do begin
                      if StringGrid1A.Objects[0,i]=ObVysl then begin
                        if StringGrid1A.Row>0 then
                          StringGrid1A.Cells[0,StringGrid1A.Row] :=
                              '  '+IntToStr(StringGrid1A.Row);
                        StringGrid1A.Row := i;
        {                StringGrid1A.Cells[0,StringGrid1A.Row] :=
                            '=>'+IntToStr(StringGrid1A.Row); }

                        FormIPage := 11;
                        break;
                      end;
                    end;
                  end else begin
                    for i := 1 to AFormI.StringGrid1B.RowCount-1 do begin
                      if (StringGrid1B.Objects[0,i] is TAmiTrubka) AND
                           (TAmiTrubka(StringGrid1B.Objects[0,i]).FIntCisloUseku=
                            TAmiTrubka(ObVysl).FIntCisloUseku) then begin
                        if StringGrid1B.Row>0 then
                          StringGrid1B.Cells[0,StringGrid1B.Row] :=
                              '  '+IntToStr(StringGrid1B.Row);
                        StringGrid1B.Row := i;
        {                StringGrid1B.Cells[0,StringGrid1B.Row] :=
                            '=>'+IntToStr(StringGrid1B.Row); }

                        FormIPage := 12;
                        break;
                      end;
                    end;
                  end;
                end;

                if ((ObVysl is TAmiRad1) OR (ObVysl is TAmiRad2)) AND (TabSheetOT1.TabVisible) then begin
                  for i := 1 to StringGridOT1.RowCount-1 do begin
                    if (StringGridOT1.Objects[0,i]=ObVysl) then begin
                      if StringGridOT1.Row>0 then
                        StringGridOT1.Cells[0,StringGridOT1.Row] :=
                          '  '+IntToStr(StringGridOT1.Row);
                      StringGridOT1.Row := i;
        {              StringGridOT1.Cells[0,StringGridOT1.Row] :=
                        '=>'+IntToStr(StringGridOT1.Row); }
                      FormIPage := 2;
                      break;
                    end;
                  end;
                end;

                if ((ObVysl is TAmiRad1) OR (ObVysl is TAmiRad2)) AND (TabSheetOT2.TabVisible) then begin
                  for i := 1 to StringGridOT2.RowCount-1 do begin
                    if (StringGridOT2.Objects[0,i]=ObVysl) then begin
                      if StringGridOT2.Row>0 then
                        StringGridOT2.Cells[0,StringGridOT2.Row] :=
                          '  '+IntToStr(StringGridOT2.Row);
                      StringGridOT2.Row := i;
        {              StringGridOT2.Cells[0,StringGridOT2.Row] :=
                        '=>'+IntToStr(StringGridOT2.Row); }
                      FormIPage := 2;
                      break;
                    end;
                  end;
                end;

                if (ObVysl is TAmiSchema) OR (ObVysl is TAmiKotel) then begin
                  if ObVysl is TAmiSchema then APata := (ObVysl as TAmiSchema).NovaPata
                                          else APata := ObVysl;
                  for i := 1 to StringGrid1B.RowCount-1 do begin
                    if (StringGrid1B.Objects[0,i]=APata) then begin
                      if StringGrid1B.Row>0 then
                        StringGrid1B.Cells[0,StringGrid1B.Row] :=
                          '  '+IntToStr(StringGrid1B.Row);
                      StringGrid1B.Row := i;
                      FormIPage := 12;
                      break;
                    end;
                  end;
                end;

                if ObVysl is TAmiPokoj then begin
                  for i := 1 to StringGrid3.RowCount-1 do begin
                    if (StringGrid3.Objects[0,i]=ObVysl) OR
                       ((TAmiPokoj(StringGrid3.Objects[0,i]).Symbol=
                         TAmiPokoj(ObVysl).Symbol) AND
                        (TAmiPokoj(ObVysl).Symbol<>'')) then begin
                      if StringGrid3.Row>0 then
                        StringGrid3.Cells[0,StringGrid3.Row] :=
                          '  '+IntToStr(StringGrid3.Row);
                      StringGrid3.Row := i;
        {              StringGrid3.Cells[0,StringGrid3.Row] :=
                        '=>'+IntToStr(StringGrid3.Row); }
                      FormIPage := 3;
                      break;
                    end;
                  end;
                end;

                if ObVysl is TAmiVentil then begin
                  if AFormI.PageControl1.ActivePage=AFormI.TabSheet1B then begin
                    if (ObVysl.Typ=TypVentDPC) OR (ObVysl.Typ=TypVentFaDPC) then begin
                      for i := 1 to StringGrid1B.RowCount-1 do begin
                        if ((StringGrid1B.Objects[0,i] is TAmiKotel) AND
                            (TAmiClass(StringGrid1B.Objects[0,i]).Typ=TypModulPata) AND
                            (TAmiClass(StringGrid1B.Objects[0,i]).Vrstva=ObVysl.Vrstva)) then begin
                          if StringGrid1B.Row>0 then
                            StringGrid1B.Cells[0,StringGrid1B.Row] :=
                              '  '+IntToStr(StringGrid1B.Row);
                          StringGrid1B.Row := i;
                          FormIPage := 12;
                          break;
                        end;
                      end;


                    end else begin
                      for i := 1 to StringGrid1B.RowCount-1 do begin
                        if (StringGrid1B.Objects[0,i]=ObVysl) then begin
                          if StringGrid1B.Row>0 then
                            StringGrid1B.Cells[0,StringGrid1B.Row] :=
                              '  '+IntToStr(StringGrid1B.Row);
                          StringGrid1B.Row := i;
                          FormIPage := 12;
                          break;
                        end;
                      end;
                    end;
                  end;

                  if FormIPage<0 then begin
                    for i := 1 to StringGrid4.RowCount-1 do begin
                      if StringGrid4.Objects[0,i]=ObVysl then begin
                        if StringGrid4.Row>0 then
                          StringGrid4.Cells[0,StringGrid4.Row] :=
                            '  '+IntToStr(StringGrid4.Row);
                        StringGrid4.Row := i;
          {              StringGrid4.Cells[0,StringGrid4.Row] :=
                          '=>'+IntToStr(StringGrid4.Row); }
                        FormIPage := 4;
                        break;
                      end;
                    end;
                  end;
                end;
              end;
            end;
          end;

          JakUkazatSipku := 0;
          case FormIPage of
            -1 : begin
               JakUkazatSipku := -1;
               TabSheet := PageControl1.ActivePage;
               for i := 0 to TabSheet.ControlCount-1 do begin
                 AControl := TabSheet.Controls[i];
                 if AControl is TStringGrid then begin
                   AControl.Invalidate;
    {               (AControl as TStringGrid).Cells[0,StringGrid4.Row] := 0; }
                   break;
                 end;
               end;
            end;

            11 : PageControl1.ActivePage := TabSheet1A;
            12 : PageControl1.ActivePage := TabSheet1B;
            2 : begin
              if TabSheetOT1.TabVisible then
                PageControl1.ActivePage := TabSheetOT1;
              if TabSheetOT2.TabVisible then
                PageControl1.ActivePage := TabSheetOT2;
            end;
            3 : PageControl1.ActivePage := TabSheet3;
            4 : PageControl1.ActivePage := TabSheet4;
            5 : PageControl1.ActivePage := TabSheet5;
            7 : PageControl1.ActivePage := TabSheet7;
          end;
        end;
      end;    // if AFormI.Visible

      if Assigned(BktAmiOzn) AND (BktAmiOzn<>AktAmiOzn) then begin
        DelejOznAmi_99(BktAmiOzn);
      end;
    end;
    if AFormP.Visible then begin
      if (AFormP.HostDockSite is TPanel) then begin
        if AFormI.Visible then begin
          if NOT (AFormI.HostDockSite is TPanel) then begin
            if AFormI.HostDockSite is TConjoinDockHost then begin
              AFormI.HostDockSite.BringToFront;
            end else begin
              AFormI.BringToFront;
            end;
          end;
        end;
      end else begin
        if AFormP.HostDockSite is TConjoinDockHost then begin
          if NOT AFormP.HostDockSite.Visible then begin
            AFormP.Visible := TRUE;
            AFormP.HostDockSite.Visible := TRUE;
          end;
          AFormP.Show;
          AFormP.HostDockSite.BringToFront;
          AFormP.BringToFront;
        end else begin
          if AFormI.Visible then begin
            if NOT (AFormI.HostDockSite is TPanel) then
              AFormI.BringToFront;
          end;
          AFormP.BringToFront;
        end;
      end;
    end else begin
      if AFormI.Visible then begin
        if AFormI.HostDockSite is TConjoinDockHost then begin
          if NOT AFormI.HostDockSite.Visible then begin
            AFormI.Visible := TRUE;
            AFormI.HostDockSite.Visible := TRUE;
          end;
          AFormI.Show;
          AFormI.HostDockSite.BringToFront;
          AFormI.BringToFront;
        end else begin
          if AFormI.Visible then begin
            if NOT (AFormI.HostDockSite is TPanel) then
              AFormI.BringToFront;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrForm99.DelejOpravVztahy_99;
begin
  ATopChlad.DelejOpravVztahy;
end;

Procedure TFrForm99.DelejOznzListu_99(AList : TAmiList);
begin
  if AList<>NIL then
    if AList.Count=1 then
      DelejOznAmi_99(AList.Items[0]);
end;

Procedure TFrForm99.TlacitkaPriJednotrubce_99;
begin
  with ATopChlad do
    if AForm_A is TFormA then
      TFormA(AForm_A).TlacitkaPriJednotrubce(NastaveniTopChlad.BCooling OR
       ((NOT NastaveniTopChlad.BCooling) AND (NOT BJeOchlazovani)),
        BJeOchlazovani AND (NOT NastaveniTopChlad.BCooling));
end;

Procedure TFrForm99.TlacitkaSchemat_99;
begin
  with ATopChlad do
    if AForm_A is TFormA then
      TFormA(AForm_A).TlacitkaSchemat(NastaveniTopChlad.BCooling);
end;

procedure TFrForm99.ZobrazitKontrolu1Click_99;
begin
  with ATopChlad do begin
    BZobrazitsKontrolou := NOT BZobrazitsKontrolou;
    ZobrazitKontrolu_99(BZobrazitsKontrolou, TRUE);
    DelejInvalidu_99;
  end;
end;

procedure TFrForm99.Cooling_x_Heating_99(ACooling : boolean);
var
  i : integer;
begin
  ATopChlad.NastaveniTopChlad.BCooling := ACooling;
  BIMICool := ACooling;   // v UnPok99B
  if BIMICool then begin
    ATopChlad.NastaveniTopChlad.Mod_Chlazeni_x_Topeni := 1;

    with TFormP(AFormP).AdvStringGridPokoj do begin
      Cells[4,0] := StrGr5BP5+' '+SWatty;
      Cells[5,0] := StrGr5BP4+' '+SWatty;
    end;
  end else begin
    ATopChlad.NastaveniTopChlad.Mod_Chlazeni_x_Topeni := 0;
    with TFormP(AFormP).AdvStringGridPokoj do begin
      Cells[4,0] := StrGr5BP4+' '+SWatty;
      Cells[5,0] := StrGr5BP5+' '+SWatty;
    end;
  end;
  BMod_Chlazeni_x_Topeni := ATopChlad.NastaveniTopChlad.Mod_Chlazeni_x_Topeni; // v UnPok99B
  TlacitkaPriJednotrubce_99;
  TlacitkaSchemat_99;

  if AForm_A is TFormA then
    TFormA(AForm_A).Cooling_x_Heating(ACooling);
  if AForm_A is TForm_RB1 then
    TForm_Rb1(AForm_A).Cooling_x_Heating(ACooling);
end;

procedure TFrForm99.APrevzitDatazTEZClick_99;
var
  i : integer;
  ATeplota, AQ : integer;
  ASymbol, APopis : String;
  AC : TAmiClass;
  Zmena : boolean;
begin
  if BJsouTepelneZtraty then begin
    Zmena := FALSE;
    with ATopChlad do begin
      VybList.Clear;
      DelejOznAmi_99(NIL);
      DelejTabulky_99;
  {$IFDEF DATABASE_PARADOX}
      with Datamodule1.TableTepZtr do begin
  {$ENDIF}

  {$IFDEF DATABASE_ACCESS}
      with Datamodule1.DTableTepZtr do begin
  {$ENDIF}
        Try
          Try
            ReadOnly := TRUE;
            Active := TRUE;
            DelejUmozniUNDO_99;
//            DelejUmozniUNDQ_99(histZmen, histParOblouk, AmiClass, NIL);          //?????
            for i := 0 to AmiLispik.Count-1 do begin
              AC := AmiLispik[i];
              if AC is TAmiPokoj then
                with AC as TAmiPokoj do begin
                  ASymbol := Symbol;
                  if ASymbol<>'' then begin
                    if Locate(StrMistnost, ASymbol, [loCaseInsensitive]) then begin
                      ATeplota := Round(FielDByName(StrTeplotaMist).Value);
                      if (ATeplota>=-25) AND (ATeplota<=50) then begin
                        Zmena := Zmena OR (TeplotaH<>ATeplota);
                        MaVymazatVypocet := MaVymazatVypocet OR (TeplotaH<>ATeplota);
                        TeplotaH := ATeplota;
                      end;

                      AQ := Round(FielDByName(StrQTep).Value);
                      if AQ>=0 then begin
                        Zmena := Zmena OR (QH<>AQ);
                        MaVymazatVypocet := MaVymazatVypocet OR (QH<>AQ);
                        QH := AQ;
                      end;

                      APopis := FielDByName(StrPopisMist).AsString;
                      Zmena := Zmena OR (Popis<>APopis);
                      Popis := APopis;
                    end;
                  end;
                end;    // with
            end;        // for i

            if MaVymazatVypocet then
              DelejVymazVypocet_99;
            if Zmena then
              ZmenaProjektu := TRUE;
          except
          end;
        finally
          Active := FALSE;
        end;
      end;

      DelejInvalidu_99;
    end;
  end;
end;

procedure TFrForm99.UmozniSchovatListy_99;
begin
  if AForm_A is TFormA then
    TFormA(AForm_A).UmozniSchovatListy;
end;

procedure TFrForm99.Vypocet1Click_99;
var
  Dale : boolean;
begin
  Dale := TRUE;
  Case HesCos of
    -1 : if ATopChlad.NastaveniTopChlad.BCoolingProj then begin
      Dale := FALSE;
      DialogsCZ.ShowMessage(SProjektChlazeni);
    end;
    1 : if NOT ATopChlad.NastaveniTopChlad.BCoolingProj then begin
      Dale := FALSE;
      DialogsCZ.ShowMessage(SProjektTopeni);
    end;
  end;

  if Dale then begin
    with ATopChlad.NastaveniTopChlad do begin
      if BCooling then begin
        KoncGlykolu := KoncGlykolu_procC*0.01;
        CisloMedia := TypMediaC;
      end else begin
        KoncGlykolu := KoncGlykolu_procH*0.01;
        CisloMedia := TypMediaH;
      end;
      if ATopChlad.DelejVypocet>=0 then
        SkrytFormP := FALSE;   // umozni, aby okno zadavani bylo navrchu
    end;
  end;
end;

procedure TFrForm99.DoplnitTepelneVykony1Click_99;

var
  ListPokoju : TAmiList;

  Procedure PridejdoOzn(AmiClass : TAmiClass);
  begin
    if AmiClass<>NIL then
        if ListPokoju.IndexOf(AmiClass)<0 then
          ListPokoju.Add(AmiClass);
  end;

var
  i,j,N,APr,NPr{,QPok} : integer;
  AC, AP, AR : TAmiClass;
  ListTeles  : TAmiList;
  Q : extended;
begin
  with ATopChlad do begin
    KontrList.Clear;
    ProtokolStrings.Clear;

    ListPokoju := TAmiList.Create;
    ListTeles  := TAmiList.Create;
    DelejVyberOzn4;
    for i := 0 to OznList.Count-1 do begin
      AC := OznList.Items[i];
      if AC is TAmiPokoj then
        PridejdoOzn(AC);
    end;
    if ListPokoju.Count=0 then begin
      for i := 0 to AmiLispik.Count-1 do begin
        AC := AmiLispik.Items[i];
        if AC is TAmiPokoj then
          PridejdoOzn(AC);
      end;
    end;

    for i := 0 to ListPokoju.Count-1 do begin
      AP := ListPokoju.Items[i];
      ListTeles.Clear;

      for j := 0 to AmiLispik.Count-1 do begin
        AC := AmiLispik.Items[j];
        if ((AC is TAmiRad1){ OR (AC is TAmiRad2)}) AND (AC.MujPokoj=AP) then
          ListTeles.Add(AC);
      end;

      if ListTeles.Count>0 then begin
        if NastaveniTopChlad.BCooling then Q := TAmiPokoj(AP).QC
                                      else Q := TAmiPokoj(AP).QH;
        if Q<=0 then begin
          KontrList.Add(AP);
          ProtokolStrings.AddObject(
               TAmiPokoj(AP).Symbol+' '+SNeniQPokoje,AP);
        end else begin
          APr := Round(100/ListTeles.Count);
          for j := 0 to ListTeles.Count-1 do begin
            AR := ListTeles.Items[j];
            if j=ListTeles.Count-1 then TAmiRad1(AR).QPr := 100-APr*j
                                   else TAmiRad1(AR).QPr := APr;
          end;
        end;
      end;
    end;

    ListPokoju.Free;
    ListTeles.Free;

    if KontrList.Count>0 then begin
      ToolWindowFormF.Caption := SMistnostibezQ;
      PripravFormF_99;
    end else begin
      DelejTabulky_99;
      DelejInvalidu_99;
    end;
  end;
end;

procedure TFrForm99.Kontrolamodul1Click_99;
begin
  with ATopChlad do
    BKontrolaModulu := NOT BKontrolaModulu;
//  KontrolaModul1.Checked := BKontrolaModulu;
  DelejInvalidu_99;
end;

procedure TFrForm99.KontrolaMistnostiClick_99;
begin
  with FormTZ2 do begin
    AList := ATopChlad.AmiLispik;
//    AForm := Self;
    ShowModal;
  end;
end;

procedure TFrForm99.NedotahyPotrubi1Click_99(AUkazatVolneKoncePotrubi : boolean);
begin
  ATopChlad.BUkazatVolneKoncePotrubi := AUkazatVolneKoncePotrubi;
  DelejInvalidu_99;
end;

procedure TFrForm99.GenerovatSmerVody1Click_99(AGenerovatSmerVody1 : boolean);
begin
  ATopChlad.BGenerovatSmerVody1 := AGenerovatSmerVody1;
  ATopChlad.ZmenaProjektu := TRUE;
end;

procedure TFrForm99.GenerovatZeslTrub1Click_99(AGenerovatZeslTrub1 : boolean);
begin
  ATopChlad.BGenerovatZeslTrub1 := AGenerovatZeslTrub1;
  ATopChlad.ZmenaProjektu := TRUE;
end;

procedure TFrForm99.BottomDockPanelDockDrop(Sender: TObject;
  Source: TDragDockObject; X, Y: Integer);
var
  AStatusBarVisible : boolean;
begin
  //OnDockDrop gets called AFTER the client has actually docked,
  //so we check for DockClientCount = 1 before making the dock panel visible.
  if (Sender as TPanel).DockClientCount = 1 then
    ShowDockPanel_99(Sender as TPanel, True, nil);
  (Sender as TPanel).DockManager.ResetBounds(True);
  //Make DockManager repaints it's clients.
//  AStatusBarVisible := StatusBar.Visible;
//  StatusBar.Top := ClientHeight;
  if Statusbar1.Visible then begin
    StatusBar1.Height := 17;
    StatusBar1.Top := Height-StatusBar1.Height;
  end;
  HSplitter.Top := BottomDockPanel.Top;
//  BottomDock97.Top := HSplitter.Top-BottomDock97.Height;
  SpocitejPosScroll_99;
//  StatusBar.Visible := AStatusBarVisible;
end;

procedure TFrForm99.BottomDockPanelDockOver(Sender: TObject;
  Source: TDragDockObject; X, Y: Integer; State: TDragState;
  var Accept: Boolean);
var
  ARect: TRect;
  AHeight : Integer;
begin
//  Accept := (Source.Control is TFormP) OR (Source.Control is TFormI){ OR (Source.Control is TFormF)};
  Accept := (Source.Control = AFormP) OR (Source.Control = AFormI){ OR (Source.Control is TFormF)};
  if Accept then begin
    //Modify the DockRect to preview dock area.
    AHeight := BottomDockPanelHeight;
    if (AHeight<=0) OR (AHeight>3*ClientHeight div 4) then
      AHeight := ClientHeight div 4;

    ARect.TopLeft := BottomDockPanel.ClientToScreen(Point(0, -AHeight));
    ARect.BottomRight := BottomDockPanel.ClientToScreen(
      Point(BottomDockPanel.Width, BottomDockPanel.Height));
    Source.DockRect := ARect;
  end;
end;

procedure TFrForm99.BottomDockPanelGetSiteInfo(Sender: TObject;
  DockClient: TControl; var InfluenceRect: TRect; MousePos: TPoint;
  var CanDock: Boolean);
begin
  //if CanDock is true, the panel will not automatically draw the preview rect.
//  CanDock := (DockClient is TFormP) OR (DockClient is TFormI){ OR (DockClient is TFormF)};
  CanDock := (DockClient=AFormP) OR (DockClient=AFormI){ OR (DockClient is TFormF)};
end;

procedure TFrForm99.BottomDockPanelUnDock(Sender: TObject; Client: TControl;
  NewTarget: TWinControl; var Allow: Boolean);
begin
  //OnUnDock gets called BEFORE the client is undocked, in order to optionally
  //disallow the undock. DockClientCount is never 0 when called from this event.
  if (Sender as TPanel).DockClientCount = 1 then
    ShowDockPanel_99(Sender as TPanel, False, nil);
end;

procedure TFrForm99.BStatusbar1Click(Sender: TObject);
begin
  BStatusbar1.Checked := NOT BStatusbar1.Checked;
  StatusBar1.Visible := BStatusbar1.Checked;
  StatusBarVisible := StatusBar1.Visible;
end;

procedure TFrForm99.TopDock97Resize(Sender: TObject);
begin
//  SpocitejPosScroll_99;
  Meritko(PaintBoxMeritkoX.Canvas, PaintBoxMeritkoY.Canvas, KoefZvetseni, PocAmi, Width, Height);
end;

procedure TFrForm99.KopirovatZrcadloveVodorovnaOsa_99;
var
  i, j, D : integer;
  AC, AA : TAmiClass;
  BP, BK, AD : TPoint;
  Alf : integer;
  ANBoduUch : integer;
begin
  DelejVlozdoClipboardu_99;
// vyhodi z popisu mistnosti cisla
  for i := JakobyClipBoard.Count-1 downto 0 do begin
    AC := JakobyClipBoard.Items[i];
    BP := Point(AC.Pocatek.X, -AC.Pocatek.Y);
    BK := Point(AC.AbsKonec.X, -AC.AbsKonec.Y);
//    if AC is TAmiPopis then
    AC.Pocatek := BP;
    AC.AbsKonec := BK;

    if (AC is TAmiKotel) OR (AC is TAmiRad1) OR (AC is TAmiRad2) OR
       (AC is TAmiVenti2) OR (AC is TAmiVenti3)  OR (AC is TAmiPokoj) OR
       (AC is TAmiStrop1) then begin
      AC.Pocatek := Point(BP.X, BK.Y);
      AC.AbsKonec := Point(BK.X, BP.Y);
    end;

    if AC is TAmiSchema then begin
      AC.Pocatek := Point(BP.X, BK.Y);
      case AC.Orientace of
        0 : AC.Orientace := 1;
        1 : AC.Orientace := 0;
        2 : AC.Orientace := 3;
        3 : AC.Orientace := 2;
        4 : AC.Orientace := 5;
        5 : AC.Orientace := 4;
        6 : AC.Orientace := 7;
        7 : AC.Orientace := 6;
      end;
    end;

    if (AC is TAmiPopis) OR (AC is TAmiTextik) then begin
      with AC do begin
        BP := HL;
        BK := DP;
        HL := Point(HL.X, Max(-BP.Y, -BK.Y));
        DP := Point(DP.X, Min(-BP.Y, -BK.Y));
      end;
      if AC is TAmiPopis then
        with AC As TAmiPopis do
          Nenakreslil;
      if AC is TAmiTextik then
        with AC As TAmiTextik do
          Nenakreslil;
    end;

    if (AC is TAmiOblouk) AND (AC.Typ=TypAmiOblouk2) then begin
      with AC as TAmiOblouk do begin
        Alf := Alfa1;
        Alfa1 := 360000-Alfa2;
        Alfa2 := 360000-Alf;
      end;
    end;

    if (AC is TAmiVentil) AND (Length(TAmiVentil(AC).Kapilara)>0) then begin
      for j := 0 to High(TAmiVentil(AC).Kapilara) do // AC.NBoduUch do
        TAmiVentil(AC).Kapilara[j].Y := -TAmiVentil(AC).Kapilara[j].Y;
      for j := Length(TAmiVentil(AC).Kapilara)+1 to 8 do // AC.NBoduUch do
        AC.BodyUch[j] := Point(AC.BodyUch[j].X, -AC.BodyUch[j].Y);
    end else begin
      if NOT (AC is TAmiPneuH) then
        for j := 1 to 8 do // AC.NBoduUch do
          AC.BodyUch[j] := Point(AC.BodyUch[j].X, -AC.BodyUch[j].Y);
    end;
    Case AC.Typ of
      TypKotel+0, TypKotel+2, TypKotel+3, TypKotel+7, TypKotel+8,
           TypKotel+10, TypKotel+12, TypKotel+13, TypVenti2..TypVenti2+9 : begin
        AC.AmCl := NIL;
        AC.AmCm := NIL;
      end;

      TypObecnaPataH, TypObecnaPataC : begin
        Case AC.Orientace of
          1, 3 : begin
            AC.AmCl := NIL;
            AC.AmCm := NIL;
          end;
        end;
      end;
      {      TypVenti1..TypVenti1+20 : begin
        if Assigned(AC.AmCl) AND (AC.AmCl.RelKonec.X=0) then
          AC.Orientace := 1-AC.Orientace;
      end; }

//      TypVenti3, TypVenti3+1, TypVenti3+2 : AC.Orientace := 1-AC.Orientace;
      TypPopisTru1..TypPopisTru5 : if AC is TAmiPopis then begin
        with AC as TAmiPopis do begin
//          AbsDrzatko := Point(-AbsDrzatko.X, AbsDrzatko.Y);
          RelDrzatko := Point(RelDrzatko.X, -RelDrzatko.Y);
          case Orientace of
            1 : Orientace := 3;
            3 : Orientace := 1;
          end;
        end;
      end;

      TypPopisRad1 : begin
//        JakobyClipboard.Delete(i);
//        AC.Free;
      end;


      TypAmiText1..TypAmiText3 : if AC is TAmiTextik then begin
        with AC as TAmiTextik do begin
//          AbsDrzatko := Point(-AbsDrzatko.X, AbsDrzatko.Y);
          RelDrzatko := Point(RelDrzatko.X, -RelDrzatko.Y);
          case Orientace of
            1 : Orientace := 3;
            3 : Orientace := 1;
          end;
        end;
      end;

    end;

    if AC is TAmiPneuH then begin
      if AC.Typ=TypPneuHInterVesselDD then begin
        case AC.Orientace of
          0 : AC.Orientace := 1;
          1 : AC.Orientace := 0;
          2 : AC.Orientace := 3;
          3 : AC.Orientace := 2;
        end;
      end;
      AC.Kresli(NIL, KoefZvetseni, 4, PocAmi);   //   AC.DelejUchBody(5);
      for j := 1 to High(TAmiPneuH(AC).Kapilarb1) do // AC.NBoduUch do
        TAmiPneuH(AC).Kapilarb1[j].y := -TAmiPneuH(AC).Kapilarb1[j].y;
      for j := 1 to High(TAmiPneuH(AC).Kapilarb2) do // AC.NBoduUch do
        TAmiPneuH(AC).Kapilarb2[j].y := -TAmiPneuH(AC).Kapilarb2[j].y;
    end;
  end;

  for i := JakobyClipBoard.Count-1 downto 0 do begin
    AC := JakobyClipBoard.Items[i];
    if AC.JeRadseSpodnimPripojeni OR AC.JeRadseStrednimPripojeni OR
       AC.JeRadseSpodPravPripojeni OR AC.JeRadseSpodLevPripojeni OR
       AC.JeRadKoupelnovy then begin
      AA := AC.AmCl;
      if AA is TAmiTrubka then begin
        AC.AmCl := NIL;
        AC.AmCm := NIL;
      end;
      if (AA is TAmiVenti2) AND (JakobyClipBoard.IndexOf(AA)>=0) then begin
        AA.Pocatek := Point(AA.Pocatek.X, AC.Pocatek.Y);
      end;
    end;

    Case AC.Typ of
      TypPopisRad1 : begin
        AA := AC.AmCl;
        if Assigned(AA) then begin
          AA.SpocitejORect;
          D := AC.HL.Y - AC.DP.Y;
          AC.Pocatek := Point(AC.Pocatek.X, AA.HL.Y + 100);
          AC.DP := Point(AC.DP.X, AC.Pocatek.Y-50);
          AC.HL := Point(AC.HL.X, AC.DP.Y + D);
        end;
      end;

      TypPopisPok1 : begin
        AA := AC.AmCl;
        if Assigned(AA) then begin
          AA.SpocitejORect;
          D := AC.HL.Y - AC.DP.Y;
          AC.Pocatek := Point(AC.Pocatek.X, AA.HL.Y - 300);
          AC.DP := Point(AC.DP.X, AC.Pocatek.Y-50);
          AC.HL := Point(AC.HL.X, AC.DP.Y + D);
        end;
      end;
    end;
  end;
end;

procedure TFrForm99.Kopirovat2Click(Sender: TObject);
begin
  DelejVlozdoClipboardu_99;
end;

procedure TFrForm99.KopirovatZrcadloveSvislaOsa_99;
var
  i, j : integer;
  AC, AA, AT1, AT2 : TAmiClass;
  BP, BK, AD : TPoint;
  Alf : integer;
  KoefSirka : integer;
  ANBoduUch : integer;
begin
  DelejVlozdoClipboardu_99;

  for i := JakobyClipBoard.Count-1 downto 0 do begin
    AC := JakobyClipBoard.Items[i];
    if AC.JeRadseSpodPravPripojeni OR AC.JeRadseSpodLevPripojeni then begin
      AC := PseudoKoncObjekt(AC);
      AT1 := AC.AmCl;
      AT2 := AC.AmCm;
      if Assigned(AT1) then begin
        BP := AC.DejBodTrubTam(j);
        if (j>0) AND PorovnejBody(AT1.Pocatek, BP) then
          AT1.VymenPocatekzaKonec;
      end;
      if Assigned(AT2) then begin
        BP := AC.DejBodTrubZpet(j);
        if (j>0) AND PorovnejBody(AT2.Pocatek, BP) then
          AT2.VymenPocatekzaKonec;
      end;
    end;
  end;

  { vyhodi z popisu mistnosti cisla }
  for i := JakobyClipBoard.Count-1 downto 0 do begin
    AC := JakobyClipBoard.Items[i];
    BP := Point(-AC.Pocatek.X, AC.Pocatek.Y);
    BK := Point(-AC.AbsKonec.X, AC.AbsKonec.Y);
//    if AC is TAmiPopis then
    AC.Pocatek := BP;
    AC.AbsKonec := BK;

    if (AC is TAmiKotel) OR (AC is TAmiRad1) OR (AC is TAmiRad2) OR
       (AC is TAmiVenti2) OR (AC is TAmiVenti3)  OR (AC is TAmiPokoj) OR
       (AC is TAmiStrop1) then begin
      AC.Pocatek := Point(BK.X, BP.Y);
      AC.AbsKonec := Point(BP.X, BK.Y);
    end;

    if AC is TAmiSchema then begin
      AC.Pocatek := Point(BK.X, BP.Y);
      case AC.Orientace of
        0 : AC.Orientace := 2;
        1 : AC.Orientace := 3;
        2 : AC.Orientace := 0;
        3 : AC.Orientace := 1;
        4 : AC.Orientace := 6;
        5 : AC.Orientace := 7;
        6 : AC.Orientace := 4;
        7 : AC.Orientace := 5;
      end;
    end;

    if (AC is TAmiPopis) OR (AC is TAmiTextik) then begin
      with AC do begin
        BP := HL;
        BK := DP;
        HL := Point(Min(-BP.X, -BK.X), HL.Y);
        DP := Point(Max(-BP.X, -BK.X), DP.Y);
      end;
      if AC is TAmiPopis then
        with AC As TAmiPopis do
          Nenakreslil;
      if AC is TAmiTextik then
        with AC As TAmiTextik do
          Nenakreslil;
    end;

    if (AC is TAmiOblouk) AND (AC.Typ=TypAmiOblouk2) then begin
      with AC as TAmiOblouk do begin
        Alf := Alfa1;
        Alfa1 := 180000-Alfa2;
        Alfa2 := 180000-Alf;
      end;
    end;


    if (AC is TAmiVentil) AND (Length(TAmiVentil(AC).Kapilara)>0) then begin
      for j := 0 to High(TAmiVentil(AC).Kapilara) do // AC.NBoduUch do
        TAmiVentil(AC).Kapilara[j].x := -TAmiVentil(AC).Kapilara[j].x;
      for j := Length(TAmiVentil(AC).Kapilara)+1 to 8 do // AC.NBoduUch do
        AC.BodyUch[j] := Point(-AC.BodyUch[j].X, AC.BodyUch[j].Y);
    end else begin
      if NOT (AC is TAmiPneuH) then
        for j := 1 to 8 do // AC.NBoduUch do
          AC.BodyUch[j] := Point(-AC.BodyUch[j].X, AC.BodyUch[j].Y);
    end;
    Case AC.Typ of
      TypVenti1+21, TypVenti1+23 : AC.ZmenTyp(AC.Typ+1);
      TypVenti1+22, TypVenti1+24 : AC.ZmenTyp(AC.Typ-1);

      TypObecnaPataH, TypObecnaPataC : begin
        Case AC.Orientace of
          0 : AC.Orientace := 2;
          1 : AC.Orientace := 3;
          2 : AC.Orientace := 0;
          3 : AC.Orientace := 1;
        end;
        AC.ZmenTyp(AC.Typ);
      end;

      TypObecnaPataH+1 : AC.ZmenTyp(TypObecnaPataH);
      TypObecnaPataH+2 : begin
        AC.Orientace := 3;
        AC.ZmenTyp(TypObecnaPataH);
      end;
      TypObecnaPataH+3 : begin
        AC.Orientace := 1;
        AC.ZmenTyp(TypObecnaPataH);
      end;
//      TypKotel+4, TypKotel+6, TypVenti1+21, TypVenti1+23 : AC.ZmenTyp(AC.Typ+1);
//      TypKotel+5, TypKotel+7, TypVenti1+22, TypVenti1+24 : AC.ZmenTyp(AC.Typ-1);

      TypVenti1..TypVenti1+20 : begin
        if Assigned(AC.AmCl) AND (AC.AmCl.RelKonec.X=0) then
          AC.Orientace := 1-AC.Orientace;
      end;

      TypVenti2..TypVenti2+8 : begin
        if AC.Orientace>=0 then AC.Orientace := -1
                           else AC.Orientace := 1;
      end;


      TypVenti3, TypVenti3+1, TypVenti3+2 : AC.Orientace := 1-AC.Orientace;
      TypPopisTru1..TypPopisTru5 : if AC is TAmiPopis then begin
        with AC as TAmiPopis do begin
//          AbsDrzatko := Point(-AbsDrzatko.X, AbsDrzatko.Y);
          RelDrzatko := Point(-RelDrzatko.X, RelDrzatko.Y);
          case Orientace of
            0 : Orientace := 2;
            2 : Orientace := 0;
          end;
        end;
      end;

{      TypPopisRad1 : begin
        with AC do begin
//          Pocatek := Point(BK.X, BP.Y);
//          AbsKonec := Point(BP.X, BK.Y);
          BP := HL; AD := HL;
          BK := DP;
          HL := Point(Min(-BP.X, -BK.X), HL.Y);
          DP := Point(Max(-BP.X, -BK.X), DP.Y);
        end;
        //        AC.AbsObd(KoefZvetseni, PocAmi);
      end; }


      TypAmiText1..TypAmiText3 : if AC is TAmiTextik then begin
        with AC as TAmiTextik do begin
//          AbsDrzatko := Point(-AbsDrzatko.X, AbsDrzatko.Y);
          RelDrzatko := Point(-RelDrzatko.X, RelDrzatko.Y);
          case Orientace of
            0 : Orientace := 2;
            2 : Orientace := 0;
          end;
        end;
      end;

    end;

    if AC is TAmiPneuH then begin
      case AC.Orientace of
        0 : AC.Orientace := 2;
        1 : AC.Orientace := 3;
        2 : AC.Orientace := 0;
        3 : AC.Orientace := 1;
      end;
      AC.Kresli(NIL, KoefZvetseni, 4, PocAmi);   //   AC.DelejUchBody(5);
      for j := 1 to High(TAmiPneuH(AC).Kapilarb1) do // AC.NBoduUch do
        TAmiPneuH(AC).Kapilarb1[j].x := -TAmiPneuH(AC).Kapilarb1[j].x;
      for j := 1 to High(TAmiPneuH(AC).Kapilarb2) do // AC.NBoduUch do
        TAmiPneuH(AC).Kapilarb2[j].x := -TAmiPneuH(AC).Kapilarb2[j].x;
    end;

  end;

  for i := JakobyClipBoard.Count-1 downto 0 do begin
    AC := JakobyClipBoard.Items[i];
    if AC.JeRadseSpodPravPripojeni OR AC.JeRadseSpodLevPripojeni then begin
      AA := AC.AmCl;
      if AA is TAmiTrubka then begin
        AT1 := AA;
        AT2 := AC.AmCm;
        if Assigned(AT1) AND (JakobyClipBoard.IndexOf(AT1)>=0) then begin
          if AT1.AbsKonec.X=AT1.Pocatek.X then
            AT1.Pocatek := Point(AC.BodyPrip[1].X, AT1.Pocatek.y);
          AT1.AbsKonec := AC.BodyPrip[1];
        end;
        if Assigned(AT2) AND (JakobyClipBoard.IndexOf(AT2)>=0) then begin
          if AT2.AbsKonec.X=AT2.Pocatek.X then
            AT2.Pocatek := Point(AC.BodyPrip[2].X, AT2.Pocatek.y);
          AT2.AbsKonec := AC.BodyPrip[2];
        end;
      end;
      if (AA is TAmiVenti2) AND (JakobyClipBoard.IndexOf(AA)>=0) then begin
        AA.Pocatek := AC.BodyPrip[1];
        AT1 := AA.AmCl;
        AT2 := AA.AmCm;
        if Assigned(AT1) AND (JakobyClipBoard.IndexOf(AT1)>=0) then begin
          if AT1.AbsKonec.X=AT1.Pocatek.X then
            AT1.Pocatek := Point(AA.BodyPrip[1].X, AT1.Pocatek.y);
          AT1.AbsKonec := AA.BodyPrip[1];
        end;
        if Assigned(AT2) AND (JakobyClipBoard.IndexOf(AT2)>=0) then begin
          if AT2.AbsKonec.X=AT2.Pocatek.X then
            AT2.Pocatek := Point(AA.BodyPrip[2].X, AT2.Pocatek.y);
          AT2.AbsKonec := AA.BodyPrip[2];
        end;
      end;
    end;

  end;
end;

Function TFrForm99.NajdivAmiList_99(AList : TAmiList; AC : TAmiClass) : TAmiClass;
var
  i, AVrstva, BVrstva : integer;
  AX, AY, ASch : TAmiClass;

begin
  Result := NIL;
  ATopChlad.AktAmiSchemaF := NIL;

  if AC<>NIL then begin
    AVrstva := AC.Vrstva;
    BVrstva := AVrstva;
    if AVrstva<0 then begin
      ASch := AC.AnCm;
      if ASch is TAmiSchema then begin
        AVrstva := ASch.Vrstva;
      end;
    end;
    for i := 0 to AList.Count-1 do begin
      AX := AList[i];
      if AX.Vrstva=AVrstva then begin
        Result := AX;
        break;
      end;
    end;

    if (BVrstva<0) AND (Result is TAmiSchema) then begin
      for i := 0 to TAmiSchema(Result).Seznam3.Count-1 do begin
        AY := TAmiSchema(Result).Seznam3[i];
        if AY.Vrstva=BVrstva then begin
          ATopChlad.AktAmiSchemaF := AY;
          break;
        end;
      end;
    end;
  end;
end;

procedure TFrForm99.ZrcadloSvisle2Click(Sender: TObject);
begin
  KopirovatZrcadloveSvislaOsa_99;
end;

procedure TFrForm99.ZrcadloSvisleClick_99;
begin
  KopirovatZrcadloveSvislaOsa_99;
end;

procedure TFrForm99.ZrcadloVodorovne2Click(Sender: TObject);
begin
  KopirovatZrcadloveVodorovnaOsa_99;
end;

procedure TFrForm99.ZrcadloVodorovneClick_99;
begin
  KopirovatZrcadloveVodorovnaOsa_99;
end;

Function TFrForm99.ListUspVen2_99(Item1, Item2: Pointer): Integer;
var
  AC1, AC2 : TAmiClass;
  AKV1, AKV2 : extended;
  AT1, AT2 : TAmiClass;
  S1, S2 : String;
  AP1, AP2 : TAmiClass;
begin
  Result := 0;
  if Item1=Item2 then exit;

  AC1 := TAmiClass(Item1);
  AC2 := TAmiClass(Item2);
  AT1 := AC1.AmCl;
  AT2 := AC2.AmCl;
  S1 := '';
  S2 := '';

  if AT1 is TAmiTrubka then
    S1 := UpperCase(TAmiTrubka(AT1).Stoup);
  if AT2 is TAmiTrubka then
    S2 := UpperCase(TAmiTrubka(AT2).Stoup);

  // podle stupne paty
  if AT1.IntCisloPaty<AT2.IntCisloPaty then Result := -1
  else if AT1.IntCisloPaty>AT2.IntCisloPaty then Result := 1
  // podle stoup
  else if S1<S2 then Result := -1
  else if S1>S2 then Result := 1
  // podle typu ventilu
  else if FunVentUspVysledky(AC1.Typ)<FunVentUspVysledky(AC2.Typ) then Result := -1
  else if FunVentUspVysledky(AC1.Typ)>FunVentUspVysledky(AC2.Typ) then Result := 1
  // podle Symbolu
  else if UpperCase(TAmiVentil(AC1).Symbol)<UpperCase(TAmiVentil(AC2).Symbol) then Result := -1
  else if UpperCase(TAmiVentil(AC1).Symbol)>UpperCase(TAmiVentil(AC2).Symbol) then Result := 1
  else begin
//    AP1 := AC1.MujPokoj;
//    AP2 := AC2.MujPokoj;
    AP1 := DejVentCimru_99(AC1);
    AP2 := DejVentCimru_99(AC2);
    if Assigned(AP1) AND Assigned(AP2) then begin
      if UpperCase(TAmiPokoj(AP1).Symbol)<UpperCase(TAmiPokoj(AP2).Symbol) then Result := -1
      else if UpperCase(TAmiPokoj(AP1).Symbol)>UpperCase(TAmiPokoj(AP2).Symbol) then Result := 1
      else Result := 0;
    end else begin
      if Assigned(AP1) then Result := 1;
      if Assigned(AP2) then Result := -1;
    end;
  end;
end;

Function TFrForm99.DejMouCimru_99(AR : TAmiClass) : TAmiClass;
var
  i, j : integer;
  AC, AK, AP : TAmiClass;
  ObjemAC, ObjemAK, ObjemAP : extended;
  ObAmi : TAmiClass;
begin
  Result := NIL;
    ObAmi := NajdivAmiList_99(ATopChlad.AmiLispik, AR);
    AC := ObAmi.MujPokoj;
    AP := NajdivAmiList_99(ATopChlad.AmiVysledky, AC);

  Result := AP;
end;

Function TFrForm99.DejVentCimru_99(AV : TAmiClass) : TAmiClass;
var
  AP, AT, AR, AU : TAmiClass;
  i : integer;
begin
  Result := NIL;
  AT := DejTrubkuVentilu(AV);
  if Assigned(AT) AND Assigned(AV.Majitel) then begin
    AP := NIL;  // pokoj
    for i := 0 to AV.Majitel.Count-1 do begin
      AR := AV.Majitel[i];
      if (AR is TAmiRad1) OR (AR is TAmiRad2) then begin
        AU := AR.AmCl;
        if (AU = AR.AmCm) AND (AU is TAmiVenti2) then
          AU := AU.AmCm;
        if AT=AU then begin
          AP := DejMouCimru_99(AR);
          if AP is TAmiPokoj then begin
            Result := TAmiPokoj(AP);
            exit;
          end;
        end;

        AU := AR.AmCm;
        if (AU = AR.AmCm) AND (AU is TAmiVenti2) then
          AU := AU.AmCm;
        if AT=AU then begin
          AP := DejMouCimru_99(AR);
          if AP is TAmiPokoj then begin
            Result := TAmiPokoj(AP);
            exit;
          end;
        end;
      end;
    end;   // for i
  end;
end;

(*Function TFrForm99.ListUspVen2_99(Item1, Item2: Pointer): Integer;
var
  AC1, AC2 : TAmiClass;
  AKV1, AKV2 : extended;
  AT1, AT2 : TAmiClass;
  S1, S2 : String;
  AP1, AP2 : TAmiClass;
begin
  Result := 0;
  if Item1=Item2 then exit;

  AC1 := TAmiClass(Item1);
  AC2 := TAmiClass(Item2);
  AT1 := AC1.AmCl;
  AT2 := AC2.AmCl;
  S1 := '';
  S2 := '';

  if AT1 is TAmiTrubka then
    S1 := UpperCase(TAmiTrubka(AT1).Stoup);
  if AT2 is TAmiTrubka then
    S2 := UpperCase(TAmiTrubka(AT2).Stoup);

  // podle stupne paty
  if AT1.IntCisloPaty<AT2.IntCisloPaty then Result := -1
  else if AT1.IntCisloPaty>AT2.IntCisloPaty then Result := 1
  // podle stoup
  else if S1<S2 then Result := -1
  else if S1>S2 then Result := 1
  // podle typu ventilu
  else if FunVentUspVysledky(AC1.Typ)<FunVentUspVysledky(AC2.Typ) then Result := -1
  else if FunVentUspVysledky(AC1.Typ)>FunVentUspVysledky(AC2.Typ) then Result := 1
  // podle Symbolu
  else if UpperCase(TAmiVentil(AC1).Symbol)<UpperCase(TAmiVentil(AC2).Symbol) then Result := -1
  else if UpperCase(TAmiVentil(AC1).Symbol)>UpperCase(TAmiVentil(AC2).Symbol) then Result := 1
  else begin
//    AP1 := AC1.MujPokoj;
//    AP2 := AC2.MujPokoj;
    AP1 := DejVentCimru_99(AC1);
    AP2 := DejVentCimru_99(AC2);
    if Assigned(AP1) AND Assigned(AP2) then begin
      if UpperCase(TAmiPokoj(AP1).Symbol)<UpperCase(TAmiPokoj(AP2).Symbol) then Result := -1
      else if UpperCase(TAmiPokoj(AP1).Symbol)>UpperCase(TAmiPokoj(AP2).Symbol) then Result := 1
      else Result := 0;
    end else begin
      if Assigned(AP1) then Result := 1;
      if Assigned(AP2) then Result := -1;
    end;
  end;
end;*)

procedure TFrForm99.Zoomuj_99(Bod : TPoint; AWheelDelta : integer; var AHandled : boolean);
var
  ABod, RBod, TBod : TPoint;
begin
  ABod := PaintBox1.ScreenToClient(Bod);
  if (ABod.X>0) AND (ABod.X<PaintBox1.Width) AND
     (ABod.Y>0) AND (ABod.Y<PaintBox1.Height) then begin
    if AWheelDelta<>0 then begin
      if ((KoefZvetseni>=MinKoeficientZvetseni) AND (KoefZvetseni<=MaxKoeficientZvetseni)) OR
         ((KoefZvetseni<=MinKoeficientZvetseni) AND (AWheelDelta<0)) OR
         ((KoefZvetseni>=MaxKoeficientZvetseni) AND (AWheelDelta>0)) then begin
        DelejSpocRealBodik(PocAmi, ABod, KoefZvetseni, RBod);
        DelejSpocRealBodik(PocAmi, Point(0, 0), KoefZvetseni, TBod);
        DelejZoom_99(RBod, TBod, 2, AWheelDelta/120);
        AHandled := TRUE;
      end;
    end;
  end;
end;

procedure TFrForm99.FrFormMouseWheel(Sender: TObject; Shift: TShiftState;
  WheelDelta: Integer; MousePos: TPoint; var Handled: Boolean);
begin
  Zoomuj_99(MousePos, WheelDelta, Handled);
end;

(*procedure TFrForm99.ASkrytOknoPClick_99(ASkrytFormP : boolean);
begin
  SkrytFormP := ASkrytFormP;
  if SkrytFormP then begin
    ATopChlad.VybList.Clear;
    DelejOznAmi_99(NIL);
    AFormP.Hide;
  end;
  DelejTabulky_99;
  DelejInvalidu_99;
end; *)

procedure TFrForm99.SchovejFormP;
begin
  AFormP.Close;
{  if AFormP.Left<10000 then
    SourFormP := Point(AFormP.Left, AFormP.Top);
  AFormP.Left := 20000; }
end;

procedure TFrForm99.ASkrytOknoPClick_99(ASkrytFormP : boolean);
begin
  SkrytFormP := ASkrytFormP;
  if SkrytFormP then begin
    ATopChlad.VybList.Clear;
    DelejOznAmi_99(NIL);
    SchovejFormP;
  end;
  DelejTabulky_99;
  DelejInvalidu_99;
end;

procedure TFrForm99.NastavTimerAutoSave;
begin
  if TimerAutoSave<>NIL then begin
//    TimerAutoSave.Enabled := BSamoUkladani;
    TimerAutoSave.Enabled := TRUE;
    TimerAutoSave.Interval := 60000*IIntUkladani;
  end;
end;

Procedure AAFormKeyPress(var Key: Char);
begin
  Case Key of
    #1 : Key := #0;  // ctrl A
    #3 : Key := #0;  // ctrl C
    #22 : Key := #0; // ctrl V
    #24 : Key := #0; // ctrl X
  end;
end;

procedure TFrForm99.BitBtn11Click(Sender: TObject);
begin
  ToolWindowStoup.Hide;
  DelejUkazatOznaceniVetvi_99(FALSE);
//  ToolWindowStoup.Close;
end;

Function UdelejSingleFrForm99(AAFrForm99 : TFrForm99; Jak : integer; JmenoSouboru : String) : boolean;
var
  ProjOK : boolean;
  AJmenoSouboru : String;
  i : integer;
begin
  AJmenoSouboru := JmenoSouboru;
  if JmenoSouboru<>'' then
    DataDirectory := ExcludeTrailingBackslash(ExtractFilePath(JmenoSouboru));
  if AAFrForm99.UlozitProjekt_99 then begin
    case Jak of
      0 : begin
        ProjOK := AAFrForm99.NovyProjekt_99('');  // novy projekt
        if ProjOK then begin
          AAFrForm99.JeOblastProTisk := FALSE;
          with AAFrForm99.ATopChlad do begin
            OznList.Clear;
            VybList.Clear;

            H_Vyprazdni_Historii(TRUE);
            MinStoryCoUndo := 0;

            AmiLispik.ZnicList;
            AktAmiMove := NIL;
            AktAmiOzn  := NIL;
            AktAmiPom  := NIL;
            NastavDataPrazdnehoProjektu;
            AJmenoSouboru := JmenoProjektu;
          end;
          AAFrForm99.DelejInvalidu_99;
        end;
      end;
      1 : ProjOK := AAFrForm99.DelejPrecti1Click_99(JmenoSouboru)>=0;
      2 : ProjOK := AAFrForm99.DelejCtiProjekt_99(JmenoSouboru, FALSE);
    end;
    if ProjOK then begin
//      AFrForm99.UvolniToolWindows;
      AAFrForm99.OtevrenyProjekt := TRUE;
//      AAFrForm99.ATopChlad.UklidpoVypoctu;
      AAFrForm99.ATopChlad.PrycsVypoctem;
      AktFrForm99 := AAFrForm99;
      if AAFrForm99.AForm_A is TFormA then
        with TFormA(AAFrForm99.AForm_A) do begin
          DelejUmozniUpravy;
          NastavListyKnofliky(TRUE);
        end;

      if AAFrForm99.AForm_A is TForm_Rb1 then
        with TForm_Rb1(AAFrForm99.AForm_A) do begin
          NastavRibbonKnofliky(TRUE);
          if AAFrForm99.ATopChlad.AmiLispik.Count>0 then A_Klasika_0.Enabled := FALSE
                                                   else A_Klasika_0.Enabled := TRUE;
        end;

      if Jak>0 then begin
        AAFrForm99.DelejTabulky_99;
        AAFrForm99.ToolBZobr4Click_99;

{        if AAFrForm99.AForm_A is TFormA then
          with TFormA(AAFrForm99.AForm_A) do
            ToolB97Zobr4.Click;
        if AAFrForm99.AForm_A is TForm_Rb1 then
          with TForm_Rb1(AAFrForm99.AForm_A) do
            ToolB97Zobr4.Click; }
        if Jak=2 then begin
//          HistPosledniSouboru.Insert(0, JmenoSouboru);
          Form_Rb1.Ribbon1.AddRecentItem(JmenoSouboru);
        end;
      end;
      with AAFrForm99 do begin
        AForm_A.Caption := DejZakladniCaption+'  '+ATopChlad.DejIMIIMICaption;
        if AForm_A is TForm99 then
          AForm_A.Caption := ATopChlad.DejIMIIMICaption;
        if AForm_A is TForm_Rb1 then begin
//          TForm_Rb1(AForm_A).Ribbon1.Caption := AForm_A.Caption;
          TForm_Rb1(AForm_A).Ribbon1.DocumentName := ATopChlad.DejIMIIMICaption;
        end;
      end;

      Result := TRUE;
    end else begin
      Result := FALSE;
      if JmenoSouboru<>'' then begin
        for i := Form_Rb1.RibbonApplicationMenuBar1.RecentItems.Count-1 downto 0 do begin
          if UpperCase(Form_Rb1.RibbonApplicationMenuBar1.RecentItems.Items[i].Caption)=
            UpperCase(JmenoSouboru) then
            Form_Rb1.RibbonApplicationMenuBar1.RecentItems.Delete(i);
        end;
      end;

    end;
  end;
end;

Function DejZakladniCaption : String;
var
  AExt : String;
  L : integer;
  i, N : integer;
  buf : array[1..100] of char;
  PopisProgramu : String;
begin
  N := GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SISO3166CTRYNAME, @Buf, 100);
  LocaleCountry := Buf[1]+Buf[2];

  SIMIVerze := StrVerze+' '+CisloIMIVerze;
//  if UpperCase(LocaleCountry)='SE' then
//    SIMIVerze := StrVerze+' '+CisloIMIVerzeSE;

  IMIAMI0 := ExtractFileName(ParamStr(0));
  AExt := ExtractFileExt(IMIAMI0);
  L := Length(AExt);
  System.Delete(IMIAMI0, Length(IMIAMI0)-L+1, L);

//  IMIIMI := IMIAMI+'  '+SIMIVerze;
//  IMIIMI := 'Projekt IMItop : "dimenzování otopných a chladicích soustav"'+'  '+SIMIVerze;
  Case HesCos of
    -1 : PopisProgramu := IMIAMI2A;
    0 : PopisProgramu := IMIAMI2;
    1 : PopisProgramu := IMIAMI2C;
  end;
  IMIIMI := IMIAMI1+IMIAMI0+' - '+PopisProgramu+'  '+SIMIVerze;
  Result := IMIIMI;
end;

end.
